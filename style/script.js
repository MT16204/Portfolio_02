const ay = "modulepreload"
  , ly = function(s) {
    return "/" + s
}
  , lp = {}
  , cy = function(e, t, i) {
    let n = Promise.resolve();
    if (t && t.length > 0) {
        const r = document.getElementsByTagName("link");
        n = Promise.all(t.map(o => {
            if (o = ly(o),
            o in lp)
                return;
            lp[o] = !0;
            const a = o.endsWith(".css")
              , l = a ? '[rel="stylesheet"]' : "";
            if (!!i)
                for (let u = r.length - 1; u >= 0; u--) {
                    const d = r[u];
                    if (d.href === o && (!a || d.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${o}"]${l}`))
                return;
            const h = document.createElement("link");
            if (h.rel = a ? "stylesheet" : ay,
            a || (h.as = "script",
            h.crossOrigin = ""),
            h.href = o,
            document.head.appendChild(h),
            a)
                return new Promise( (u, d) => {
                    h.addEventListener("load", u),
                    h.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${o}`)))
                }
                )
        }
        ))
    }
    return n.then( () => e()).catch(r => {
        const o = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (o.payload = r,
        window.dispatchEvent(o),
        !o.defaultPrevented)
            throw r
    }
    )
};
function fr(s) {
    if (s === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return s
}
function S_(s, e) {
    s.prototype = Object.create(e.prototype),
    s.prototype.constructor = s,
    s.__proto__ = e
}
/*!
 * GSAP 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var ln = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, oa = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, xf, Mi, Ht, vn = 1e8, Lt = 1 / vn, bd = Math.PI * 2, hy = bd / 4, uy = 0, b_ = Math.sqrt, dy = Math.cos, fy = Math.sin, ci = function(e) {
    return typeof e == "string"
}, Gt = function(e) {
    return typeof e == "function"
}, br = function(e) {
    return typeof e == "number"
}, yf = function(e) {
    return typeof e > "u"
}, Kn = function(e) {
    return typeof e == "object"
}, Vi = function(e) {
    return e !== !1
}, vf = function() {
    return typeof window < "u"
}, Nl = function(e) {
    return Gt(e) || ci(e)
}, T_ = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, Si = Array.isArray, Td = /(?:-?\.?\d|\.)+/gi, E_ = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Vo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Gh = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, w_ = /[+-]=-?[.\d]+/, A_ = /[^,'"\[\]\s]+/gi, py = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, zt, pn, Ed, Mf, hn = {}, hh = {}, R_, C_ = function(e) {
    return (hh = Ks(e, hn)) && ji 
}, Sf = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
}, ll = function(e, t) {
    return !t && console.warn(e)
}, P_ = function(e, t) {
    return e && (hn[e] = t) && hh && (hh[e] = t) || hn
}, cl = function() {
    return 0
}, my = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, jc = {
    suppressEvents: !0,
    kill: !1
}, gy = {
    suppressEvents: !0
}, bf = {}, ts = [], wd = {}, L_, rn = {}, Vh = {}, cp = 30, Zc = [], Tf = "", Ef = function(e) {
    var t = e[0], i, n;
    if (Kn(t) || Gt(t) || (e = [e]),
    !(i = (t._gsap || {}).harness)) {
        for (n = Zc.length; n-- && !Zc[n].targetTest(t); )
            ;
        i = Zc[n]
    }
    for (n = e.length; n--; )
        e[n] && (e[n]._gsap || (e[n]._gsap = new t0(e[n],i))) || e.splice(n, 1);
    return e
}, Bs = function(e) {
    return e._gsap || Ef(Mn(e))[0]._gsap
}, I_ = function(e, t, i) {
    return (i = e[t]) && Gt(i) ? e[t]() : yf(i) && e.getAttribute && e.getAttribute(t) || i
}, Wi = function(e, t) {
    return (e = e.split(",")).forEach(t) || e
}, Wt = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, li = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0
}, Zo = function(e, t) {
    var i = t.charAt(0)
      , n = parseFloat(t.substr(2));
    return e = parseFloat(e),
    i === "+" ? e + n : i === "-" ? e - n : i === "*" ? e * n : e / n
}, _y = function(e, t) {
    for (var i = t.length, n = 0; e.indexOf(t[n]) < 0 && ++n < i; )
        ;
    return n < i
}, uh = function() {
    var e = ts.length, t = ts.slice(0), i, n;
    for (wd = {},
    ts.length = 0,
    i = 0; i < e; i++)
        n = t[i],
        n && n._lazy && (n.render(n._lazy[0], n._lazy[1], !0)._lazy = 0)
}, D_ = function(e, t, i, n) {
    ts.length && !Mi && uh(),
    e.render(t, i, n || Mi && t < 0 && (e._initted || e._startAt)),
    ts.length && !Mi && uh()
}, U_ = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(A_).length < 2 ? t : ci(e) ? e.trim() : e
}, N_ = function(e) {
    return e
}, Tn = function(e, t) {
    for (var i in t)
        i in e || (e[i] = t[i]);
    return e
}, xy = function(e) {
    return function(t, i) {
        for (var n in i)
            n in t || n === "duration" && e || n === "ease" || (t[n] = i[n])
    }
}, Ks = function(e, t) {
    for (var i in t)
        e[i] = t[i];
    return e
}, hp = function s(e, t) {
    for (var i in t)
        i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = Kn(t[i]) ? s(e[i] || (e[i] = {}), t[i]) : t[i]);
    return e
}, dh = function(e, t) {
    var i = {}, n;
    for (n in e)
        n in t || (i[n] = e[n]);
    return i
}, Wa = function(e) {
    var t = e.parent || zt
      , i = e.keyframes ? xy(Si(e.keyframes)) : Tn;
    if (Vi(e.inherit))
        for (; t; )
            i(e, t.vars.defaults),
            t = t.parent || t._dp;
    return e
}, yy = function(e, t) {
    for (var i = e.length, n = i === t.length; n && i-- && e[i] === t[i]; )
        ;
    return i < 0
}, F_ = function(e, t, i, n, r) {
    i === void 0 && (i = "_first"),
    n === void 0 && (n = "_last");
    var o = e[n], a;
    if (r)
        for (a = t[r]; o && o[r] > a; )
            o = o._prev;
    return o ? (t._next = o._next,
    o._next = t) : (t._next = e[i],
    e[i] = t),
    t._next ? t._next._prev = t : e[n] = t,
    t._prev = o,
    t.parent = t._dp = e,
    t
}, Ch = function(e, t, i, n) {
    i === void 0 && (i = "_first"),
    n === void 0 && (n = "_last");
    var r = t._prev
      , o = t._next;
    r ? r._next = o : e[i] === t && (e[i] = o),
    o ? o._prev = r : e[n] === t && (e[n] = r),
    t._next = t._prev = t.parent = null
}, ls = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
    e._act = 0
}, zs = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
        for (var i = e; i; )
            i._dirty = 1,
            i = i.parent;
    return e
}, vy = function(e) {
    for (var t = e.parent; t && t.parent; )
        t._dirty = 1,
        t.totalDuration(),
        t = t.parent;
    return e
}, Ad = function(e, t, i, n) {
    return e._startAt && (Mi ? e._startAt.revert(jc) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, n))
}, My = function s(e) {
    return !e || e._ts && s(e.parent)
}, up = function(e) {
    return e._repeat ? aa(e._tTime, e = e.duration() + e._rDelay) * e : 0
}, aa = function(e, t) {
    var i = Math.floor(e /= t);
    return e && i === e ? i - 1 : i
}, fh = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
}, Ph = function(e) {
    return e._end = li(e._start + (e._tDur / Math.abs(e._ts || e._rts || Lt) || 0))
}, Lh = function(e, t) {
    var i = e._dp;
    return i && i.smoothChildTiming && e._ts && (e._start = li(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
    Ph(e),
    i._dirty || zs(i, e)),
    e
}, O_ = function(e, t) {
    var i;
    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = fh(e.rawTime(), t),
    (!t._dur || wl(0, t.totalDuration(), i) - t._tTime > Lt) && t.render(i, !0)),
    zs(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
        if (e._dur < e.duration())
            for (i = e; i._dp; )
                i.rawTime() >= 0 && i.totalTime(i._tTime),
                i = i._dp;
        e._zTime = -Lt
    }
}, Vn = function(e, t, i, n) {
    return t.parent && ls(t),
    t._start = li((br(i) ? i : i || e !== zt ? fn(e, i, t) : e._time) + t._delay),
    t._end = li(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
    F_(e, t, "_first", "_last", e._sort ? "_start" : 0),
    Rd(t) || (e._recent = t),
    n || O_(e, t),
    e._ts < 0 && Lh(e, e._tTime),
    e
}, B_ = function(e, t) {
    return (hn.ScrollTrigger || Sf("scrollTrigger", t)) && hn.ScrollTrigger.create(t, e)
}, z_ = function(e, t, i, n, r) {
    if (Af(e, t, r),
    !e._initted)
        return 1;
    if (!i && e._pt && !Mi && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && L_ !== sn.frame)
        return ts.push(e),
        e._lazy = [r, n],
        1
}, Sy = function s(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || s(t))
}, Rd = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart"
}, by = function(e, t, i, n) {
    var r = e.ratio, o = t < 0 || !t && (!e._start && Sy(e) && !(!e._initted && Rd(e)) || (e._ts < 0 || e._dp._ts < 0) && !Rd(e)) ? 0 : 1, a = e._rDelay, l = 0, c, h, u;
    if (a && e._repeat && (l = wl(0, e._tDur, t),
    h = aa(l, a),
    e._yoyo && h & 1 && (o = 1 - o),
    h !== aa(e._tTime, a) && (r = 1 - o,
    e.vars.repeatRefresh && e._initted && e.invalidate())),
    o !== r || Mi || n || e._zTime === Lt || !t && e._zTime) {
        if (!e._initted && z_(e, t, n, i, l))
            return;
        for (u = e._zTime,
        e._zTime = t || (i ? Lt : 0),
        i || (i = t && !u),
        e.ratio = o,
        e._from && (o = 1 - o),
        e._time = 0,
        e._tTime = l,
        c = e._pt; c; )
            c.r(o, c.d),
            c = c._next;
        t < 0 && Ad(e, t, i, !0),
        e._onUpdate && !i && an(e, "onUpdate"),
        l && e._repeat && !i && e.parent && an(e, "onRepeat"),
        (t >= e._tDur || t < 0) && e.ratio === o && (o && ls(e, 1),
        !i && !Mi && (an(e, o ? "onComplete" : "onReverseComplete", !0),
        e._prom && e._prom()))
    } else
        e._zTime || (e._zTime = t)
}, Ty = function(e, t, i) {
    var n;
    if (i > t)
        for (n = e._first; n && n._start <= i; ) {
            if (n.data === "isPause" && n._start > t)
                return n;
            n = n._next
        }
    else
        for (n = e._last; n && n._start >= i; ) {
            if (n.data === "isPause" && n._start < t)
                return n;
            n = n._prev
        }
}, la = function(e, t, i, n) {
    var r = e._repeat
      , o = li(t) || 0
      , a = e._tTime / e._tDur;
    return a && !n && (e._time *= o / e._dur),
    e._dur = o,
    e._tDur = r ? r < 0 ? 1e10 : li(o * (r + 1) + e._rDelay * r) : o,
    a > 0 && !n && Lh(e, e._tTime = e._tDur * a),
    e.parent && Ph(e),
    i || zs(e.parent, e),
    e
}, dp = function(e) {
    return e instanceof Ui ? zs(e) : la(e, e._dur)
}, Ey = {
    _start: 0,
    endTime: cl,
    totalDuration: cl
}, fn = function s(e, t, i) {
    var n = e.labels, r = e._recent || Ey, o = e.duration() >= vn ? r.endTime(!1) : e._dur, a, l, c;
    return ci(t) && (isNaN(t) || t in n) ? (l = t.charAt(0),
    c = t.substr(-1) === "%",
    a = t.indexOf("="),
    l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")),
    (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? r : i).totalDuration() / 100 : 1)) : a < 0 ? (t in n || (n[t] = o),
    n[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)),
    c && i && (l = l / 100 * (Si(i) ? i[0] : i).totalDuration()),
    a > 1 ? s(e, t.substr(0, a - 1), i) + l : o + l)) : t == null ? o : +t
}, Xa = function(e, t, i) {
    var n = br(t[1]), r = (n ? 2 : 1) + (e < 2 ? 0 : 1), o = t[r], a, l;
    if (n && (o.duration = t[1]),
    o.parent = i,
    e) {
        for (a = o,
        l = i; l && !("immediateRender"in a); )
            a = l.vars.defaults || {},
            l = Vi(l.vars.inherit) && l.parent;
        o.immediateRender = Vi(a.immediateRender),
        e < 2 ? o.runBackwards = 1 : o.startAt = t[r - 1]
    }
    return new Zt(t[0],o,t[r + 1])
}, ds = function(e, t) {
    return e || e === 0 ? t(e) : t
}, wl = function(e, t, i) {
    return i < e ? e : i > t ? t : i
}, vi = function(e, t) {
    return !ci(e) || !(t = py.exec(e)) ? "" : t[1]
}, wy = function(e, t, i) {
    return ds(i, function(n) {
        return wl(e, t, n)
    })
}, Cd = [].slice, k_ = function(e, t) {
    return e && Kn(e) && "length"in e && (!t && !e.length || e.length - 1 in e && Kn(e[0])) && !e.nodeType && e !== pn
}, Ay = function(e, t, i) {
    return i === void 0 && (i = []),
    e.forEach(function(n) {
        var r;
        return ci(n) && !t || k_(n, 1) ? (r = i).push.apply(r, Mn(n)) : i.push(n)
    }) || i
}, Mn = function(e, t, i) {
    return Ht && !t && Ht.selector ? Ht.selector(e) : ci(e) && !i && (Ed || !ca()) ? Cd.call((t || Mf).querySelectorAll(e), 0) : Si(e) ? Ay(e, i) : k_(e) ? Cd.call(e, 0) : e ? [e] : []
}, Pd = function(e) {
    return e = Mn(e)[0] || ll("Invalid scope") || {},
    function(t) {
        var i = e.current || e.nativeElement || e;
        return Mn(t, i.querySelectorAll ? i : i === e ? ll("Invalid scope") || Mf.createElement("div") : e)
    }
}, H_ = function(e) {
    return e.sort(function() {
        return .5 - Math.random()
    })
}, G_ = function(e) {
    if (Gt(e))
        return e;
    var t = Kn(e) ? e : {
        each: e
    }
      , i = ks(t.ease)
      , n = t.from || 0
      , r = parseFloat(t.base) || 0
      , o = {}
      , a = n > 0 && n < 1
      , l = isNaN(n) || a
      , c = t.axis
      , h = n
      , u = n;
    return ci(n) ? h = u = {
        center: .5,
        edges: .5,
        end: 1
    }[n] || 0 : !a && l && (h = n[0],
    u = n[1]),
    function(d, f, m) {
        var _ = (m || t).length, p = o[_], g, M, y, S, C, w, T, B, b;
        if (!p) {
            if (b = t.grid === "auto" ? 0 : (t.grid || [1, vn])[1],
            !b) {
                for (T = -vn; T < (T = m[b++].getBoundingClientRect().left) && b < _; )
                    ;
                b < _ && b--
            }
            for (p = o[_] = [],
            g = l ? Math.min(b, _) * h - .5 : n % b,
            M = b === vn ? 0 : l ? _ * u / b - .5 : n / b | 0,
            T = 0,
            B = vn,
            w = 0; w < _; w++)
                y = w % b - g,
                S = M - (w / b | 0),
                p[w] = C = c ? Math.abs(c === "y" ? S : y) : b_(y * y + S * S),
                C > T && (T = C),
                C < B && (B = C);
            n === "random" && H_(p),
            p.max = T - B,
            p.min = B,
            p.v = _ = (parseFloat(t.amount) || parseFloat(t.each) * (b > _ ? _ - 1 : c ? c === "y" ? _ / b : b : Math.max(b, _ / b)) || 0) * (n === "edges" ? -1 : 1),
            p.b = _ < 0 ? r - _ : r,
            p.u = vi(t.amount || t.each) || 0,
            i = i && _ < 0 ? J_(i) : i
        }
        return _ = (p[d] - p.min) / p.max || 0,
        li(p.b + (i ? i(_) : _) * p.v) + p.u
    }
}, Ld = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(i) {
        var n = li(Math.round(parseFloat(i) / e) * e * t);
        return (n - n % 1) / t + (br(i) ? 0 : vi(i))
    }
}, V_ = function(e, t) {
    var i = Si(e), n, r;
    return !i && Kn(e) && (n = i = e.radius || vn,
    e.values ? (e = Mn(e.values),
    (r = !br(e[0])) && (n *= n)) : e = Ld(e.increment)),
    ds(t, i ? Gt(e) ? function(o) {
        return r = e(o),
        Math.abs(r - o) <= n ? r : o
    }
    : function(o) {
        for (var a = parseFloat(r ? o.x : o), l = parseFloat(r ? o.y : 0), c = vn, h = 0, u = e.length, d, f; u--; )
            r ? (d = e[u].x - a,
            f = e[u].y - l,
            d = d * d + f * f) : d = Math.abs(e[u] - a),
            d < c && (c = d,
            h = u);
        return h = !n || c <= n ? e[h] : o,
        r || h === o || br(o) ? h : h + vi(o)
    }
    : Ld(e))
}, W_ = function(e, t, i, n) {
    return ds(Si(e) ? !t : i === !0 ? !!(i = 0) : !n, function() {
        return Si(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * .99)) / i) * i * n) / n
    })
}, Ry = function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
    return function(n) {
        return t.reduce(function(r, o) {
            return o(r)
        }, n)
    }
}, Cy = function(e, t) {
    return function(i) {
        return e(parseFloat(i)) + (t || vi(i))
    }
}, Py = function(e, t, i) {
    return q_(e, t, 0, 1, i)
}, X_ = function(e, t, i) {
    return ds(i, function(n) {
        return e[~~t(n)]
    })
}, Ly = function s(e, t, i) {
    var n = t - e;
    return Si(e) ? X_(e, s(0, e.length), t) : ds(i, function(r) {
        return (n + (r - e) % n) % n + e
    })
}, Iy = function s(e, t, i) {
    var n = t - e
      , r = n * 2;
    return Si(e) ? X_(e, s(0, e.length - 1), t) : ds(i, function(o) {
        return o = (r + (o - e) % r) % r || 0,
        e + (o > n ? r - o : o)
    })
}, hl = function(e) {
    for (var t = 0, i = "", n, r, o, a; ~(n = e.indexOf("random(", t)); )
        o = e.indexOf(")", n),
        a = e.charAt(n + 7) === "[",
        r = e.substr(n + 7, o - n - 7).match(a ? A_ : Td),
        i += e.substr(t, n - t) + W_(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5),
        t = o + 1;
    return i + e.substr(t, e.length - t)
}, q_ = function(e, t, i, n, r) {
    var o = t - e
      , a = n - i;
    return ds(r, function(l) {
        return i + ((l - e) / o * a || 0)
    })
}, Dy = function s(e, t, i, n) {
    var r = isNaN(e + t) ? 0 : function(f) {
        return (1 - f) * e + f * t
    }
    ;
    if (!r) {
        var o = ci(e), a = {}, l, c, h, u, d;
        if (i === !0 && (n = 1) && (i = null),
        o)
            e = {
                p: e
            },
            t = {
                p: t
            };
        else if (Si(e) && !Si(t)) {
            for (h = [],
            u = e.length,
            d = u - 2,
            c = 1; c < u; c++)
                h.push(s(e[c - 1], e[c]));
            u--,
            r = function(m) {
                m *= u;
                var _ = Math.min(d, ~~m);
                return h[_](m - _)
            }
            ,
            i = t
        } else
            n || (e = Ks(Si(e) ? [] : {}, e));
        if (!h) {
            for (l in t)
                wf.call(a, e, l, "get", t[l]);
            r = function(m) {
                return Pf(m, a) || (o ? e.p : e)
            }
        }
    }
    return ds(i, r)
}, fp = function(e, t, i) {
    var n = e.labels, r = vn, o, a, l;
    for (o in n)
        a = n[o] - t,
        a < 0 == !!i && a && r > (a = Math.abs(a)) && (l = o,
        r = a);
    return l
}, an = function(e, t, i) {
    var n = e.vars, r = n[t], o = Ht, a = e._ctx, l, c, h;
    if (r)
        return l = n[t + "Params"],
        c = n.callbackScope || e,
        i && ts.length && uh(),
        a && (Ht = a),
        h = l ? r.apply(c, l) : r.call(c),
        Ht = o,
        h
}, za = function(e) {
    return ls(e),
    e.scrollTrigger && e.scrollTrigger.kill(!!Mi),
    e.progress() < 1 && an(e, "onInterrupt"),
    e
}, Wo, Y_ = [], $_ = function(e) {
    if (vf() && e) {
        e = !e.name && e.default || e;
        var t = e.name
          , i = Gt(e)
          , n = t && !i && e.init ? function() {
            this._props = []
        }
        : e
          , r = {
            init: cl,
            render: Pf,
            add: wf,
            kill: jy,
            modifier: $y,
            rawVars: 0
        }
          , o = {
            targetTest: 0,
            get: 0,
            getSetter: Cf,
            aliases: {},
            register: 0
        };
        if (ca(),
        e !== n) {
            if (rn[t])
                return;
            Tn(n, Tn(dh(e, r), o)),
            Ks(n.prototype, Ks(r, dh(e, o))),
            rn[n.prop = t] = n,
            e.targetTest && (Zc.push(n),
            bf[t] = 1),
            t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
        }
        P_(t, n),
        e.register && e.register(ji, n, Xi)
    } else
        e && Y_.push(e)
}, Pt = 255, ka = {
    aqua: [0, Pt, Pt],
    lime: [0, Pt, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Pt],
    navy: [0, 0, 128],
    white: [Pt, Pt, Pt],
    olive: [128, 128, 0],
    yellow: [Pt, Pt, 0],
    orange: [Pt, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Pt, 0, 0],
    pink: [Pt, 192, 203],
    cyan: [0, Pt, Pt],
    transparent: [Pt, Pt, Pt, 0]
}, Wh = function(e, t, i) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0,
    (e * 6 < 1 ? t + (i - t) * e * 6 : e < .5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * Pt + .5 | 0
}, j_ = function(e, t, i) {
    var n = e ? br(e) ? [e >> 16, e >> 8 & Pt, e & Pt] : 0 : ka.black, r, o, a, l, c, h, u, d, f, m;
    if (!n) {
        if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        ka[e])
            n = ka[e];
        else if (e.charAt(0) === "#") {
            if (e.length < 6 && (r = e.charAt(1),
            o = e.charAt(2),
            a = e.charAt(3),
            e = "#" + r + r + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")),
            e.length === 9)
                return n = parseInt(e.substr(1, 6), 16),
                [n >> 16, n >> 8 & Pt, n & Pt, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16),
            n = [e >> 16, e >> 8 & Pt, e & Pt]
        } else if (e.substr(0, 3) === "hsl") {
            if (n = m = e.match(Td),
            !t)
                l = +n[0] % 360 / 360,
                c = +n[1] / 100,
                h = +n[2] / 100,
                o = h <= .5 ? h * (c + 1) : h + c - h * c,
                r = h * 2 - o,
                n.length > 3 && (n[3] *= 1),
                n[0] = Wh(l + 1 / 3, r, o),
                n[1] = Wh(l, r, o),
                n[2] = Wh(l - 1 / 3, r, o);
            else if (~e.indexOf("="))
                return n = e.match(E_),
                i && n.length < 4 && (n[3] = 1),
                n
        } else
            n = e.match(Td) || ka.transparent;
        n = n.map(Number)
    }
    return t && !m && (r = n[0] / Pt,
    o = n[1] / Pt,
    a = n[2] / Pt,
    u = Math.max(r, o, a),
    d = Math.min(r, o, a),
    h = (u + d) / 2,
    u === d ? l = c = 0 : (f = u - d,
    c = h > .5 ? f / (2 - u - d) : f / (u + d),
    l = u === r ? (o - a) / f + (o < a ? 6 : 0) : u === o ? (a - r) / f + 2 : (r - o) / f + 4,
    l *= 60),
    n[0] = ~~(l + .5),
    n[1] = ~~(c * 100 + .5),
    n[2] = ~~(h * 100 + .5)),
    i && n.length < 4 && (n[3] = 1),
    n
}, Z_ = function(e) {
    var t = []
      , i = []
      , n = -1;
    return e.split(is).forEach(function(r) {
        var o = r.match(Vo) || [];
        t.push.apply(t, o),
        i.push(n += o.length + 1)
    }),
    t.c = i,
    t
}, pp = function(e, t, i) {
    var n = "", r = (e + n).match(is), o = t ? "hsla(" : "rgba(", a = 0, l, c, h, u;
    if (!r)
        return e;
    if (r = r.map(function(d) {
        return (d = j_(d, t, 1)) && o + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
    }),
    i && (h = Z_(e),
    l = i.c,
    l.join(n) !== h.c.join(n)))
        for (c = e.replace(is, "1").split(Vo),
        u = c.length - 1; a < u; a++)
            n += c[a] + (~l.indexOf(a) ? r.shift() || o + "0,0,0,0)" : (h.length ? h : r.length ? r : i).shift());
    if (!c)
        for (c = e.split(is),
        u = c.length - 1; a < u; a++)
            n += c[a] + r[a];
    return n + c[u]
}, is = function() {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in ka)
        s += "|" + e + "\\b";
    return new RegExp(s + ")","gi")
}(), Uy = /hsl[a]?\(/, K_ = function(e) {
    var t = e.join(" "), i;
    if (is.lastIndex = 0,
    is.test(t))
        return i = Uy.test(t),
        e[1] = pp(e[1], i),
        e[0] = pp(e[0], i, Z_(e[1])),
        !0
}, ul, sn = function() {
    var s = Date.now, e = 500, t = 33, i = s(), n = i, r = 1e3 / 240, o = r, a = [], l, c, h, u, d, f, m = function _(p) {
        var g = s() - n, M = p === !0, y, S, C, w;
        if (g > e && (i += g - t),
        n += g,
        C = n - i,
        y = C - o,
        (y > 0 || M) && (w = ++u.frame,
        d = C - u.time * 1e3,
        u.time = C = C / 1e3,
        o += y + (y >= r ? 4 : r - y),
        S = 1),
        M || (l = c(_)),
        S)
            for (f = 0; f < a.length; f++)
                a[f](C, d, w, p)
    };
    return u = {
        time: 0,
        frame: 0,
        tick: function() {
            m(!0)
        },
        deltaRatio: function(p) {
            return d / (1e3 / (p || 60))
        },
        wake: function() {
            R_ && (!Ed && vf() && (pn = Ed = window,
            Mf = pn.document || {},
            hn.gsap = ji,
            (pn.gsapVersions || (pn.gsapVersions = [])).push(ji.version),
            C_(hh || pn.GreenSockGlobals || !pn.gsap && pn || {}),
            h = pn.requestAnimationFrame,
            Y_.forEach($_)),
            l && u.sleep(),
            c = h || function(p) {
                return setTimeout(p, o - u.time * 1e3 + 1 | 0)
            }
            ,
            ul = 1,
            m(2))
        },
        sleep: function() {
            (h ? pn.cancelAnimationFrame : clearTimeout)(l),
            ul = 0,
            c = cl
        },
        lagSmoothing: function(p, g) {
            e = p || 1 / 0,
            t = Math.min(g || 33, e)
        },
        fps: function(p) {
            r = 1e3 / (p || 240),
            o = u.time * 1e3 + r
        },
        add: function(p, g, M) {
            var y = g ? function(S, C, w, T) {
                p(S, C, w, T),
                u.remove(y)
            }
            : p;
            return u.remove(p),
            a[M ? "unshift" : "push"](y),
            ca(),
            y
        },
        remove: function(p, g) {
            ~(g = a.indexOf(p)) && a.splice(g, 1) && f >= g && f--
        },
        _listeners: a
    },
    u
}(), ca = function() {
    return !ul && sn.wake()
}, yt = {}, Ny = /^[\d.\-M][\d.\-,\s]/, Fy = /["']/g, Oy = function(e) {
    for (var t = {}, i = e.substr(1, e.length - 3).split(":"), n = i[0], r = 1, o = i.length, a, l, c; r < o; r++)
        l = i[r],
        a = r !== o - 1 ? l.lastIndexOf(",") : l.length,
        c = l.substr(0, a),
        t[n] = isNaN(c) ? c.replace(Fy, "").trim() : +c,
        n = l.substr(a + 1).trim();
    return t
}, By = function(e) {
    var t = e.indexOf("(") + 1
      , i = e.indexOf(")")
      , n = e.indexOf("(", t);
    return e.substring(t, ~n && n < i ? e.indexOf(")", i + 1) : i)
}, zy = function(e) {
    var t = (e + "").split("(")
      , i = yt[t[0]];
    return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [Oy(t[1])] : By(e).split(",").map(U_)) : yt._CE && Ny.test(e) ? yt._CE("", e) : i
}, J_ = function(e) {
    return function(t) {
        return 1 - e(1 - t)
    }
}, Q_ = function s(e, t) {
    for (var i = e._first, n; i; )
        i instanceof Ui ? s(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? s(i.timeline, t) : (n = i._ease,
        i._ease = i._yEase,
        i._yEase = n,
        i._yoyo = t)),
        i = i._next
}, ks = function(e, t) {
    return e && (Gt(e) ? e : yt[e] || zy(e)) || t
}, ro = function(e, t, i, n) {
    i === void 0 && (i = function(l) {
        return 1 - t(1 - l)
    }
    ),
    n === void 0 && (n = function(l) {
        return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
    }
    );
    var r = {
        easeIn: t,
        easeOut: i,
        easeInOut: n
    }, o;
    return Wi(e, function(a) {
        yt[a] = hn[a] = r,
        yt[o = a.toLowerCase()] = i;
        for (var l in r)
            yt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = yt[a + "." + l] = r[l]
    }),
    r
}, e0 = function(e) {
    return function(t) {
        return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
    }
}, Xh = function s(e, t, i) {
    var n = t >= 1 ? t : 1
      , r = (i || (e ? .3 : .45)) / (t < 1 ? t : 1)
      , o = r / bd * (Math.asin(1 / n) || 0)
      , a = function(h) {
        return h === 1 ? 1 : n * Math.pow(2, -10 * h) * fy((h - o) * r) + 1
    }
      , l = e === "out" ? a : e === "in" ? function(c) {
        return 1 - a(1 - c)
    }
    : e0(a);
    return r = bd / r,
    l.config = function(c, h) {
        return s(e, c, h)
    }
    ,
    l
}, qh = function s(e, t) {
    t === void 0 && (t = 1.70158);
    var i = function(o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0
    }
      , n = e === "out" ? i : e === "in" ? function(r) {
        return 1 - i(1 - r)
    }
    : e0(i);
    return n.config = function(r) {
        return s(e, r)
    }
    ,
    n
};
Wi("Linear,Quad,Cubic,Quart,Quint,Strong", function(s, e) {
    var t = e < 5 ? e + 1 : e;
    ro(s + ",Power" + (t - 1), e ? function(i) {
        return Math.pow(i, t)
    }
    : function(i) {
        return i
    }
    , function(i) {
        return 1 - Math.pow(1 - i, t)
    }, function(i) {
        return i < .5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2
    })
});
yt.Linear.easeNone = yt.none = yt.Linear.easeIn;
ro("Elastic", Xh("in"), Xh("out"), Xh());
(function(s, e) {
    var t = 1 / e
      , i = 2 * t
      , n = 2.5 * t
      , r = function(a) {
        return a < t ? s * a * a : a < i ? s * Math.pow(a - 1.5 / e, 2) + .75 : a < n ? s * (a -= 2.25 / e) * a + .9375 : s * Math.pow(a - 2.625 / e, 2) + .984375
    };
    ro("Bounce", function(o) {
        return 1 - r(1 - o)
    }, r)
}
)(7.5625, 2.75);
ro("Expo", function(s) {
    return s ? Math.pow(2, 10 * (s - 1)) : 0
});
ro("Circ", function(s) {
    return -(b_(1 - s * s) - 1)
});
ro("Sine", function(s) {
    return s === 1 ? 1 : -dy(s * hy) + 1
});
ro("Back", qh("in"), qh("out"), qh());
yt.SteppedEase = yt.steps = hn.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var i = 1 / e
          , n = e + (t ? 0 : 1)
          , r = t ? 1 : 0
          , o = 1 - Lt;
        return function(a) {
            return ((n * wl(0, o, a) | 0) + r) * i
        }
    }
};
oa.ease = yt["quad.out"];
Wi("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(s) {
    return Tf += s + "," + s + "Params,"
});
var t0 = function(e, t) {
    this.id = uy++,
    e._gsap = this,
    this.target = e,
    this.harness = t,
    this.get = t ? t.get : I_,
    this.set = t ? t.getSetter : Cf
}
  , dl = function() {
    function s(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        la(this, +t.duration, 1, 1),
        this.data = t.data,
        Ht && (this._ctx = Ht,
        Ht.data.push(this)),
        ul || sn.wake()
    }
    var e = s.prototype;
    return e.delay = function(i) {
        return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay),
        this._delay = i,
        this) : this._delay
    }
    ,
    e.duration = function(i) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(i) {
        return arguments.length ? (this._dirty = 0,
        la(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(i, n) {
        if (ca(),
        !arguments.length)
            return this._tTime;
        var r = this._dp;
        if (r && r.smoothChildTiming && this._ts) {
            for (Lh(this, i),
            !r._dp || r.parent || O_(r, this); r && r.parent; )
                r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0),
                r = r.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && Vn(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== i || !this._dur && !n || this._initted && Math.abs(this._zTime) === Lt || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i),
        D_(this, i, n)),
        this
    }
    ,
    e.time = function(i, n) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + up(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), n) : this._time
    }
    ,
    e.totalProgress = function(i, n) {
        return arguments.length ? this.totalTime(this.totalDuration() * i, n) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.progress = function(i, n) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + up(this), n) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.iteration = function(i, n) {
        var r = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (i - 1) * r, n) : this._repeat ? aa(this._tTime, r) + 1 : 1
    }
    ,
    e.timeScale = function(i, n) {
        if (!arguments.length)
            return this._rts === -Lt ? 0 : this._rts;
        if (this._rts === i)
            return this;
        var r = this.parent && this._ts ? fh(this.parent._time, this) : this._tTime;
        return this._rts = +i || 0,
        this._ts = this._ps || i === -Lt ? 0 : this._rts,
        this.totalTime(wl(-Math.abs(this._delay), this._tDur, r), n !== !1),
        Ph(this),
        vy(this)
    }
    ,
    e.paused = function(i) {
        return arguments.length ? (this._ps !== i && (this._ps = i,
        i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (ca(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Lt && (this._tTime -= Lt)))),
        this) : this._ps
    }
    ,
    e.startTime = function(i) {
        if (arguments.length) {
            this._start = i;
            var n = this.parent || this._dp;
            return n && (n._sort || !this.parent) && Vn(n, this, i - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(i) {
        return this._start + (Vi(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(i) {
        var n = this.parent || this._dp;
        return n ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? fh(n.rawTime(i), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(i) {
        i === void 0 && (i = gy);
        var n = Mi;
        return Mi = i,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i),
        this.totalTime(-.01, i.suppressEvents)),
        this.data !== "nested" && i.kill !== !1 && this.kill(),
        Mi = n,
        this
    }
    ,
    e.globalTime = function(i) {
        for (var n = this, r = arguments.length ? i : n.rawTime(); n; )
            r = n._start + r / (Math.abs(n._ts) || 1),
            n = n._dp;
        return !this.parent && this._sat ? this._sat.globalTime(i) : r
    }
    ,
    e.repeat = function(i) {
        return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i,
        dp(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(i) {
        if (arguments.length) {
            var n = this._time;
            return this._rDelay = i,
            dp(this),
            n ? this.time(n) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(i) {
        return arguments.length ? (this._yoyo = i,
        this) : this._yoyo
    }
    ,
    e.seek = function(i, n) {
        return this.totalTime(fn(this, i), Vi(n))
    }
    ,
    e.restart = function(i, n) {
        return this.play().totalTime(i ? -this._delay : 0, Vi(n))
    }
    ,
    e.play = function(i, n) {
        return i != null && this.seek(i, n),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(i, n) {
        return i != null && this.seek(i || this.totalDuration(), n),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(i, n) {
        return i != null && this.seek(i, n),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(i) {
        return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -Lt : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -Lt,
        this
    }
    ,
    e.isActive = function() {
        var i = this.parent || this._dp, n = this._start, r;
        return !!(!i || this._ts && this._initted && i.isActive() && (r = i.rawTime(!0)) >= n && r < this.endTime(!0) - Lt)
    }
    ,
    e.eventCallback = function(i, n, r) {
        var o = this.vars;
        return arguments.length > 1 ? (n ? (o[i] = n,
        r && (o[i + "Params"] = r),
        i === "onUpdate" && (this._onUpdate = n)) : delete o[i],
        this) : o[i]
    }
    ,
    e.then = function(i) {
        var n = this;
        return new Promise(function(r) {
            var o = Gt(i) ? i : N_
              , a = function() {
                var c = n.then;
                n.then = null,
                Gt(o) && (o = o(n)) && (o.then || o === n) && (n.then = c),
                r(o),
                n.then = c
            };
            n._initted && n.totalProgress() === 1 && n._ts >= 0 || !n._tTime && n._ts < 0 ? a() : n._prom = a
        }
        )
    }
    ,
    e.kill = function() {
        za(this)
    }
    ,
    s
}();
Tn(dl.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Lt,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Ui = function(s) {
    S_(e, s);
    function e(i, n) {
        var r;
        return i === void 0 && (i = {}),
        r = s.call(this, i) || this,
        r.labels = {},
        r.smoothChildTiming = !!i.smoothChildTiming,
        r.autoRemoveChildren = !!i.autoRemoveChildren,
        r._sort = Vi(i.sortChildren),
        zt && Vn(i.parent || zt, fr(r), n),
        i.reversed && r.reverse(),
        i.paused && r.paused(!0),
        i.scrollTrigger && B_(fr(r), i.scrollTrigger),
        r
    }
    var t = e.prototype;
    return t.to = function(n, r, o) {
        return Xa(0, arguments, this),
        this
    }
    ,
    t.from = function(n, r, o) {
        return Xa(1, arguments, this),
        this
    }
    ,
    t.fromTo = function(n, r, o, a) {
        return Xa(2, arguments, this),
        this
    }
    ,
    t.set = function(n, r, o) {
        return r.duration = 0,
        r.parent = this,
        Wa(r).repeatDelay || (r.repeat = 0),
        r.immediateRender = !!r.immediateRender,
        new Zt(n,r,fn(this, o),1),
        this
    }
    ,
    t.call = function(n, r, o) {
        return Vn(this, Zt.delayedCall(0, n, r), o)
    }
    ,
    t.staggerTo = function(n, r, o, a, l, c, h) {
        return o.duration = r,
        o.stagger = o.stagger || a,
        o.onComplete = c,
        o.onCompleteParams = h,
        o.parent = this,
        new Zt(n,o,fn(this, l)),
        this
    }
    ,
    t.staggerFrom = function(n, r, o, a, l, c, h) {
        return o.runBackwards = 1,
        Wa(o).immediateRender = Vi(o.immediateRender),
        this.staggerTo(n, r, o, a, l, c, h)
    }
    ,
    t.staggerFromTo = function(n, r, o, a, l, c, h, u) {
        return a.startAt = o,
        Wa(a).immediateRender = Vi(a.immediateRender),
        this.staggerTo(n, r, a, l, c, h, u)
    }
    ,
    t.render = function(n, r, o) {
        var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, h = n <= 0 ? 0 : li(n), u = this._zTime < 0 != n < 0 && (this._initted || !c), d, f, m, _, p, g, M, y, S, C, w, T;
        if (this !== zt && h > l && n >= 0 && (h = l),
        h !== this._tTime || o || u) {
            if (a !== this._time && c && (h += this._time - a,
            n += this._time - a),
            d = h,
            S = this._start,
            y = this._ts,
            g = !y,
            u && (c || (a = this._zTime),
            (n || !r) && (this._zTime = n)),
            this._repeat) {
                if (w = this._yoyo,
                p = c + this._rDelay,
                this._repeat < -1 && n < 0)
                    return this.totalTime(p * 100 + n, r, o);
                if (d = li(h % p),
                h === l ? (_ = this._repeat,
                d = c) : (_ = ~~(h / p),
                _ && _ === h / p && (d = c,
                _--),
                d > c && (d = c)),
                C = aa(this._tTime, p),
                !a && this._tTime && C !== _ && this._tTime - C * p - this._dur <= 0 && (C = _),
                w && _ & 1 && (d = c - d,
                T = 1),
                _ !== C && !this._lock) {
                    var B = w && C & 1
                      , b = B === (w && _ & 1);
                    if (_ < C && (B = !B),
                    a = B ? 0 : h % c ? c : h,
                    this._lock = 1,
                    this.render(a || (T ? 0 : li(_ * p)), r, !c)._lock = 0,
                    this._tTime = h,
                    !r && this.parent && an(this, "onRepeat"),
                    this.vars.repeatRefresh && !T && (this.invalidate()._lock = 1),
                    a && a !== this._time || g !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (c = this._dur,
                    l = this._tDur,
                    b && (this._lock = 2,
                    a = B ? c : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !T && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !g)
                        return this;
                    Q_(this, T)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (M = Ty(this, li(a), li(d)),
            M && (h -= d - (d = M._start))),
            this._tTime = h,
            this._time = d,
            this._act = !y,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = n,
            a = 0),
            !a && d && !r && !_ && (an(this, "onStart"),
            this._tTime !== h))
                return this;
            if (d >= a && n >= 0)
                for (f = this._first; f; ) {
                    if (m = f._next,
                    (f._act || d >= f._start) && f._ts && M !== f) {
                        if (f.parent !== this)
                            return this.render(n, r, o);
                        if (f.render(f._ts > 0 ? (d - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (d - f._start) * f._ts, r, o),
                        d !== this._time || !this._ts && !g) {
                            M = 0,
                            m && (h += this._zTime = -Lt);
                            break
                        }
                    }
                    f = m
                }
            else {
                f = this._last;
                for (var E = n < 0 ? n : d; f; ) {
                    if (m = f._prev,
                    (f._act || E <= f._end) && f._ts && M !== f) {
                        if (f.parent !== this)
                            return this.render(n, r, o);
                        if (f.render(f._ts > 0 ? (E - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (E - f._start) * f._ts, r, o || Mi && (f._initted || f._startAt)),
                        d !== this._time || !this._ts && !g) {
                            M = 0,
                            m && (h += this._zTime = E ? -Lt : Lt);
                            break
                        }
                    }
                    f = m
                }
            }
            if (M && !r && (this.pause(),
            M.render(d >= a ? 0 : -Lt)._zTime = d >= a ? 1 : -1,
            this._ts))
                return this._start = S,
                Ph(this),
                this.render(n, r, o);
            this._onUpdate && !r && an(this, "onUpdate", !0),
            (h === l && this._tTime >= this.totalDuration() || !h && a) && (S === this._start || Math.abs(y) !== Math.abs(this._ts)) && (this._lock || ((n || !c) && (h === l && this._ts > 0 || !h && this._ts < 0) && ls(this, 1),
            !r && !(n < 0 && !a) && (h || a || !l) && (an(this, h === l && n >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(h < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    t.add = function(n, r) {
        var o = this;
        if (br(r) || (r = fn(this, r, n)),
        !(n instanceof dl)) {
            if (Si(n))
                return n.forEach(function(a) {
                    return o.add(a, r)
                }),
                this;
            if (ci(n))
                return this.addLabel(n, r);
            if (Gt(n))
                n = Zt.delayedCall(0, n);
            else
                return this
        }
        return this !== n ? Vn(this, n, r) : this
    }
    ,
    t.getChildren = function(n, r, o, a) {
        n === void 0 && (n = !0),
        r === void 0 && (r = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -vn);
        for (var l = [], c = this._first; c; )
            c._start >= a && (c instanceof Zt ? r && l.push(c) : (o && l.push(c),
            n && l.push.apply(l, c.getChildren(!0, r, o)))),
            c = c._next;
        return l
    }
    ,
    t.getById = function(n) {
        for (var r = this.getChildren(1, 1, 1), o = r.length; o--; )
            if (r[o].vars.id === n)
                return r[o]
    }
    ,
    t.remove = function(n) {
        return ci(n) ? this.removeLabel(n) : Gt(n) ? this.killTweensOf(n) : (Ch(this, n),
        n === this._recent && (this._recent = this._last),
        zs(this))
    }
    ,
    t.totalTime = function(n, r) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = li(sn.time - (this._ts > 0 ? n / this._ts : (this.totalDuration() - n) / -this._ts))),
        s.prototype.totalTime.call(this, n, r),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    t.addLabel = function(n, r) {
        return this.labels[n] = fn(this, r),
        this
    }
    ,
    t.removeLabel = function(n) {
        return delete this.labels[n],
        this
    }
    ,
    t.addPause = function(n, r, o) {
        var a = Zt.delayedCall(0, r || cl, o);
        return a.data = "isPause",
        this._hasPause = 1,
        Vn(this, a, fn(this, n))
    }
    ,
    t.removePause = function(n) {
        var r = this._first;
        for (n = fn(this, n); r; )
            r._start === n && r.data === "isPause" && ls(r),
            r = r._next
    }
    ,
    t.killTweensOf = function(n, r, o) {
        for (var a = this.getTweensOf(n, o), l = a.length; l--; )
            qr !== a[l] && a[l].kill(n, r);
        return this
    }
    ,
    t.getTweensOf = function(n, r) {
        for (var o = [], a = Mn(n), l = this._first, c = br(r), h; l; )
            l instanceof Zt ? _y(l._targets, a) && (c ? (!qr || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && o.push(l) : (h = l.getTweensOf(a, r)).length && o.push.apply(o, h),
            l = l._next;
        return o
    }
    ,
    t.tweenTo = function(n, r) {
        r = r || {};
        var o = this, a = fn(o, n), l = r, c = l.startAt, h = l.onStart, u = l.onStartParams, d = l.immediateRender, f, m = Zt.to(o, Tn({
            ease: r.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: r.duration || Math.abs((a - (c && "time"in c ? c.time : o._time)) / o.timeScale()) || Lt,
            onStart: function() {
                if (o.pause(),
                !f) {
                    var p = r.duration || Math.abs((a - (c && "time"in c ? c.time : o._time)) / o.timeScale());
                    m._dur !== p && la(m, p, 0, 1).render(m._time, !0, !0),
                    f = 1
                }
                h && h.apply(m, u || [])
            }
        }, r));
        return d ? m.render(0) : m
    }
    ,
    t.tweenFromTo = function(n, r, o) {
        return this.tweenTo(r, Tn({
            startAt: {
                time: fn(this, n)
            }
        }, o))
    }
    ,
    t.recent = function() {
        return this._recent
    }
    ,
    t.nextLabel = function(n) {
        return n === void 0 && (n = this._time),
        fp(this, fn(this, n))
    }
    ,
    t.previousLabel = function(n) {
        return n === void 0 && (n = this._time),
        fp(this, fn(this, n), 1)
    }
    ,
    t.currentLabel = function(n) {
        return arguments.length ? this.seek(n, !0) : this.previousLabel(this._time + Lt)
    }
    ,
    t.shiftChildren = function(n, r, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, c; a; )
            a._start >= o && (a._start += n,
            a._end += n),
            a = a._next;
        if (r)
            for (c in l)
                l[c] >= o && (l[c] += n);
        return zs(this)
    }
    ,
    t.invalidate = function(n) {
        var r = this._first;
        for (this._lock = 0; r; )
            r.invalidate(n),
            r = r._next;
        return s.prototype.invalidate.call(this, n)
    }
    ,
    t.clear = function(n) {
        n === void 0 && (n = !0);
        for (var r = this._first, o; r; )
            o = r._next,
            this.remove(r),
            r = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        n && (this.labels = {}),
        zs(this)
    }
    ,
    t.totalDuration = function(n) {
        var r = 0, o = this, a = o._last, l = vn, c, h, u;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -n : n));
        if (o._dirty) {
            for (u = o.parent; a; )
                c = a._prev,
                a._dirty && a.totalDuration(),
                h = a._start,
                h > l && o._sort && a._ts && !o._lock ? (o._lock = 1,
                Vn(o, a, h - a._delay, 1)._lock = 0) : l = h,
                h < 0 && a._ts && (r -= h,
                (!u && !o._dp || u && u.smoothChildTiming) && (o._start += h / o._ts,
                o._time -= h,
                o._tTime -= h),
                o.shiftChildren(-h, !1, -1 / 0),
                l = 0),
                a._end > r && a._ts && (r = a._end),
                a = c;
            la(o, o === zt && o._time > r ? o._time : r, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }
    ,
    e.updateRoot = function(n) {
        if (zt._ts && (D_(zt, fh(n, zt)),
        L_ = sn.frame),
        sn.frame >= cp) {
            cp += ln.autoSleep || 120;
            var r = zt._first;
            if ((!r || !r._ts) && ln.autoSleep && sn._listeners.length < 2) {
                for (; r && !r._ts; )
                    r = r._next;
                r || sn.sleep()
            }
        }
    }
    ,
    e
}(dl);
Tn(Ui.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var ky = function(e, t, i, n, r, o, a) {
    var l = new Xi(this._pt,e,t,0,1,a0,null,r), c = 0, h = 0, u, d, f, m, _, p, g, M;
    for (l.b = i,
    l.e = n,
    i += "",
    n += "",
    (g = ~n.indexOf("random(")) && (n = hl(n)),
    o && (M = [i, n],
    o(M, e, t),
    i = M[0],
    n = M[1]),
    d = i.match(Gh) || []; u = Gh.exec(n); )
        m = u[0],
        _ = n.substring(c, u.index),
        f ? f = (f + 1) % 5 : _.substr(-5) === "rgba(" && (f = 1),
        m !== d[h++] && (p = parseFloat(d[h - 1]) || 0,
        l._pt = {
            _next: l._pt,
            p: _ || h === 1 ? _ : ",",
            s: p,
            c: m.charAt(1) === "=" ? Zo(p, m) - p : parseFloat(m) - p,
            m: f && f < 4 ? Math.round : 0
        },
        c = Gh.lastIndex);
    return l.c = c < n.length ? n.substring(c, n.length) : "",
    l.fp = a,
    (w_.test(n) || g) && (l.e = 0),
    this._pt = l,
    l
}, wf = function(e, t, i, n, r, o, a, l, c, h) {
    Gt(n) && (n = n(r || 0, e, o));
    var u = e[t], d = i !== "get" ? i : Gt(u) ? c ? e[t.indexOf("set") || !Gt(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : u, f = Gt(u) ? c ? Xy : s0 : Rf, m;
    if (ci(n) && (~n.indexOf("random(") && (n = hl(n)),
    n.charAt(1) === "=" && (m = Zo(d, n) + (vi(d) || 0),
    (m || m === 0) && (n = m))),
    !h || d !== n || Id)
        return !isNaN(d * n) && n !== "" ? (m = new Xi(this._pt,e,t,+d || 0,n - (d || 0),typeof u == "boolean" ? Yy : o0,0,f),
        c && (m.fp = c),
        a && m.modifier(a, this, e),
        this._pt = m) : (!u && !(t in e) && Sf(t, n),
        ky.call(this, e, t, d, n, f, l || ln.stringFilter, c))
}, Hy = function(e, t, i, n, r) {
    if (Gt(e) && (e = qa(e, r, t, i, n)),
    !Kn(e) || e.style && e.nodeType || Si(e) || T_(e))
        return ci(e) ? qa(e, r, t, i, n) : e;
    var o = {}, a;
    for (a in e)
        o[a] = qa(e[a], r, t, i, n);
    return o
}, i0 = function(e, t, i, n, r, o) {
    var a, l, c, h;
    if (rn[e] && (a = new rn[e]).init(r, a.rawVars ? t[e] : Hy(t[e], n, r, o, i), i, n, o) !== !1 && (i._pt = l = new Xi(i._pt,r,e,0,1,a.render,a,0,a.priority),
    i !== Wo))
        for (c = i._ptLookup[i._targets.indexOf(r)],
        h = a._props.length; h--; )
            c[a._props[h]] = l;
    return a
}, qr, Id, Af = function s(e, t, i) {
    var n = e.vars, r = n.ease, o = n.startAt, a = n.immediateRender, l = n.lazy, c = n.onUpdate, h = n.runBackwards, u = n.yoyoEase, d = n.keyframes, f = n.autoRevert, m = e._dur, _ = e._startAt, p = e._targets, g = e.parent, M = g && g.data === "nested" ? g.vars.targets : p, y = e._overwrite === "auto" && !xf, S = e.timeline, C, w, T, B, b, E, G, k, te, O, H, V, Y;
    if (S && (!d || !r) && (r = "none"),
    e._ease = ks(r, oa.ease),
    e._yEase = u ? J_(ks(u === !0 ? r : u, oa.ease)) : 0,
    u && e._yoyo && !e._repeat && (u = e._yEase,
    e._yEase = e._ease,
    e._ease = u),
    e._from = !S && !!n.runBackwards,
    !S || d && !n.stagger) {
        if (k = p[0] ? Bs(p[0]).harness : 0,
        V = k && n[k.prop],
        C = dh(n, bf),
        _ && (_._zTime < 0 && _.progress(1),
        t < 0 && h && a && !f ? _.render(-1, !0) : _.revert(h && m ? jc : my),
        _._lazy = 0),
        o) {
            if (ls(e._startAt = Zt.set(p, Tn({
                data: "isStart",
                overwrite: !1,
                parent: g,
                immediateRender: !0,
                lazy: !_ && Vi(l),
                startAt: null,
                delay: 0,
                onUpdate: c && function() {
                    return an(e, "onUpdate")
                }
                ,
                stagger: 0
            }, o))),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (Mi || !a && !f) && e._startAt.revert(jc),
            a && m && t <= 0 && i <= 0) {
                t && (e._zTime = t);
                return
            }
        } else if (h && m && !_) {
            if (t && (a = !1),
            T = Tn({
                overwrite: !1,
                data: "isFromStart",
                lazy: a && !_ && Vi(l),
                immediateRender: a,
                stagger: 0,
                parent: g
            }, C),
            V && (T[k.prop] = V),
            ls(e._startAt = Zt.set(p, T)),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (Mi ? e._startAt.revert(jc) : e._startAt.render(-1, !0)),
            e._zTime = t,
            !a)
                s(e._startAt, Lt, Lt);
            else if (!t)
                return
        }
        for (e._pt = e._ptCache = 0,
        l = m && Vi(l) || l && !m,
        w = 0; w < p.length; w++) {
            if (b = p[w],
            G = b._gsap || Ef(p)[w]._gsap,
            e._ptLookup[w] = O = {},
            wd[G.id] && ts.length && uh(),
            H = M === p ? w : M.indexOf(b),
            k && (te = new k).init(b, V || C, e, H, M) !== !1 && (e._pt = B = new Xi(e._pt,b,te.name,0,1,te.render,te,0,te.priority),
            te._props.forEach(function(K) {
                O[K] = B
            }),
            te.priority && (E = 1)),
            !k || V)
                for (T in C)
                    rn[T] && (te = i0(T, C, e, H, b, M)) ? te.priority && (E = 1) : O[T] = B = wf.call(e, b, T, "get", C[T], H, M, 0, n.stringFilter);
            e._op && e._op[w] && e.kill(b, e._op[w]),
            y && e._pt && (qr = e,
            zt.killTweensOf(b, O, e.globalTime(t)),
            Y = !e.parent,
            qr = 0),
            e._pt && l && (wd[G.id] = 1)
        }
        E && l0(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = c,
    e._initted = (!e._op || e._pt) && !Y,
    d && t <= 0 && S.render(vn, !0, !0)
}, Gy = function(e, t, i, n, r, o, a, l) {
    var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], h, u, d, f;
    if (!c)
        for (c = e._ptCache[t] = [],
        d = e._ptLookup,
        f = e._targets.length; f--; ) {
            if (h = d[f][t],
            h && h.d && h.d._pt)
                for (h = h.d._pt; h && h.p !== t && h.fp !== t; )
                    h = h._next;
            if (!h)
                return Id = 1,
                e.vars[t] = "+=0",
                Af(e, a),
                Id = 0,
                l ? ll(t + " not eligible for reset") : 1;
            c.push(h)
        }
    for (f = c.length; f--; )
        u = c[f],
        h = u._pt || u,
        h.s = (n || n === 0) && !r ? n : h.s + (n || 0) + o * h.c,
        h.c = i - h.s,
        u.e && (u.e = Wt(i) + vi(u.e)),
        u.b && (u.b = h.s + vi(u.b))
}, Vy = function(e, t) {
    var i = e[0] ? Bs(e[0]).harness : 0, n = i && i.aliases, r, o, a, l;
    if (!n)
        return t;
    r = Ks({}, t);
    for (o in n)
        if (o in r)
            for (l = n[o].split(","),
            a = l.length; a--; )
                r[l[a]] = r[o];
    return r
}, Wy = function(e, t, i, n) {
    var r = t.ease || n || "power1.inOut", o, a;
    if (Si(t))
        a = i[e] || (i[e] = []),
        t.forEach(function(l, c) {
            return a.push({
                t: c / (t.length - 1) * 100,
                v: l,
                e: r
            })
        });
    else
        for (o in t)
            a = i[o] || (i[o] = []),
            o === "ease" || a.push({
                t: parseFloat(e),
                v: t[o],
                e: r
            })
}, qa = function(e, t, i, n, r) {
    return Gt(e) ? e.call(t, i, n, r) : ci(e) && ~e.indexOf("random(") ? hl(e) : e
}, n0 = Tf + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", r0 = {};
Wi(n0 + ",id,stagger,delay,duration,paused,scrollTrigger", function(s) {
    return r0[s] = 1
});
var Zt = function(s) {
    S_(e, s);
    function e(i, n, r, o) {
        var a;
        typeof n == "number" && (r.duration = n,
        n = r,
        r = null),
        a = s.call(this, o ? n : Wa(n)) || this;
        var l = a.vars, c = l.duration, h = l.delay, u = l.immediateRender, d = l.stagger, f = l.overwrite, m = l.keyframes, _ = l.defaults, p = l.scrollTrigger, g = l.yoyoEase, M = n.parent || zt, y = (Si(i) || T_(i) ? br(i[0]) : "length"in n) ? [i] : Mn(i), S, C, w, T, B, b, E, G;
        if (a._targets = y.length ? Ef(y) : ll("GSAP target " + i + " not found. https://gsap.com", !ln.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = f,
        m || d || Nl(c) || Nl(h)) {
            if (n = a.vars,
            S = a.timeline = new Ui({
                data: "nested",
                defaults: _ || {},
                targets: M && M.data === "nested" ? M.vars.targets : y
            }),
            S.kill(),
            S.parent = S._dp = fr(a),
            S._start = 0,
            d || Nl(c) || Nl(h)) {
                if (T = y.length,
                E = d && G_(d),
                Kn(d))
                    for (B in d)
                        ~n0.indexOf(B) && (G || (G = {}),
                        G[B] = d[B]);
                for (C = 0; C < T; C++)
                    w = dh(n, r0),
                    w.stagger = 0,
                    g && (w.yoyoEase = g),
                    G && Ks(w, G),
                    b = y[C],
                    w.duration = +qa(c, fr(a), C, b, y),
                    w.delay = (+qa(h, fr(a), C, b, y) || 0) - a._delay,
                    !d && T === 1 && w.delay && (a._delay = h = w.delay,
                    a._start += h,
                    w.delay = 0),
                    S.to(b, w, E ? E(C, b, y) : 0),
                    S._ease = yt.none;
                S.duration() ? c = h = 0 : a.timeline = 0
            } else if (m) {
                Wa(Tn(S.vars.defaults, {
                    ease: "none"
                })),
                S._ease = ks(m.ease || n.ease || "none");
                var k = 0, te, O, H;
                if (Si(m))
                    m.forEach(function(V) {
                        return S.to(y, V, ">")
                    }),
                    S.duration();
                else {
                    w = {};
                    for (B in m)
                        B === "ease" || B === "easeEach" || Wy(B, m[B], w, m.easeEach);
                    for (B in w)
                        for (te = w[B].sort(function(V, Y) {
                            return V.t - Y.t
                        }),
                        k = 0,
                        C = 0; C < te.length; C++)
                            O = te[C],
                            H = {
                                ease: O.e,
                                duration: (O.t - (C ? te[C - 1].t : 0)) / 100 * c
                            },
                            H[B] = O.v,
                            S.to(y, H, k),
                            k += H.duration;
                    S.duration() < c && S.to({}, {
                        duration: c - S.duration()
                    })
                }
            }
            c || a.duration(c = S.duration())
        } else
            a.timeline = 0;
        return f === !0 && !xf && (qr = fr(a),
        zt.killTweensOf(y),
        qr = 0),
        Vn(M, fr(a), r),
        n.reversed && a.reverse(),
        n.paused && a.paused(!0),
        (u || !c && !m && a._start === li(M._time) && Vi(u) && My(fr(a)) && M.data !== "nested") && (a._tTime = -Lt,
        a.render(Math.max(0, -h) || 0)),
        p && B_(fr(a), p),
        a
    }
    var t = e.prototype;
    return t.render = function(n, r, o) {
        var a = this._time, l = this._tDur, c = this._dur, h = n < 0, u = n > l - Lt && !h ? l : n < Lt ? 0 : n, d, f, m, _, p, g, M, y, S;
        if (!c)
            by(this, n, r, o);
        else if (u !== this._tTime || !n || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h) {
            if (d = u,
            y = this.timeline,
            this._repeat) {
                if (_ = c + this._rDelay,
                this._repeat < -1 && h)
                    return this.totalTime(_ * 100 + n, r, o);
                if (d = li(u % _),
                u === l ? (m = this._repeat,
                d = c) : (m = ~~(u / _),
                m && m === li(u / _) && (d = c,
                m--),
                d > c && (d = c)),
                g = this._yoyo && m & 1,
                g && (S = this._yEase,
                d = c - d),
                p = aa(this._tTime, _),
                d === a && !o && this._initted && m === p)
                    return this._tTime = u,
                    this;
                m !== p && (y && this._yEase && Q_(y, g),
                this.vars.repeatRefresh && !g && !this._lock && this._time !== c && this._initted && (this._lock = o = 1,
                this.render(li(_ * m), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (z_(this, h ? n : d, o, r, u))
                    return this._tTime = 0,
                    this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && m !== p))
                    return this;
                if (c !== this._dur)
                    return this.render(n, r, o)
            }
            if (this._tTime = u,
            this._time = d,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = M = (S || this._ease)(d / c),
            this._from && (this.ratio = M = 1 - M),
            d && !a && !r && !m && (an(this, "onStart"),
            this._tTime !== u))
                return this;
            for (f = this._pt; f; )
                f.r(M, f.d),
                f = f._next;
            y && y.render(n < 0 ? n : !d && g ? -Lt : y._dur * y._ease(d / this._dur), r, o) || this._startAt && (this._zTime = n),
            this._onUpdate && !r && (h && Ad(this, n, r, o),
            an(this, "onUpdate")),
            this._repeat && m !== p && this.vars.onRepeat && !r && this.parent && an(this, "onRepeat"),
            (u === this._tDur || !u) && this._tTime === u && (h && !this._onUpdate && Ad(this, n, !0, !0),
            (n || !c) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && ls(this, 1),
            !r && !(h && !a) && (u || a || g) && (an(this, u === l ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(u < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    t.targets = function() {
        return this._targets
    }
    ,
    t.invalidate = function(n) {
        return (!n || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(n),
        s.prototype.invalidate.call(this, n)
    }
    ,
    t.resetTo = function(n, r, o, a, l) {
        ul || sn.wake(),
        this._ts || this.play();
        var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
        return this._initted || Af(this, c),
        h = this._ease(c / this._dur),
        Gy(this, n, r, o, a, h, c, l) ? this.resetTo(n, r, o, a, 1) : (Lh(this, 0),
        this.parent || F_(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    t.kill = function(n, r) {
        if (r === void 0 && (r = "all"),
        !n && (!r || r === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? za(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(n, r, qr && qr.vars.overwrite !== !0)._first || za(this),
            this.parent && o !== this.timeline.totalDuration() && la(this, this._dur * this.timeline._tDur / o, 0, 1),
            this
        }
        var a = this._targets, l = n ? Mn(n) : a, c = this._ptLookup, h = this._pt, u, d, f, m, _, p, g;
        if ((!r || r === "all") && yy(a, l))
            return r === "all" && (this._pt = 0),
            za(this);
        for (u = this._op = this._op || [],
        r !== "all" && (ci(r) && (_ = {},
        Wi(r, function(M) {
            return _[M] = 1
        }),
        r = _),
        r = Vy(a, r)),
        g = a.length; g--; )
            if (~l.indexOf(a[g])) {
                d = c[g],
                r === "all" ? (u[g] = r,
                m = d,
                f = {}) : (f = u[g] = u[g] || {},
                m = r);
                for (_ in m)
                    p = d && d[_],
                    p && ((!("kill"in p.d) || p.d.kill(_) === !0) && Ch(this, p, "_pt"),
                    delete d[_]),
                    f !== "all" && (f[_] = 1)
            }
        return this._initted && !this._pt && h && za(this),
        this
    }
    ,
    e.to = function(n, r) {
        return new e(n,r,arguments[2])
    }
    ,
    e.from = function(n, r) {
        return Xa(1, arguments)
    }
    ,
    e.delayedCall = function(n, r, o, a) {
        return new e(r,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: n,
            onComplete: r,
            onReverseComplete: r,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }
    ,
    e.fromTo = function(n, r, o) {
        return Xa(2, arguments)
    }
    ,
    e.set = function(n, r) {
        return r.duration = 0,
        r.repeatDelay || (r.repeat = 0),
        new e(n,r)
    }
    ,
    e.killTweensOf = function(n, r, o) {
        return zt.killTweensOf(n, r, o)
    }
    ,
    e
}(dl);
Tn(Zt.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
Wi("staggerTo,staggerFrom,staggerFromTo", function(s) {
    Zt[s] = function() {
        var e = new Ui
          , t = Cd.call(arguments, 0);
        return t.splice(s === "staggerFromTo" ? 5 : 4, 0, 0),
        e[s].apply(e, t)
    }
});
var Rf = function(e, t, i) {
    return e[t] = i
}
  , s0 = function(e, t, i) {
    return e[t](i)
}
  , Xy = function(e, t, i, n) {
    return e[t](n.fp, i)
}
  , qy = function(e, t, i) {
    return e.setAttribute(t, i)
}
  , Cf = function(e, t) {
    return Gt(e[t]) ? s0 : yf(e[t]) && e.setAttribute ? qy : Rf
}
  , o0 = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
}
  , Yy = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
}
  , a0 = function(e, t) {
    var i = t._pt
      , n = "";
    if (!e && t.b)
        n = t.b;
    else if (e === 1 && t.e)
        n = t.e;
    else {
        for (; i; )
            n = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + n,
            i = i._next;
        n += t.c
    }
    t.set(t.t, t.p, n, t)
}
  , Pf = function(e, t) {
    for (var i = t._pt; i; )
        i.r(e, i.d),
        i = i._next
}
  , $y = function(e, t, i, n) {
    for (var r = this._pt, o; r; )
        o = r._next,
        r.p === n && r.modifier(e, t, i),
        r = o
}
  , jy = function(e) {
    for (var t = this._pt, i, n; t; )
        n = t._next,
        t.p === e && !t.op || t.op === e ? Ch(this, t, "_pt") : t.dep || (i = 1),
        t = n;
    return !i
}
  , Zy = function(e, t, i, n) {
    n.mSet(e, t, n.m.call(n.tween, i, n.mt), n)
}
  , l0 = function(e) {
    for (var t = e._pt, i, n, r, o; t; ) {
        for (i = t._next,
        n = r; n && n.pr > t.pr; )
            n = n._next;
        (t._prev = n ? n._prev : o) ? t._prev._next = t : r = t,
        (t._next = n) ? n._prev = t : o = t,
        t = i
    }
    e._pt = r
}
  , Xi = function() {
    function s(t, i, n, r, o, a, l, c, h) {
        this.t = i,
        this.s = r,
        this.c = o,
        this.p = n,
        this.r = a || o0,
        this.d = l || this,
        this.set = c || Rf,
        this.pr = h || 0,
        this._next = t,
        t && (t._prev = this)
    }
    var e = s.prototype;
    return e.modifier = function(i, n, r) {
        this.mSet = this.mSet || this.set,
        this.set = Zy,
        this.m = i,
        this.mt = r,
        this.tween = n
    }
    ,
    s
}();
Wi(Tf + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(s) {
    return bf[s] = 1
});
hn.TweenMax = hn.TweenLite = Zt;
hn.TimelineLite = hn.TimelineMax = Ui;
zt = new Ui({
    sortChildren: !1,
    defaults: oa,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
ln.stringFilter = K_;
var Hs = []
  , Kc = {}
  , Ky = []
  , mp = 0
  , Jy = 0
  , Yh = function(e) {
    return (Kc[e] || Ky).map(function(t) {
        return t()
    })
}
  , Dd = function() {
    var e = Date.now()
      , t = [];
    e - mp > 2 && (Yh("matchMediaInit"),
    Hs.forEach(function(i) {
        var n = i.queries, r = i.conditions, o, a, l, c;
        for (a in n)
            o = pn.matchMedia(n[a]).matches,
            o && (l = 1),
            o !== r[a] && (r[a] = o,
            c = 1);
        c && (i.revert(),
        l && t.push(i))
    }),
    Yh("matchMediaRevert"),
    t.forEach(function(i) {
        return i.onMatch(i, function(n) {
            return i.add(null, n)
        })
    }),
    mp = e,
    Yh("matchMedia"))
}
  , c0 = function() {
    function s(t, i) {
        this.selector = i && Pd(i),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = Jy++,
        t && this.add(t)
    }
    var e = s.prototype;
    return e.add = function(i, n, r) {
        Gt(i) && (r = n,
        n = i,
        i = Gt);
        var o = this
          , a = function() {
            var c = Ht, h = o.selector, u;
            return c && c !== o && c.data.push(o),
            r && (o.selector = Pd(r)),
            Ht = o,
            u = n.apply(o, arguments),
            Gt(u) && o._r.push(u),
            Ht = c,
            o.selector = h,
            o.isReverted = !1,
            u
        };
        return o.last = a,
        i === Gt ? a(o, function(l) {
            return o.add(null, l)
        }) : i ? o[i] = a : a
    }
    ,
    e.ignore = function(i) {
        var n = Ht;
        Ht = null,
        i(this),
        Ht = n
    }
    ,
    e.getTweens = function() {
        var i = [];
        return this.data.forEach(function(n) {
            return n instanceof s ? i.push.apply(i, n.getTweens()) : n instanceof Zt && !(n.parent && n.parent.data === "nested") && i.push(n)
        }),
        i
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(i, n) {
        var r = this;
        if (i ? function() {
            for (var a = r.getTweens(), l = r.data.length, c; l--; )
                c = r.data[l],
                c.data === "isFlip" && (c.revert(),
                c.getChildren(!0, !0, !1).forEach(function(h) {
                    return a.splice(a.indexOf(h), 1)
                }));
            for (a.map(function(h) {
                return {
                    g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0,
                    t: h
                }
            }).sort(function(h, u) {
                return u.g - h.g || -1 / 0
            }).forEach(function(h) {
                return h.t.revert(i)
            }),
            l = r.data.length; l--; )
                c = r.data[l],
                c instanceof Ui ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(),
                c.kill()) : !(c instanceof Zt) && c.revert && c.revert(i);
            r._r.forEach(function(h) {
                return h(i, r)
            }),
            r.isReverted = !0
        }() : this.data.forEach(function(a) {
            return a.kill && a.kill()
        }),
        this.clear(),
        n)
            for (var o = Hs.length; o--; )
                Hs[o].id === this.id && Hs.splice(o, 1)
    }
    ,
    e.revert = function(i) {
        this.kill(i || {})
    }
    ,
    s
}()
  , Qy = function() {
    function s(t) {
        this.contexts = [],
        this.scope = t
    }
    var e = s.prototype;
    return e.add = function(i, n, r) {
        Kn(i) || (i = {
            matches: i
        });
        var o = new c0(0,r || this.scope), a = o.conditions = {}, l, c, h;
        Ht && !o.selector && (o.selector = Ht.selector),
        this.contexts.push(o),
        n = o.add("onMatch", n),
        o.queries = i;
        for (c in i)
            c === "all" ? h = 1 : (l = pn.matchMedia(i[c]),
            l && (Hs.indexOf(o) < 0 && Hs.push(o),
            (a[c] = l.matches) && (h = 1),
            l.addListener ? l.addListener(Dd) : l.addEventListener("change", Dd)));
        return h && n(o, function(u) {
            return o.add(null, u)
        }),
        this
    }
    ,
    e.revert = function(i) {
        this.kill(i || {})
    }
    ,
    e.kill = function(i) {
        this.contexts.forEach(function(n) {
            return n.kill(i, !0)
        })
    }
    ,
    s
}()
  , ph = {
    registerPlugin: function() {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
            t[i] = arguments[i];
        t.forEach(function(n) {
            return $_(n)
        })
    },
    timeline: function(e) {
        return new Ui(e)
    },
    getTweensOf: function(e, t) {
        return zt.getTweensOf(e, t)
    },
    getProperty: function(e, t, i, n) {
        ci(e) && (e = Mn(e)[0]);
        var r = Bs(e || {}).get
          , o = i ? N_ : U_;
        return i === "native" && (i = ""),
        e && (t ? o((rn[t] && rn[t].get || r)(e, t, i, n)) : function(a, l, c) {
            return o((rn[a] && rn[a].get || r)(e, a, l, c))
        }
        )
    },
    quickSetter: function(e, t, i) {
        if (e = Mn(e),
        e.length > 1) {
            var n = e.map(function(h) {
                return ji.quickSetter(h, t, i)
            })
              , r = n.length;
            return function(h) {
                for (var u = r; u--; )
                    n[u](h)
            }
        }
        e = e[0] || {};
        var o = rn[t]
          , a = Bs(e)
          , l = a.harness && (a.harness.aliases || {})[t] || t
          , c = o ? function(h) {
            var u = new o;
            Wo._pt = 0,
            u.init(e, i ? h + i : h, Wo, 0, [e]),
            u.render(1, u),
            Wo._pt && Pf(1, Wo)
        }
        : a.set(e, l);
        return o ? c : function(h) {
            return c(e, l, i ? h + i : h, a, 1)
        }
    },
    quickTo: function(e, t, i) {
        var n, r = ji.to(e, Ks((n = {},
        n[t] = "+=0.1",
        n.paused = !0,
        n), i || {})), o = function(l, c, h) {
            return r.resetTo(t, l, c, h)
        };
        return o.tween = r,
        o
    },
    isTweening: function(e) {
        return zt.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = ks(e.ease, oa.ease)),
        hp(oa, e || {})
    },
    config: function(e) {
        return hp(ln, e || {})
    },
    registerEffect: function(e) {
        var t = e.name
          , i = e.effect
          , n = e.plugins
          , r = e.defaults
          , o = e.extendTimeline;
        (n || "").split(",").forEach(function(a) {
            return a && !rn[a] && !hn[a] && ll(t + " effect requires " + a + " plugin.")
        }),
        Vh[t] = function(a, l, c) {
            return i(Mn(a), Tn(l || {}, r), c)
        }
        ,
        o && (Ui.prototype[t] = function(a, l, c) {
            return this.add(Vh[t](a, Kn(l) ? l : (c = l) && {}, this), c)
        }
        )
    },
    registerEase: function(e, t) {
        yt[e] = ks(t)
    },
    parseEase: function(e, t) {
        return arguments.length ? ks(e, t) : yt
    },
    getById: function(e) {
        return zt.getById(e)
    },
    exportRoot: function(e, t) {
        e === void 0 && (e = {});
        var i = new Ui(e), n, r;
        for (i.smoothChildTiming = Vi(e.smoothChildTiming),
        zt.remove(i),
        i._dp = 0,
        i._time = i._tTime = zt._time,
        n = zt._first; n; )
            r = n._next,
            (t || !(!n._dur && n instanceof Zt && n.vars.onComplete === n._targets[0])) && Vn(i, n, n._start - n._delay),
            n = r;
        return Vn(zt, i, 0),
        i
    },
    context: function(e, t) {
        return e ? new c0(e,t) : Ht
    },
    matchMedia: function(e) {
        return new Qy(e)
    },
    matchMediaRefresh: function() {
        return Hs.forEach(function(e) {
            var t = e.conditions, i, n;
            for (n in t)
                t[n] && (t[n] = !1,
                i = 1);
            i && e.revert()
        }) || Dd()
    },
    addEventListener: function(e, t) {
        var i = Kc[e] || (Kc[e] = []);
        ~i.indexOf(t) || i.push(t)
    },
    removeEventListener: function(e, t) {
        var i = Kc[e]
          , n = i && i.indexOf(t);
        n >= 0 && i.splice(n, 1)
    },
    utils: {
        wrap: Ly,
        wrapYoyo: Iy,
        distribute: G_,
        random: W_,
        snap: V_,
        normalize: Py,
        getUnit: vi,
        clamp: wy,
        splitColor: j_,
        toArray: Mn,
        selector: Pd,
        mapRange: q_,
        pipe: Ry,
        unitize: Cy,
        interpolate: Dy,
        shuffle: H_
    },
    install: C_,
    effects: Vh,
    ticker: sn,
    updateRoot: Ui.updateRoot,
    plugins: rn,
    globalTimeline: zt,
    core: {
        PropTween: Xi,
        globals: P_,
        Tween: Zt,
        Timeline: Ui,
        Animation: dl,
        getCache: Bs,
        _removeLinkedListItem: Ch,
        reverting: function() {
            return Mi
        },
        context: function(e) {
            return e && Ht && (Ht.data.push(e),
            e._ctx = Ht),
            Ht
        },
        suppressOverwrites: function(e) {
            return xf = e
        }
    }
};
Wi("to,from,fromTo,delayedCall,set,killTweensOf", function(s) {
    return ph[s] = Zt[s]
});
sn.add(Ui.updateRoot);
Wo = ph.to({}, {
    duration: 0
});
var ev = function(e, t) {
    for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
        i = i._next;
    return i
}
  , tv = function(e, t) {
    var i = e._targets, n, r, o;
    for (n in t)
        for (r = i.length; r--; )
            o = e._ptLookup[r][n],
            o && (o = o.d) && (o._pt && (o = ev(o, n)),
            o && o.modifier && o.modifier(t[n], e, i[r], n))
}
  , $h = function(e, t) {
    return {
        name: e,
        rawVars: 1,
        init: function(n, r, o) {
            o._onInit = function(a) {
                var l, c;
                if (ci(r) && (l = {},
                Wi(r, function(h) {
                    return l[h] = 1
                }),
                r = l),
                t) {
                    l = {};
                    for (c in r)
                        l[c] = t(r[c]);
                    r = l
                }
                tv(a, r)
            }
        }
    }
}
  , ji = ph.registerPlugin({
    name: "attr",
    init: function(e, t, i, n, r) {
        var o, a, l;
        this.tween = i;
        for (o in t)
            l = e.getAttribute(o) || "",
            a = this.add(e, "setAttribute", (l || 0) + "", t[o], n, r, 0, 0, o),
            a.op = o,
            a.b = l,
            this._props.push(o)
    },
    render: function(e, t) {
        for (var i = t._pt; i; )
            Mi ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d),
            i = i._next
    }
}, {
    name: "endArray",
    init: function(e, t) {
        for (var i = t.length; i--; )
            this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1)
    }
}, $h("roundProps", Ld), $h("modifiers"), $h("snap", V_)) || ph;
Zt.version = Ui.version = ji.version = "3.12.4";
R_ = 1;
vf() && ca();
yt.Power0;
yt.Power1;
yt.Power2;
yt.Power3;
yt.Power4;
yt.Linear;
yt.Quad;
yt.Cubic;
yt.Quart;
yt.Quint;
yt.Strong;
yt.Elastic;
yt.Back;
yt.SteppedEase;
yt.Bounce;
yt.Sine;
yt.Expo;
yt.Circ;
/*!
 * CSSPlugin 3.12.4
 * https://gsap.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var gp, Yr, Ko, Lf, Us, _p, If, iv = function() {
    return typeof window < "u"
}, Tr = {}, ws = 180 / Math.PI, Jo = Math.PI / 180, oo = Math.atan2, xp = 1e8, Df = /([A-Z])/g, nv = /(left|right|width|margin|padding|x)/i, rv = /[\s,\(]\S/, Xn = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, Ud = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, sv = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, ov = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, av = function(e, t) {
    var i = t.s + t.c * e;
    t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
}, h0 = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t)
}, u0 = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
}, lv = function(e, t, i) {
    return e.style[t] = i
}, cv = function(e, t, i) {
    return e.style.setProperty(t, i)
}, hv = function(e, t, i) {
    return e._gsap[t] = i
}, uv = function(e, t, i) {
    return e._gsap.scaleX = e._gsap.scaleY = i
}, dv = function(e, t, i, n, r) {
    var o = e._gsap;
    o.scaleX = o.scaleY = i,
    o.renderTransform(r, o)
}, fv = function(e, t, i, n, r) {
    var o = e._gsap;
    o[t] = i,
    o.renderTransform(r, o)
}, kt = "transform", qi = kt + "Origin", pv = function s(e, t) {
    var i = this
      , n = this.target
      , r = n.style
      , o = n._gsap;
    if (e in Tr && r) {
        if (this.tfm = this.tfm || {},
        e !== "transform")
            e = Xn[e] || e,
            ~e.indexOf(",") ? e.split(",").forEach(function(a) {
                return i.tfm[a] = pr(n, a)
            }) : this.tfm[e] = o.x ? o[e] : pr(n, e),
            e === qi && (this.tfm.zOrigin = o.zOrigin);
        else
            return Xn.transform.split(",").forEach(function(a) {
                return s.call(i, a, t)
            });
        if (this.props.indexOf(kt) >= 0)
            return;
        o.svg && (this.svgo = n.getAttribute("data-svg-origin"),
        this.props.push(qi, t, "")),
        e = kt
    }
    (r || t) && this.props.push(e, t, r[e])
}, d0 = function(e) {
    e.translate && (e.removeProperty("translate"),
    e.removeProperty("scale"),
    e.removeProperty("rotate"))
}, mv = function() {
    var e = this.props, t = this.target, i = t.style, n = t._gsap, r, o;
    for (r = 0; r < e.length; r += 3)
        e[r + 1] ? t[e[r]] = e[r + 2] : e[r + 2] ? i[e[r]] = e[r + 2] : i.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(Df, "-$1").toLowerCase());
    if (this.tfm) {
        for (o in this.tfm)
            n[o] = this.tfm[o];
        n.svg && (n.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        r = If(),
        (!r || !r.isStart) && !i[kt] && (d0(i),
        n.zOrigin && i[qi] && (i[qi] += " " + n.zOrigin + "px",
        n.zOrigin = 0,
        n.renderTransform()),
        n.uncache = 1)
    }
}, f0 = function(e, t) {
    var i = {
        target: e,
        props: [],
        revert: mv,
        save: pv
    };
    return e._gsap || ji.core.getCache(e),
    t && t.split(",").forEach(function(n) {
        return i.save(n)
    }),
    i
}, p0, Nd = function(e, t) {
    var i = Yr.createElementNS ? Yr.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Yr.createElement(e);
    return i && i.style ? i : Yr.createElement(e)
}, $n = function s(e, t, i) {
    var n = getComputedStyle(e);
    return n[t] || n.getPropertyValue(t.replace(Df, "-$1").toLowerCase()) || n.getPropertyValue(t) || !i && s(e, ha(t) || t, 1) || ""
}, yp = "O,Moz,ms,Ms,Webkit".split(","), ha = function(e, t, i) {
    var n = t || Us
      , r = n.style
      , o = 5;
    if (e in r && !i)
        return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(yp[o] + e in r); )
        ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? yp[o] : "") + e
}, Fd = function() {
    iv() && window.document && (gp = window,
    Yr = gp.document,
    Ko = Yr.documentElement,
    Us = Nd("div") || {
        style: {}
    },
    Nd("div"),
    kt = ha(kt),
    qi = kt + "Origin",
    Us.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    p0 = !!ha("perspective"),
    If = ji.core.reverting,
    Lf = 1)
}, jh = function s(e) {
    var t = Nd("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, n = this.nextSibling, r = this.style.cssText, o;
    if (Ko.appendChild(t),
    t.appendChild(this),
    this.style.display = "block",
    e)
        try {
            o = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = s
        } catch {}
    else
        this._gsapBBox && (o = this._gsapBBox());
    return i && (n ? i.insertBefore(this, n) : i.appendChild(this)),
    Ko.removeChild(t),
    this.style.cssText = r,
    o
}, vp = function(e, t) {
    for (var i = t.length; i--; )
        if (e.hasAttribute(t[i]))
            return e.getAttribute(t[i])
}, m0 = function(e) {
    var t;
    try {
        t = e.getBBox()
    } catch {
        t = jh.call(e, !0)
    }
    return t && (t.width || t.height) || e.getBBox === jh || (t = jh.call(e, !0)),
    t && !t.width && !t.x && !t.y ? {
        x: +vp(e, ["x", "cx", "x1"]) || 0,
        y: +vp(e, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : t
}, g0 = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && m0(e))
}, Js = function(e, t) {
    if (t) {
        var i = e.style, n;
        t in Tr && t !== qi && (t = kt),
        i.removeProperty ? (n = t.substr(0, 2),
        (n === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
        i.removeProperty(n === "--" ? t : t.replace(Df, "-$1").toLowerCase())) : i.removeAttribute(t)
    }
}, $r = function(e, t, i, n, r, o) {
    var a = new Xi(e._pt,t,i,0,1,o ? u0 : h0);
    return e._pt = a,
    a.b = n,
    a.e = r,
    e._props.push(i),
    a
}, Mp = {
    deg: 1,
    rad: 1,
    turn: 1
}, gv = {
    grid: 1,
    flex: 1
}, cs = function s(e, t, i, n) {
    var r = parseFloat(i) || 0, o = (i + "").trim().substr((r + "").length) || "px", a = Us.style, l = nv.test(t), c = e.tagName.toLowerCase() === "svg", h = (c ? "client" : "offset") + (l ? "Width" : "Height"), u = 100, d = n === "px", f = n === "%", m, _, p, g;
    if (n === o || !r || Mp[n] || Mp[o])
        return r;
    if (o !== "px" && !d && (r = s(e, t, i, "px")),
    g = e.getCTM && g0(e),
    (f || o === "%") && (Tr[t] || ~t.indexOf("adius")))
        return m = g ? e.getBBox()[l ? "width" : "height"] : e[h],
        Wt(f ? r / m * u : r / 100 * m);
    if (a[l ? "width" : "height"] = u + (d ? o : n),
    _ = ~t.indexOf("adius") || n === "em" && e.appendChild && !c ? e : e.parentNode,
    g && (_ = (e.ownerSVGElement || {}).parentNode),
    (!_ || _ === Yr || !_.appendChild) && (_ = Yr.body),
    p = _._gsap,
    p && f && p.width && l && p.time === sn.time && !p.uncache)
        return Wt(r / p.width * u);
    if (f && (t === "height" || t === "width")) {
        var M = e.style[t];
        e.style[t] = u + n,
        m = e[h],
        M ? e.style[t] = M : Js(e, t)
    } else
        (f || o === "%") && !gv[$n(_, "display")] && (a.position = $n(e, "position")),
        _ === e && (a.position = "static"),
        _.appendChild(Us),
        m = Us[h],
        _.removeChild(Us),
        a.position = "absolute";
    return l && f && (p = Bs(_),
    p.time = sn.time,
    p.width = _[h]),
    Wt(d ? m * r / u : m && r ? u / m * r : 0)
}, pr = function(e, t, i, n) {
    var r;
    return Lf || Fd(),
    t in Xn && t !== "transform" && (t = Xn[t],
    ~t.indexOf(",") && (t = t.split(",")[0])),
    Tr[t] && t !== "transform" ? (r = pl(e, n),
    r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : gh($n(e, qi)) + " " + r.zOrigin + "px") : (r = e.style[t],
    (!r || r === "auto" || n || ~(r + "").indexOf("calc(")) && (r = mh[t] && mh[t](e, t, i) || $n(e, t) || I_(e, t) || (t === "opacity" ? 1 : 0))),
    i && !~(r + "").trim().indexOf(" ") ? cs(e, t, r, i) + i : r
}, _v = function(e, t, i, n) {
    if (!i || i === "none") {
        var r = ha(t, e, 1)
          , o = r && $n(e, r, 1);
        o && o !== i ? (t = r,
        i = o) : t === "borderColor" && (i = $n(e, "borderTopColor"))
    }
    var a = new Xi(this._pt,e.style,t,0,1,a0), l = 0, c = 0, h, u, d, f, m, _, p, g, M, y, S, C;
    if (a.b = i,
    a.e = n,
    i += "",
    n += "",
    n === "auto" && (_ = e.style[t],
    e.style[t] = n,
    n = $n(e, t) || n,
    _ ? e.style[t] = _ : Js(e, t)),
    h = [i, n],
    K_(h),
    i = h[0],
    n = h[1],
    d = i.match(Vo) || [],
    C = n.match(Vo) || [],
    C.length) {
        for (; u = Vo.exec(n); )
            p = u[0],
            M = n.substring(l, u.index),
            m ? m = (m + 1) % 5 : (M.substr(-5) === "rgba(" || M.substr(-5) === "hsla(") && (m = 1),
            p !== (_ = d[c++] || "") && (f = parseFloat(_) || 0,
            S = _.substr((f + "").length),
            p.charAt(1) === "=" && (p = Zo(f, p) + S),
            g = parseFloat(p),
            y = p.substr((g + "").length),
            l = Vo.lastIndex - y.length,
            y || (y = y || ln.units[t] || S,
            l === n.length && (n += y,
            a.e += y)),
            S !== y && (f = cs(e, t, _, y) || 0),
            a._pt = {
                _next: a._pt,
                p: M || c === 1 ? M : ",",
                s: f,
                c: g - f,
                m: m && m < 4 || t === "zIndex" ? Math.round : 0
            });
        a.c = l < n.length ? n.substring(l, n.length) : ""
    } else
        a.r = t === "display" && n === "none" ? u0 : h0;
    return w_.test(n) && (a.e = 0),
    this._pt = a,
    a
}, Sp = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, xv = function(e) {
    var t = e.split(" ")
      , i = t[0]
      , n = t[1] || "50%";
    return (i === "top" || i === "bottom" || n === "left" || n === "right") && (e = i,
    i = n,
    n = e),
    t[0] = Sp[i] || i,
    t[1] = Sp[n] || n,
    t.join(" ")
}, yv = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
        var i = t.t, n = i.style, r = t.u, o = i._gsap, a, l, c;
        if (r === "all" || r === !0)
            n.cssText = "",
            l = 1;
        else
            for (r = r.split(","),
            c = r.length; --c > -1; )
                a = r[c],
                Tr[a] && (l = 1,
                a = a === "transformOrigin" ? qi : kt),
                Js(i, a);
        l && (Js(i, kt),
        o && (o.svg && i.removeAttribute("transform"),
        pl(i, 1),
        o.uncache = 1,
        d0(n)))
    }
}, mh = {
    clearProps: function(e, t, i, n, r) {
        if (r.data !== "isFromStart") {
            var o = e._pt = new Xi(e._pt,t,i,0,0,yv);
            return o.u = n,
            o.pr = -10,
            o.tween = r,
            e._props.push(i),
            1
        }
    }
}, fl = [1, 0, 0, 1, 0, 0], _0 = {}, x0 = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
}, bp = function(e) {
    var t = $n(e, kt);
    return x0(t) ? fl : t.substr(7).match(E_).map(Wt)
}, Uf = function(e, t) {
    var i = e._gsap || Bs(e), n = e.style, r = bp(e), o, a, l, c;
    return i.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix,
    r = [l.a, l.b, l.c, l.d, l.e, l.f],
    r.join(",") === "1,0,0,1,0,0" ? fl : r) : (r === fl && !e.offsetParent && e !== Ko && !i.svg && (l = n.display,
    n.display = "block",
    o = e.parentNode,
    (!o || !e.offsetParent) && (c = 1,
    a = e.nextElementSibling,
    Ko.appendChild(e)),
    r = bp(e),
    l ? n.display = l : Js(e, "display"),
    c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Ko.removeChild(e))),
    t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r)
}, Od = function(e, t, i, n, r, o) {
    var a = e._gsap, l = r || Uf(e, !0), c = a.xOrigin || 0, h = a.yOrigin || 0, u = a.xOffset || 0, d = a.yOffset || 0, f = l[0], m = l[1], _ = l[2], p = l[3], g = l[4], M = l[5], y = t.split(" "), S = parseFloat(y[0]) || 0, C = parseFloat(y[1]) || 0, w, T, B, b;
    i ? l !== fl && (T = f * p - m * _) && (B = S * (p / T) + C * (-_ / T) + (_ * M - p * g) / T,
    b = S * (-m / T) + C * (f / T) - (f * M - m * g) / T,
    S = B,
    C = b) : (w = m0(e),
    S = w.x + (~y[0].indexOf("%") ? S / 100 * w.width : S),
    C = w.y + (~(y[1] || y[0]).indexOf("%") ? C / 100 * w.height : C)),
    n || n !== !1 && a.smooth ? (g = S - c,
    M = C - h,
    a.xOffset = u + (g * f + M * _) - g,
    a.yOffset = d + (g * m + M * p) - M) : a.xOffset = a.yOffset = 0,
    a.xOrigin = S,
    a.yOrigin = C,
    a.smooth = !!n,
    a.origin = t,
    a.originIsAbsolute = !!i,
    e.style[qi] = "0px 0px",
    o && ($r(o, a, "xOrigin", c, S),
    $r(o, a, "yOrigin", h, C),
    $r(o, a, "xOffset", u, a.xOffset),
    $r(o, a, "yOffset", d, a.yOffset)),
    e.setAttribute("data-svg-origin", S + " " + C)
}, pl = function(e, t) {
    var i = e._gsap || new t0(e);
    if ("x"in i && !t && !i.uncache)
        return i;
    var n = e.style, r = i.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), c = $n(e, qi) || "0", h, u, d, f, m, _, p, g, M, y, S, C, w, T, B, b, E, G, k, te, O, H, V, Y, K, J, D, se, de, Q, re, ge;
    return h = u = d = _ = p = g = M = y = S = 0,
    f = m = 1,
    i.svg = !!(e.getCTM && g0(e)),
    l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (n[kt] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[kt] !== "none" ? l[kt] : "")),
    n.scale = n.rotate = n.translate = "none"),
    T = Uf(e, i.svg),
    i.svg && (i.uncache ? (K = e.getBBox(),
    c = i.xOrigin - K.x + "px " + (i.yOrigin - K.y) + "px",
    Y = "") : Y = !t && e.getAttribute("data-svg-origin"),
    Od(e, Y || c, !!Y || i.originIsAbsolute, i.smooth !== !1, T)),
    C = i.xOrigin || 0,
    w = i.yOrigin || 0,
    T !== fl && (G = T[0],
    k = T[1],
    te = T[2],
    O = T[3],
    h = H = T[4],
    u = V = T[5],
    T.length === 6 ? (f = Math.sqrt(G * G + k * k),
    m = Math.sqrt(O * O + te * te),
    _ = G || k ? oo(k, G) * ws : 0,
    M = te || O ? oo(te, O) * ws + _ : 0,
    M && (m *= Math.abs(Math.cos(M * Jo))),
    i.svg && (h -= C - (C * G + w * te),
    u -= w - (C * k + w * O))) : (ge = T[6],
    Q = T[7],
    D = T[8],
    se = T[9],
    de = T[10],
    re = T[11],
    h = T[12],
    u = T[13],
    d = T[14],
    B = oo(ge, de),
    p = B * ws,
    B && (b = Math.cos(-B),
    E = Math.sin(-B),
    Y = H * b + D * E,
    K = V * b + se * E,
    J = ge * b + de * E,
    D = H * -E + D * b,
    se = V * -E + se * b,
    de = ge * -E + de * b,
    re = Q * -E + re * b,
    H = Y,
    V = K,
    ge = J),
    B = oo(-te, de),
    g = B * ws,
    B && (b = Math.cos(-B),
    E = Math.sin(-B),
    Y = G * b - D * E,
    K = k * b - se * E,
    J = te * b - de * E,
    re = O * E + re * b,
    G = Y,
    k = K,
    te = J),
    B = oo(k, G),
    _ = B * ws,
    B && (b = Math.cos(B),
    E = Math.sin(B),
    Y = G * b + k * E,
    K = H * b + V * E,
    k = k * b - G * E,
    V = V * b - H * E,
    G = Y,
    H = K),
    p && Math.abs(p) + Math.abs(_) > 359.9 && (p = _ = 0,
    g = 180 - g),
    f = Wt(Math.sqrt(G * G + k * k + te * te)),
    m = Wt(Math.sqrt(V * V + ge * ge)),
    B = oo(H, V),
    M = Math.abs(B) > 2e-4 ? B * ws : 0,
    S = re ? 1 / (re < 0 ? -re : re) : 0),
    i.svg && (Y = e.getAttribute("transform"),
    i.forceCSS = e.setAttribute("transform", "") || !x0($n(e, kt)),
    Y && e.setAttribute("transform", Y))),
    Math.abs(M) > 90 && Math.abs(M) < 270 && (r ? (f *= -1,
    M += _ <= 0 ? 180 : -180,
    _ += _ <= 0 ? 180 : -180) : (m *= -1,
    M += M <= 0 ? 180 : -180)),
    t = t || i.uncache,
    i.x = h - ((i.xPercent = h && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + o,
    i.y = u - ((i.yPercent = u && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + o,
    i.z = d + o,
    i.scaleX = Wt(f),
    i.scaleY = Wt(m),
    i.rotation = Wt(_) + a,
    i.rotationX = Wt(p) + a,
    i.rotationY = Wt(g) + a,
    i.skewX = M + a,
    i.skewY = y + a,
    i.transformPerspective = S + o,
    (i.zOrigin = parseFloat(c.split(" ")[2]) || !t && i.zOrigin || 0) && (n[qi] = gh(c)),
    i.xOffset = i.yOffset = 0,
    i.force3D = ln.force3D,
    i.renderTransform = i.svg ? Mv : p0 ? y0 : vv,
    i.uncache = 0,
    i
}, gh = function(e) {
    return (e = e.split(" "))[0] + " " + e[1]
}, Zh = function(e, t, i) {
    var n = vi(t);
    return Wt(parseFloat(t) + parseFloat(cs(e, "x", i + "px", n))) + n
}, vv = function(e, t) {
    t.z = "0px",
    t.rotationY = t.rotationX = "0deg",
    t.force3D = 0,
    y0(e, t)
}, ms = "0deg", ba = "0px", gs = ") ", y0 = function(e, t) {
    var i = t || this
      , n = i.xPercent
      , r = i.yPercent
      , o = i.x
      , a = i.y
      , l = i.z
      , c = i.rotation
      , h = i.rotationY
      , u = i.rotationX
      , d = i.skewX
      , f = i.skewY
      , m = i.scaleX
      , _ = i.scaleY
      , p = i.transformPerspective
      , g = i.force3D
      , M = i.target
      , y = i.zOrigin
      , S = ""
      , C = g === "auto" && e && e !== 1 || g === !0;
    if (y && (u !== ms || h !== ms)) {
        var w = parseFloat(h) * Jo, T = Math.sin(w), B = Math.cos(w), b;
        w = parseFloat(u) * Jo,
        b = Math.cos(w),
        o = Zh(M, o, T * b * -y),
        a = Zh(M, a, -Math.sin(w) * -y),
        l = Zh(M, l, B * b * -y + y)
    }
    p !== ba && (S += "perspective(" + p + gs),
    (n || r) && (S += "translate(" + n + "%, " + r + "%) "),
    (C || o !== ba || a !== ba || l !== ba) && (S += l !== ba || C ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + gs),
    c !== ms && (S += "rotate(" + c + gs),
    h !== ms && (S += "rotateY(" + h + gs),
    u !== ms && (S += "rotateX(" + u + gs),
    (d !== ms || f !== ms) && (S += "skew(" + d + ", " + f + gs),
    (m !== 1 || _ !== 1) && (S += "scale(" + m + ", " + _ + gs),
    M.style[kt] = S || "translate(0, 0)"
}, Mv = function(e, t) {
    var i = t || this, n = i.xPercent, r = i.yPercent, o = i.x, a = i.y, l = i.rotation, c = i.skewX, h = i.skewY, u = i.scaleX, d = i.scaleY, f = i.target, m = i.xOrigin, _ = i.yOrigin, p = i.xOffset, g = i.yOffset, M = i.forceCSS, y = parseFloat(o), S = parseFloat(a), C, w, T, B, b;
    l = parseFloat(l),
    c = parseFloat(c),
    h = parseFloat(h),
    h && (h = parseFloat(h),
    c += h,
    l += h),
    l || c ? (l *= Jo,
    c *= Jo,
    C = Math.cos(l) * u,
    w = Math.sin(l) * u,
    T = Math.sin(l - c) * -d,
    B = Math.cos(l - c) * d,
    c && (h *= Jo,
    b = Math.tan(c - h),
    b = Math.sqrt(1 + b * b),
    T *= b,
    B *= b,
    h && (b = Math.tan(h),
    b = Math.sqrt(1 + b * b),
    C *= b,
    w *= b)),
    C = Wt(C),
    w = Wt(w),
    T = Wt(T),
    B = Wt(B)) : (C = u,
    B = d,
    w = T = 0),
    (y && !~(o + "").indexOf("px") || S && !~(a + "").indexOf("px")) && (y = cs(f, "x", o, "px"),
    S = cs(f, "y", a, "px")),
    (m || _ || p || g) && (y = Wt(y + m - (m * C + _ * T) + p),
    S = Wt(S + _ - (m * w + _ * B) + g)),
    (n || r) && (b = f.getBBox(),
    y = Wt(y + n / 100 * b.width),
    S = Wt(S + r / 100 * b.height)),
    b = "matrix(" + C + "," + w + "," + T + "," + B + "," + y + "," + S + ")",
    f.setAttribute("transform", b),
    M && (f.style[kt] = b)
}, Sv = function(e, t, i, n, r) {
    var o = 360, a = ci(r), l = parseFloat(r) * (a && ~r.indexOf("rad") ? ws : 1), c = l - n, h = n + c + "deg", u, d;
    return a && (u = r.split("_")[1],
    u === "short" && (c %= o,
    c !== c % (o / 2) && (c += c < 0 ? o : -o)),
    u === "cw" && c < 0 ? c = (c + o * xp) % o - ~~(c / o) * o : u === "ccw" && c > 0 && (c = (c - o * xp) % o - ~~(c / o) * o)),
    e._pt = d = new Xi(e._pt,t,i,n,c,sv),
    d.e = h,
    d.u = "deg",
    e._props.push(i),
    d
}, Tp = function(e, t) {
    for (var i in t)
        e[i] = t[i];
    return e
}, bv = function(e, t, i) {
    var n = Tp({}, i._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", o = i.style, a, l, c, h, u, d, f, m;
    n.svg ? (c = i.getAttribute("transform"),
    i.setAttribute("transform", ""),
    o[kt] = t,
    a = pl(i, 1),
    Js(i, kt),
    i.setAttribute("transform", c)) : (c = getComputedStyle(i)[kt],
    o[kt] = t,
    a = pl(i, 1),
    o[kt] = c);
    for (l in Tr)
        c = n[l],
        h = a[l],
        c !== h && r.indexOf(l) < 0 && (f = vi(c),
        m = vi(h),
        u = f !== m ? cs(i, l, c, m) : parseFloat(c),
        d = parseFloat(h),
        e._pt = new Xi(e._pt,a,l,u,d - u,Ud),
        e._pt.u = m || 0,
        e._props.push(l));
    Tp(a, n)
};
Wi("padding,margin,Width,Radius", function(s, e) {
    var t = "Top"
      , i = "Right"
      , n = "Bottom"
      , r = "Left"
      , o = (e < 3 ? [t, i, n, r] : [t + r, t + i, n + i, n + r]).map(function(a) {
        return e < 2 ? s + a : "border" + a + s
    });
    mh[e > 1 ? "border" + s : s] = function(a, l, c, h, u) {
        var d, f;
        if (arguments.length < 4)
            return d = o.map(function(m) {
                return pr(a, m, c)
            }),
            f = d.join(" "),
            f.split(d[0]).length === 5 ? d[0] : f;
        d = (h + "").split(" "),
        f = {},
        o.forEach(function(m, _) {
            return f[m] = d[_] = d[_] || d[(_ - 1) / 2 | 0]
        }),
        a.init(l, f, u)
    }
});
var v0 = {
    name: "css",
    register: Fd,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, i, n, r) {
        var o = this._props, a = e.style, l = i.vars.startAt, c, h, u, d, f, m, _, p, g, M, y, S, C, w, T, B;
        Lf || Fd(),
        this.styles = this.styles || f0(e),
        B = this.styles.props,
        this.tween = i;
        for (_ in t)
            if (_ !== "autoRound" && (h = t[_],
            !(rn[_] && i0(_, t, i, n, e, r)))) {
                if (f = typeof h,
                m = mh[_],
                f === "function" && (h = h.call(i, n, e, r),
                f = typeof h),
                f === "string" && ~h.indexOf("random(") && (h = hl(h)),
                m)
                    m(this, e, _, h, i) && (T = 1);
                else if (_.substr(0, 2) === "--")
                    c = (getComputedStyle(e).getPropertyValue(_) + "").trim(),
                    h += "",
                    is.lastIndex = 0,
                    is.test(c) || (p = vi(c),
                    g = vi(h)),
                    g ? p !== g && (c = cs(e, _, c, g) + g) : p && (h += p),
                    this.add(a, "setProperty", c, h, n, r, 0, 0, _),
                    o.push(_),
                    B.push(_, 0, a[_]);
                else if (f !== "undefined") {
                    if (l && _ in l ? (c = typeof l[_] == "function" ? l[_].call(i, n, e, r) : l[_],
                    ci(c) && ~c.indexOf("random(") && (c = hl(c)),
                    vi(c + "") || c === "auto" || (c += ln.units[_] || vi(pr(e, _)) || ""),
                    (c + "").charAt(1) === "=" && (c = pr(e, _))) : c = pr(e, _),
                    d = parseFloat(c),
                    M = f === "string" && h.charAt(1) === "=" && h.substr(0, 2),
                    M && (h = h.substr(2)),
                    u = parseFloat(h),
                    _ in Xn && (_ === "autoAlpha" && (d === 1 && pr(e, "visibility") === "hidden" && u && (d = 0),
                    B.push("visibility", 0, a.visibility),
                    $r(this, a, "visibility", d ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)),
                    _ !== "scale" && _ !== "transform" && (_ = Xn[_],
                    ~_.indexOf(",") && (_ = _.split(",")[0]))),
                    y = _ in Tr,
                    y) {
                        if (this.styles.save(_),
                        S || (C = e._gsap,
                        C.renderTransform && !t.parseTransform || pl(e, t.parseTransform),
                        w = t.smoothOrigin !== !1 && C.smooth,
                        S = this._pt = new Xi(this._pt,a,kt,0,1,C.renderTransform,C,0,-1),
                        S.dep = 1),
                        _ === "scale")
                            this._pt = new Xi(this._pt,C,"scaleY",C.scaleY,(M ? Zo(C.scaleY, M + u) : u) - C.scaleY || 0,Ud),
                            this._pt.u = 0,
                            o.push("scaleY", _),
                            _ += "X";
                        else if (_ === "transformOrigin") {
                            B.push(qi, 0, a[qi]),
                            h = xv(h),
                            C.svg ? Od(e, h, 0, w, 0, this) : (g = parseFloat(h.split(" ")[2]) || 0,
                            g !== C.zOrigin && $r(this, C, "zOrigin", C.zOrigin, g),
                            $r(this, a, _, gh(c), gh(h)));
                            continue
                        } else if (_ === "svgOrigin") {
                            Od(e, h, 1, w, 0, this);
                            continue
                        } else if (_ in _0) {
                            Sv(this, C, _, d, M ? Zo(d, M + h) : h);
                            continue
                        } else if (_ === "smoothOrigin") {
                            $r(this, C, "smooth", C.smooth, h);
                            continue
                        } else if (_ === "force3D") {
                            C[_] = h;
                            continue
                        } else if (_ === "transform") {
                            bv(this, h, e);
                            continue
                        }
                    } else
                        _ in a || (_ = ha(_) || _);
                    if (y || (u || u === 0) && (d || d === 0) && !rv.test(h) && _ in a)
                        p = (c + "").substr((d + "").length),
                        u || (u = 0),
                        g = vi(h) || (_ in ln.units ? ln.units[_] : p),
                        p !== g && (d = cs(e, _, c, g)),
                        this._pt = new Xi(this._pt,y ? C : a,_,d,(M ? Zo(d, M + u) : u) - d,!y && (g === "px" || _ === "zIndex") && t.autoRound !== !1 ? av : Ud),
                        this._pt.u = g || 0,
                        p !== g && g !== "%" && (this._pt.b = c,
                        this._pt.r = ov);
                    else if (_ in a)
                        _v.call(this, e, _, c, M ? M + h : h);
                    else if (_ in e)
                        this.add(e, _, c || e[_], M ? M + h : h, n, r);
                    else if (_ !== "parseTransform") {
                        Sf(_, h);
                        continue
                    }
                    y || (_ in a ? B.push(_, 0, a[_]) : B.push(_, 1, c || e[_])),
                    o.push(_)
                }
            }
        T && l0(this)
    },
    render: function(e, t) {
        if (t.tween._time || !If())
            for (var i = t._pt; i; )
                i.r(e, i.d),
                i = i._next;
        else
            t.styles.revert()
    },
    get: pr,
    aliases: Xn,
    getSetter: function(e, t, i) {
        var n = Xn[t];
        return n && n.indexOf(",") < 0 && (t = n),
        t in Tr && t !== qi && (e._gsap.x || pr(e, "x")) ? i && _p === i ? t === "scale" ? uv : hv : (_p = i || {}) && (t === "scale" ? dv : fv) : e.style && !yf(e.style[t]) ? lv : ~t.indexOf("-") ? cv : Cf(e, t)
    },
    core: {
        _removeProperty: Js,
        _getMatrix: Uf
    }
};
ji.utils.checkPrefix = ha;
ji.core.getStyleSaver = f0;
(function(s, e, t, i) {
    var n = Wi(s + "," + e + "," + t, function(r) {
        Tr[r] = 1
    });
    Wi(e, function(r) {
        ln.units[r] = "deg",
        _0[r] = 1
    }),
    Xn[n[13]] = s + "," + e,
    Wi(i, function(r) {
        var o = r.split(":");
        Xn[o[1]] = n[o[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Wi("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(s) {
    ln.units[s] = "px"
});
ji.registerPlugin(v0);
var Gi = ji.registerPlugin(v0) || ji;
Gi.core.Tween;
function Ep(s, e) {
    for (var t = 0; t < e.length; t++) {
        var i = e[t];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(s, i.key, i)
    }
}
function Tv(s, e, t) {
    return e && Ep(s.prototype, e),
    t && Ep(s, t),
    s
}
/*!
 * Observer 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var fi, Jc, on, jr, Zr, Qo, M0, As, Ya, S0, yr, In, b0, T0 = function() {
    return fi || typeof window < "u" && (fi = window.gsap) && fi.registerPlugin && fi
}, E0 = 1, Xo = [], pt = [], jn = [], $a = Date.now, Bd = function(e, t) {
    return t
}, Ev = function() {
    var e = Ya.core
      , t = e.bridge || {}
      , i = e._scrollers
      , n = e._proxies;
    i.push.apply(i, pt),
    n.push.apply(n, jn),
    pt = i,
    jn = n,
    Bd = function(o, a) {
        return t[o](a)
    }
}, ns = function(e, t) {
    return ~jn.indexOf(e) && jn[jn.indexOf(e) + 1][t]
}, ja = function(e) {
    return !!~S0.indexOf(e)
}, wi = function(e, t, i, n, r) {
    return e.addEventListener(t, i, {
        passive: !n,
        capture: !!r
    })
}, Ti = function(e, t, i, n) {
    return e.removeEventListener(t, i, !!n)
}, Fl = "scrollLeft", Ol = "scrollTop", zd = function() {
    return yr && yr.isPressed || pt.cache++
}, _h = function(e, t) {
    var i = function n(r) {
        if (r || r === 0) {
            E0 && (on.history.scrollRestoration = "manual");
            var o = yr && yr.isPressed;
            r = n.v = Math.round(r) || (yr && yr.iOS ? 1 : 0),
            e(r),
            n.cacheID = pt.cache,
            o && Bd("ss", r)
        } else
            (t || pt.cache !== n.cacheID || Bd("ref")) && (n.cacheID = pt.cache,
            n.v = e());
        return n.v + n.offset
    };
    return i.offset = 0,
    e && i
}, Ni = {
    s: Fl,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _h(function(s) {
        return arguments.length ? on.scrollTo(s, Qt.sc()) : on.pageXOffset || jr[Fl] || Zr[Fl] || Qo[Fl] || 0
    })
}, Qt = {
    s: Ol,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: Ni,
    sc: _h(function(s) {
        return arguments.length ? on.scrollTo(Ni.sc(), s) : on.pageYOffset || jr[Ol] || Zr[Ol] || Qo[Ol] || 0
    })
}, zi = function(e, t) {
    return (t && t._ctx && t._ctx.selector || fi.utils.toArray)(e)[0] || (typeof e == "string" && fi.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
}, hs = function(e, t) {
    var i = t.s
      , n = t.sc;
    ja(e) && (e = jr.scrollingElement || Zr);
    var r = pt.indexOf(e)
      , o = n === Qt.sc ? 1 : 2;
    !~r && (r = pt.push(e) - 1),
    pt[r + o] || wi(e, "scroll", zd);
    var a = pt[r + o]
      , l = a || (pt[r + o] = _h(ns(e, i), !0) || (ja(e) ? n : _h(function(c) {
        return arguments.length ? e[i] = c : e[i]
    })));
    return l.target = e,
    a || (l.smooth = fi.getProperty(e, "scrollBehavior") === "smooth"),
    l
}, kd = function(e, t, i) {
    var n = e
      , r = e
      , o = $a()
      , a = o
      , l = t || 50
      , c = Math.max(500, l * 3)
      , h = function(m, _) {
        var p = $a();
        _ || p - o > l ? (r = n,
        n = m,
        a = o,
        o = p) : i ? n += m : n = r + (m - r) / (p - a) * (o - a)
    }
      , u = function() {
        r = n = i ? 0 : n,
        a = o = 0
    }
      , d = function(m) {
        var _ = a
          , p = r
          , g = $a();
        return (m || m === 0) && m !== n && h(m),
        o === a || g - a > c ? 0 : (n + (i ? p : -p)) / ((i ? g : o) - _) * 1e3
    };
    return {
        update: h,
        reset: u,
        getVelocity: d
    }
}, Ta = function(e, t) {
    return t && !e._gsapAllow && e.preventDefault(),
    e.changedTouches ? e.changedTouches[0] : e
}, wp = function(e) {
    var t = Math.max.apply(Math, e)
      , i = Math.min.apply(Math, e);
    return Math.abs(t) >= Math.abs(i) ? t : i
}, w0 = function() {
    Ya = fi.core.globals().ScrollTrigger,
    Ya && Ya.core && Ev()
}, A0 = function(e) {
    return fi = e || T0(),
    !Jc && fi && typeof document < "u" && document.body && (on = window,
    jr = document,
    Zr = jr.documentElement,
    Qo = jr.body,
    S0 = [on, jr, Zr, Qo],
    fi.utils.clamp,
    b0 = fi.core.context || function() {}
    ,
    As = "onpointerenter"in Qo ? "pointer" : "mouse",
    M0 = Kt.isTouch = on.matchMedia && on.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in on || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
    In = Kt.eventTypes = ("ontouchstart"in Zr ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in Zr ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
    setTimeout(function() {
        return E0 = 0
    }, 500),
    w0(),
    Jc = 1),
    Jc
};
Ni.op = Qt;
pt.cache = 0;
var Kt = function() {
    function s(t) {
        this.init(t)
    }
    var e = s.prototype;
    return e.init = function(i) {
        Jc || A0(fi) || console.warn("Please gsap.registerPlugin(Observer)"),
        Ya || w0();
        var n = i.tolerance
          , r = i.dragMinimum
          , o = i.type
          , a = i.target
          , l = i.lineHeight
          , c = i.debounce
          , h = i.preventDefault
          , u = i.onStop
          , d = i.onStopDelay
          , f = i.ignore
          , m = i.wheelSpeed
          , _ = i.event
          , p = i.onDragStart
          , g = i.onDragEnd
          , M = i.onDrag
          , y = i.onPress
          , S = i.onRelease
          , C = i.onRight
          , w = i.onLeft
          , T = i.onUp
          , B = i.onDown
          , b = i.onChangeX
          , E = i.onChangeY
          , G = i.onChange
          , k = i.onToggleX
          , te = i.onToggleY
          , O = i.onHover
          , H = i.onHoverEnd
          , V = i.onMove
          , Y = i.ignoreCheck
          , K = i.isNormalizer
          , J = i.onGestureStart
          , D = i.onGestureEnd
          , se = i.onWheel
          , de = i.onEnable
          , Q = i.onDisable
          , re = i.onClick
          , ge = i.scrollSpeed
          , fe = i.capture
          , ve = i.allowClicks
          , Ue = i.lockAxis
          , ke = i.onLockAxis;
        this.target = a = zi(a) || Zr,
        this.vars = i,
        f && (f = fi.utils.toArray(f)),
        n = n || 1e-9,
        r = r || 0,
        m = m || 1,
        ge = ge || 1,
        o = o || "wheel,touch,pointer",
        c = c !== !1,
        l || (l = parseFloat(on.getComputedStyle(Qo).lineHeight) || 22);
        var Ve, Ke, $, Qe, Re, ze, Pe, Z = this, Ye = 0, L = 0, R = hs(a, Ni), X = hs(a, Qt), ue = R(), ce = X(), pe = ~o.indexOf("touch") && !~o.indexOf("pointer") && In[0] === "pointerdown", be = ja(a), me = a.ownerDocument || jr, Ee = [0, 0, 0], Oe = [0, 0, 0], Je = 0, le = function() {
            return Je = $a()
        }, lt = function(De, nt) {
            return (Z.event = De) && f && ~f.indexOf(De.target) || nt && pe && De.pointerType !== "touch" || Y && Y(De, nt)
        }, Ze = function() {
            Z._vx.reset(),
            Z._vy.reset(),
            Ke.pause(),
            u && u(Z)
        }, We = function() {
            var De = Z.deltaX = wp(Ee)
              , nt = Z.deltaY = wp(Oe)
              , rt = Math.abs(De) >= n
              , Me = Math.abs(nt) >= n;
            G && (rt || Me) && G(Z, De, nt, Ee, Oe),
            rt && (C && Z.deltaX > 0 && C(Z),
            w && Z.deltaX < 0 && w(Z),
            b && b(Z),
            k && Z.deltaX < 0 != Ye < 0 && k(Z),
            Ye = Z.deltaX,
            Ee[0] = Ee[1] = Ee[2] = 0),
            Me && (B && Z.deltaY > 0 && B(Z),
            T && Z.deltaY < 0 && T(Z),
            E && E(Z),
            te && Z.deltaY < 0 != L < 0 && te(Z),
            L = Z.deltaY,
            Oe[0] = Oe[1] = Oe[2] = 0),
            (Qe || $) && (V && V(Z),
            $ && (M(Z),
            $ = !1),
            Qe = !1),
            ze && !(ze = !1) && ke && ke(Z),
            Re && (se(Z),
            Re = !1),
            Ve = 0
        }, Ce = function(De, nt, rt) {
            Ee[rt] += De,
            Oe[rt] += nt,
            Z._vx.update(De),
            Z._vy.update(nt),
            c ? Ve || (Ve = requestAnimationFrame(We)) : We()
        }, Le = function(De, nt) {
            Ue && !Pe && (Z.axis = Pe = Math.abs(De) > Math.abs(nt) ? "x" : "y",
            ze = !0),
            Pe !== "y" && (Ee[2] += De,
            Z._vx.update(De, !0)),
            Pe !== "x" && (Oe[2] += nt,
            Z._vy.update(nt, !0)),
            c ? Ve || (Ve = requestAnimationFrame(We)) : We()
        }, $e = function(De) {
            if (!lt(De, 1)) {
                De = Ta(De, h);
                var nt = De.clientX
                  , rt = De.clientY
                  , Me = nt - Z.x
                  , tt = rt - Z.y
                  , je = Z.isDragging;
                Z.x = nt,
                Z.y = rt,
                (je || Math.abs(Z.startX - nt) >= r || Math.abs(Z.startY - rt) >= r) && (M && ($ = !0),
                je || (Z.isDragging = !0),
                Le(Me, tt),
                je || p && p(Z))
            }
        }, et = Z.onPress = function(Ie) {
            lt(Ie, 1) || Ie && Ie.button || (Z.axis = Pe = null,
            Ke.pause(),
            Z.isPressed = !0,
            Ie = Ta(Ie),
            Ye = L = 0,
            Z.startX = Z.x = Ie.clientX,
            Z.startY = Z.y = Ie.clientY,
            Z._vx.reset(),
            Z._vy.reset(),
            wi(K ? a : me, In[1], $e, h, !0),
            Z.deltaX = Z.deltaY = 0,
            y && y(Z))
        }
        , st = Z.onRelease = function(Ie) {
            if (!lt(Ie, 1)) {
                Ti(K ? a : me, In[1], $e, !0);
                var De = !isNaN(Z.y - Z.startY)
                  , nt = Z.isDragging
                  , rt = nt && (Math.abs(Z.x - Z.startX) > 3 || Math.abs(Z.y - Z.startY) > 3)
                  , Me = Ta(Ie);
                !rt && De && (Z._vx.reset(),
                Z._vy.reset(),
                h && ve && fi.delayedCall(.08, function() {
                    if ($a() - Je > 300 && !Ie.defaultPrevented) {
                        if (Ie.target.click)
                            Ie.target.click();
                        else if (me.createEvent) {
                            var tt = me.createEvent("MouseEvents");
                            tt.initMouseEvent("click", !0, !0, on, 1, Me.screenX, Me.screenY, Me.clientX, Me.clientY, !1, !1, !1, !1, 0, null),
                            Ie.target.dispatchEvent(tt)
                        }
                    }
                })),
                Z.isDragging = Z.isGesturing = Z.isPressed = !1,
                u && nt && !K && Ke.restart(!0),
                g && nt && g(Z),
                S && S(Z, rt)
            }
        }
        , we = function(De) {
            return De.touches && De.touches.length > 1 && (Z.isGesturing = !0) && J(De, Z.isDragging)
        }, j = function() {
            return (Z.isGesturing = !1) || D(Z)
        }, z = function(De) {
            if (!lt(De)) {
                var nt = R()
                  , rt = X();
                Ce((nt - ue) * ge, (rt - ce) * ge, 1),
                ue = nt,
                ce = rt,
                u && Ke.restart(!0)
            }
        }, _e = function(De) {
            if (!lt(De)) {
                De = Ta(De, h),
                se && (Re = !0);
                var nt = (De.deltaMode === 1 ? l : De.deltaMode === 2 ? on.innerHeight : 1) * m;
                Ce(De.deltaX * nt, De.deltaY * nt, 0),
                u && !K && Ke.restart(!0)
            }
        }, xe = function(De) {
            if (!lt(De)) {
                var nt = De.clientX
                  , rt = De.clientY
                  , Me = nt - Z.x
                  , tt = rt - Z.y;
                Z.x = nt,
                Z.y = rt,
                Qe = !0,
                u && Ke.restart(!0),
                (Me || tt) && Le(Me, tt)
            }
        }, Xe = function(De) {
            Z.event = De,
            O(Z)
        }, He = function(De) {
            Z.event = De,
            H(Z)
        }, ut = function(De) {
            return lt(De) || Ta(De, h) && re(Z)
        };
        Ke = Z._dc = fi.delayedCall(d || .25, Ze).pause(),
        Z.deltaX = Z.deltaY = 0,
        Z._vx = kd(0, 50, !0),
        Z._vy = kd(0, 50, !0),
        Z.scrollX = R,
        Z.scrollY = X,
        Z.isDragging = Z.isGesturing = Z.isPressed = !1,
        b0(this),
        Z.enable = function(Ie) {
            return Z.isEnabled || (wi(be ? me : a, "scroll", zd),
            o.indexOf("scroll") >= 0 && wi(be ? me : a, "scroll", z, h, fe),
            o.indexOf("wheel") >= 0 && wi(a, "wheel", _e, h, fe),
            (o.indexOf("touch") >= 0 && M0 || o.indexOf("pointer") >= 0) && (wi(a, In[0], et, h, fe),
            wi(me, In[2], st),
            wi(me, In[3], st),
            ve && wi(a, "click", le, !1, !0),
            re && wi(a, "click", ut),
            J && wi(me, "gesturestart", we),
            D && wi(me, "gestureend", j),
            O && wi(a, As + "enter", Xe),
            H && wi(a, As + "leave", He),
            V && wi(a, As + "move", xe)),
            Z.isEnabled = !0,
            Ie && Ie.type && et(Ie),
            de && de(Z)),
            Z
        }
        ,
        Z.disable = function() {
            Z.isEnabled && (Xo.filter(function(Ie) {
                return Ie !== Z && ja(Ie.target)
            }).length || Ti(be ? me : a, "scroll", zd),
            Z.isPressed && (Z._vx.reset(),
            Z._vy.reset(),
            Ti(K ? a : me, In[1], $e, !0)),
            Ti(be ? me : a, "scroll", z, fe),
            Ti(a, "wheel", _e, fe),
            Ti(a, In[0], et, fe),
            Ti(me, In[2], st),
            Ti(me, In[3], st),
            Ti(a, "click", le, !0),
            Ti(a, "click", ut),
            Ti(me, "gesturestart", we),
            Ti(me, "gestureend", j),
            Ti(a, As + "enter", Xe),
            Ti(a, As + "leave", He),
            Ti(a, As + "move", xe),
            Z.isEnabled = Z.isPressed = Z.isDragging = !1,
            Q && Q(Z))
        }
        ,
        Z.kill = Z.revert = function() {
            Z.disable();
            var Ie = Xo.indexOf(Z);
            Ie >= 0 && Xo.splice(Ie, 1),
            yr === Z && (yr = 0)
        }
        ,
        Xo.push(Z),
        K && ja(a) && (yr = Z),
        Z.enable(_)
    }
    ,
    Tv(s, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]),
    s
}();
Kt.version = "3.12.4";
Kt.create = function(s) {
    return new Kt(s)
}
;
Kt.register = A0;
Kt.getAll = function() {
    return Xo.slice()
}
;
Kt.getById = function(s) {
    return Xo.filter(function(e) {
        return e.vars.id === s
    })[0]
}
;
T0() && fi.registerPlugin(Kt);
/*!
 * ScrollTrigger 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Fe, Ho, xt, Bt, Dn, Dt, R0, xh, ml, qo, Qc, Bl, yi, Ih, Hd, Ci, Ap, Rp, Go, C0, Kh, P0, Ri, L0, I0, D0, Wr, Gd, Nf, ea, Ff, yh, Vd, Jh, zl = 1, Li = Date.now, Qh = Li(), Sn = 0, Ha = 0, Cp = function(e, t, i) {
    var n = nn(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
    return i["_" + t + "Clamp"] = n,
    n ? e.substr(6, e.length - 7) : e
}, Pp = function(e, t) {
    return t && (!nn(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
}, wv = function s() {
    return Ha && requestAnimationFrame(s)
}, Lp = function() {
    return Ih = 1
}, Ip = function() {
    return Ih = 0
}, kn = function(e) {
    return e
}, Ga = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, U0 = function() {
    return typeof window < "u"
}, N0 = function() {
    return Fe || U0() && (Fe = window.gsap) && Fe.registerPlugin && Fe
}, Qs = function(e) {
    return !!~R0.indexOf(e)
}, F0 = function(e) {
    return (e === "Height" ? Ff : xt["inner" + e]) || Dn["client" + e] || Dt["client" + e]
}, O0 = function(e) {
    return ns(e, "getBoundingClientRect") || (Qs(e) ? function() {
        return sh.width = xt.innerWidth,
        sh.height = Ff,
        sh
    }
    : function() {
        return mr(e)
    }
    )
}, Av = function(e, t, i) {
    var n = i.d
      , r = i.d2
      , o = i.a;
    return (o = ns(e, "getBoundingClientRect")) ? function() {
        return o()[n]
    }
    : function() {
        return (t ? F0(r) : e["client" + r]) || 0
    }
}, Rv = function(e, t) {
    return !t || ~jn.indexOf(e) ? O0(e) : function() {
        return sh
    }
}, qn = function(e, t) {
    var i = t.s
      , n = t.d2
      , r = t.d
      , o = t.a;
    return Math.max(0, (i = "scroll" + n) && (o = ns(e, i)) ? o() - O0(e)()[r] : Qs(e) ? (Dn[i] || Dt[i]) - F0(n) : e[i] - e["offset" + n])
}, kl = function(e, t) {
    for (var i = 0; i < Go.length; i += 3)
        (!t || ~t.indexOf(Go[i + 1])) && e(Go[i], Go[i + 1], Go[i + 2])
}, nn = function(e) {
    return typeof e == "string"
}, Fi = function(e) {
    return typeof e == "function"
}, eh = function(e) {
    return typeof e == "number"
}, Rs = function(e) {
    return typeof e == "object"
}, Ea = function(e, t, i) {
    return e && e.progress(t ? 0 : 1) && i && e.pause()
}, eu = function(e, t) {
    if (e.enabled) {
        var i = e._ctx ? e._ctx.add(function() {
            return t(e)
        }) : t(e);
        i && i.totalTime && (e.callbackAnimation = i)
    }
}, ao = Math.abs, B0 = "left", z0 = "top", Of = "right", Bf = "bottom", Gs = "width", Vs = "height", Za = "Right", Ka = "Left", Ja = "Top", Qa = "Bottom", jt = "padding", gn = "margin", ua = "Width", zf = "Height", ri = "px", _n = function(e) {
    return xt.getComputedStyle(e)
}, Cv = function(e) {
    var t = _n(e).position;
    e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
}, Dp = function(e, t) {
    for (var i in t)
        i in e || (e[i] = t[i]);
    return e
}, mr = function(e, t) {
    var i = t && _n(e)[Hd] !== "matrix(1, 0, 0, 1, 0, 0)" && Fe.to(e, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
    }).progress(1)
      , n = e.getBoundingClientRect();
    return i && i.progress(0).kill(),
    n
}, Wd = function(e, t) {
    var i = t.d2;
    return e["offset" + i] || e["client" + i] || 0
}, k0 = function(e) {
    var t = [], i = e.labels, n = e.duration(), r;
    for (r in i)
        t.push(i[r] / n);
    return t
}, Pv = function(e) {
    return function(t) {
        return Fe.utils.snap(k0(e), t)
    }
}, kf = function(e) {
    var t = Fe.utils.snap(e)
      , i = Array.isArray(e) && e.slice(0).sort(function(n, r) {
        return n - r
    });
    return i ? function(n, r, o) {
        o === void 0 && (o = .001);
        var a;
        if (!r)
            return t(n);
        if (r > 0) {
            for (n -= o,
            a = 0; a < i.length; a++)
                if (i[a] >= n)
                    return i[a];
            return i[a - 1]
        } else
            for (a = i.length,
            n += o; a--; )
                if (i[a] <= n)
                    return i[a];
        return i[0]
    }
    : function(n, r, o) {
        o === void 0 && (o = .001);
        var a = t(n);
        return !r || Math.abs(a - n) < o || a - n < 0 == r < 0 ? a : t(r < 0 ? n - e : n + e)
    }
}, Lv = function(e) {
    return function(t, i) {
        return kf(k0(e))(t, i.direction)
    }
}, Hl = function(e, t, i, n) {
    return i.split(",").forEach(function(r) {
        return e(t, r, n)
    })
}, oi = function(e, t, i, n, r) {
    return e.addEventListener(t, i, {
        passive: !n,
        capture: !!r
    })
}, si = function(e, t, i, n) {
    return e.removeEventListener(t, i, !!n)
}, Gl = function(e, t, i) {
    i = i && i.wheelHandler,
    i && (e(t, "wheel", i),
    e(t, "touchmove", i))
}, Up = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
}, Vl = {
    toggleActions: "play",
    anticipatePin: 0
}, vh = {
    top: 0,
    left: 0,
    center: .5,
    bottom: 1,
    right: 1
}, th = function(e, t) {
    if (nn(e)) {
        var i = e.indexOf("=")
          , n = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
        ~i && (e.indexOf("%") > i && (n *= t / 100),
        e = e.substr(0, i - 1)),
        e = n + (e in vh ? vh[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
    }
    return e
}, Wl = function(e, t, i, n, r, o, a, l) {
    var c = r.startColor
      , h = r.endColor
      , u = r.fontSize
      , d = r.indent
      , f = r.fontWeight
      , m = Bt.createElement("div")
      , _ = Qs(i) || ns(i, "pinType") === "fixed"
      , p = e.indexOf("scroller") !== -1
      , g = _ ? Dt : i
      , M = e.indexOf("start") !== -1
      , y = M ? c : h
      , S = "border-color:" + y + ";font-size:" + u + ";color:" + y + ";font-weight:" + f + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return S += "position:" + ((p || l) && _ ? "fixed;" : "absolute;"),
    (p || l || !_) && (S += (n === Qt ? Of : Bf) + ":" + (o + parseFloat(d)) + "px;"),
    a && (S += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
    m._isStart = M,
    m.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")),
    m.style.cssText = S,
    m.innerText = t || t === 0 ? e + "-" + t : e,
    g.children[0] ? g.insertBefore(m, g.children[0]) : g.appendChild(m),
    m._offset = m["offset" + n.op.d2],
    ih(m, 0, n, M),
    m
}, ih = function(e, t, i, n) {
    var r = {
        display: "block"
    }
      , o = i[n ? "os2" : "p2"]
      , a = i[n ? "p2" : "os2"];
    e._isFlipped = n,
    r[i.a + "Percent"] = n ? -100 : 0,
    r[i.a] = n ? "1px" : 0,
    r["border" + o + ua] = 1,
    r["border" + a + ua] = 0,
    r[i.p] = t + "px",
    Fe.set(e, r)
}, ft = [], Xd = {}, gl, Np = function() {
    return Li() - Sn > 34 && (gl || (gl = requestAnimationFrame(Sr)))
}, lo = function() {
    (!Ri || !Ri.isPressed || Ri.startX > Dt.clientWidth) && (pt.cache++,
    Ri ? gl || (gl = requestAnimationFrame(Sr)) : Sr(),
    Sn || to("scrollStart"),
    Sn = Li())
}, tu = function() {
    D0 = xt.innerWidth,
    I0 = xt.innerHeight
}, Va = function() {
    pt.cache++,
    !yi && !P0 && !Bt.fullscreenElement && !Bt.webkitFullscreenElement && (!L0 || D0 !== xt.innerWidth || Math.abs(xt.innerHeight - I0) > xt.innerHeight * .25) && xh.restart(!0)
}, eo = {}, Iv = [], H0 = function s() {
    return si(_t, "scrollEnd", s) || Ns(!0)
}, to = function(e) {
    return eo[e] && eo[e].map(function(t) {
        return t()
    }) || Iv
}, tn = [], G0 = function(e) {
    for (var t = 0; t < tn.length; t += 5)
        (!e || tn[t + 4] && tn[t + 4].query === e) && (tn[t].style.cssText = tn[t + 1],
        tn[t].getBBox && tn[t].setAttribute("transform", tn[t + 2] || ""),
        tn[t + 3].uncache = 1)
}, Hf = function(e, t) {
    var i;
    for (Ci = 0; Ci < ft.length; Ci++)
        i = ft[Ci],
        i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
    yh = !0,
    t && G0(t),
    t || to("revert")
}, V0 = function(e, t) {
    pt.cache++,
    (t || !Pi) && pt.forEach(function(i) {
        return Fi(i) && i.cacheID++ && (i.rec = 0)
    }),
    nn(e) && (xt.history.scrollRestoration = Nf = e)
}, Pi, Ws = 0, Fp, Dv = function() {
    if (Fp !== Ws) {
        var e = Fp = Ws;
        requestAnimationFrame(function() {
            return e === Ws && Ns(!0)
        })
    }
}, W0 = function() {
    Dt.appendChild(ea),
    Ff = !Ri && ea.offsetHeight || xt.innerHeight,
    Dt.removeChild(ea)
}, Op = function(e) {
    return ml(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
        return t.style.display = e ? "none" : "block"
    })
}, Ns = function(e, t) {
    if (Sn && !e && !yh) {
        oi(_t, "scrollEnd", H0);
        return
    }
    W0(),
    Pi = _t.isRefreshing = !0,
    pt.forEach(function(n) {
        return Fi(n) && ++n.cacheID && (n.rec = n())
    });
    var i = to("refreshInit");
    C0 && _t.sort(),
    t || Hf(),
    pt.forEach(function(n) {
        Fi(n) && (n.smooth && (n.target.style.scrollBehavior = "auto"),
        n(0))
    }),
    ft.slice(0).forEach(function(n) {
        return n.refresh()
    }),
    yh = !1,
    ft.forEach(function(n) {
        if (n._subPinOffset && n.pin) {
            var r = n.vars.horizontal ? "offsetWidth" : "offsetHeight"
              , o = n.pin[r];
            n.revert(!0, 1),
            n.adjustPinSpacing(n.pin[r] - o),
            n.refresh()
        }
    }),
    Vd = 1,
    Op(!0),
    ft.forEach(function(n) {
        var r = qn(n.scroller, n._dir)
          , o = n.vars.end === "max" || n._endClamp && n.end > r
          , a = n._startClamp && n.start >= r;
        (o || a) && n.setPositions(a ? r - 1 : n.start, o ? Math.max(a ? r : n.start + 1, r) : n.end, !0)
    }),
    Op(!1),
    Vd = 0,
    i.forEach(function(n) {
        return n && n.render && n.render(-1)
    }),
    pt.forEach(function(n) {
        Fi(n) && (n.smooth && requestAnimationFrame(function() {
            return n.target.style.scrollBehavior = "smooth"
        }),
        n.rec && n(n.rec))
    }),
    V0(Nf, 1),
    xh.pause(),
    Ws++,
    Pi = 2,
    Sr(2),
    ft.forEach(function(n) {
        return Fi(n.vars.onRefresh) && n.vars.onRefresh(n)
    }),
    Pi = _t.isRefreshing = !1,
    to("refresh")
}, qd = 0, nh = 1, el, Sr = function(e) {
    if (e === 2 || !Pi && !yh) {
        _t.isUpdating = !0,
        el && el.update(0);
        var t = ft.length
          , i = Li()
          , n = i - Qh >= 50
          , r = t && ft[0].scroll();
        if (nh = qd > r ? -1 : 1,
        Pi || (qd = r),
        n && (Sn && !Ih && i - Sn > 200 && (Sn = 0,
        to("scrollEnd")),
        Qc = Qh,
        Qh = i),
        nh < 0) {
            for (Ci = t; Ci-- > 0; )
                ft[Ci] && ft[Ci].update(0, n);
            nh = 1
        } else
            for (Ci = 0; Ci < t; Ci++)
                ft[Ci] && ft[Ci].update(0, n);
        _t.isUpdating = !1
    }
    gl = 0
}, Yd = [B0, z0, Bf, Of, gn + Qa, gn + Za, gn + Ja, gn + Ka, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], rh = Yd.concat([Gs, Vs, "boxSizing", "max" + ua, "max" + zf, "position", gn, jt, jt + Ja, jt + Za, jt + Qa, jt + Ka]), Uv = function(e, t, i) {
    ta(i);
    var n = e._gsap;
    if (n.spacerIsNative)
        ta(n.spacerState);
    else if (e._gsap.swappedIn) {
        var r = t.parentNode;
        r && (r.insertBefore(e, t),
        r.removeChild(t))
    }
    e._gsap.swappedIn = !1
}, iu = function(e, t, i, n) {
    if (!e._gsap.swappedIn) {
        for (var r = Yd.length, o = t.style, a = e.style, l; r--; )
            l = Yd[r],
            o[l] = i[l];
        o.position = i.position === "absolute" ? "absolute" : "relative",
        i.display === "inline" && (o.display = "inline-block"),
        a[Bf] = a[Of] = "auto",
        o.flexBasis = i.flexBasis || "auto",
        o.overflow = "visible",
        o.boxSizing = "border-box",
        o[Gs] = Wd(e, Ni) + ri,
        o[Vs] = Wd(e, Qt) + ri,
        o[jt] = a[gn] = a[z0] = a[B0] = "0",
        ta(n),
        a[Gs] = a["max" + ua] = i[Gs],
        a[Vs] = a["max" + zf] = i[Vs],
        a[jt] = i[jt],
        e.parentNode !== t && (e.parentNode.insertBefore(t, e),
        t.appendChild(e)),
        e._gsap.swappedIn = !0
    }
}, Nv = /([A-Z])/g, ta = function(e) {
    if (e) {
        var t = e.t.style, i = e.length, n = 0, r, o;
        for ((e.t._gsap || Fe.core.getCache(e.t)).uncache = 1; n < i; n += 2)
            o = e[n + 1],
            r = e[n],
            o ? t[r] = o : t[r] && t.removeProperty(r.replace(Nv, "-$1").toLowerCase())
    }
}, Xl = function(e) {
    for (var t = rh.length, i = e.style, n = [], r = 0; r < t; r++)
        n.push(rh[r], i[rh[r]]);
    return n.t = e,
    n
}, Fv = function(e, t, i) {
    for (var n = [], r = e.length, o = i ? 8 : 0, a; o < r; o += 2)
        a = e[o],
        n.push(a, a in t ? t[a] : e[o + 1]);
    return n.t = e.t,
    n
}, sh = {
    left: 0,
    top: 0
}, Bp = function(e, t, i, n, r, o, a, l, c, h, u, d, f, m) {
    Fi(e) && (e = e(l)),
    nn(e) && e.substr(0, 3) === "max" && (e = d + (e.charAt(4) === "=" ? th("0" + e.substr(3), i) : 0));
    var _ = f ? f.time() : 0, p, g, M;
    if (f && f.seek(0),
    isNaN(e) || (e = +e),
    eh(e))
        f && (e = Fe.utils.mapRange(f.scrollTrigger.start, f.scrollTrigger.end, 0, d, e)),
        a && ih(a, i, n, !0);
    else {
        Fi(t) && (t = t(l));
        var y = (e || "0").split(" "), S, C, w, T;
        M = zi(t, l) || Dt,
        S = mr(M) || {},
        (!S || !S.left && !S.top) && _n(M).display === "none" && (T = M.style.display,
        M.style.display = "block",
        S = mr(M),
        T ? M.style.display = T : M.style.removeProperty("display")),
        C = th(y[0], S[n.d]),
        w = th(y[1] || "0", i),
        e = S[n.p] - c[n.p] - h + C + r - w,
        a && ih(a, w, n, i - w < 20 || a._isStart && w > 20),
        i -= i - w
    }
    if (m && (l[m] = e || -.001,
    e < 0 && (e = 0)),
    o) {
        var B = e + i
          , b = o._isStart;
        p = "scroll" + n.d2,
        ih(o, B, n, b && B > 20 || !b && (u ? Math.max(Dt[p], Dn[p]) : o.parentNode[p]) <= B + 1),
        u && (c = mr(a),
        u && (o.style[n.op.p] = c[n.op.p] - n.op.m - o._offset + ri))
    }
    return f && M && (p = mr(M),
    f.seek(d),
    g = mr(M),
    f._caScrollDist = p[n.p] - g[n.p],
    e = e / f._caScrollDist * d),
    f && f.seek(_),
    f ? e : Math.round(e)
}, Ov = /(webkit|moz|length|cssText|inset)/i, zp = function(e, t, i, n) {
    if (e.parentNode !== t) {
        var r = e.style, o, a;
        if (t === Dt) {
            e._stOrig = r.cssText,
            a = _n(e);
            for (o in a)
                !+o && !Ov.test(o) && a[o] && typeof r[o] == "string" && o !== "0" && (r[o] = a[o]);
            r.top = i,
            r.left = n
        } else
            r.cssText = e._stOrig;
        Fe.core.getCache(e).uncache = 1,
        t.appendChild(e)
    }
}, X0 = function(e, t, i) {
    var n = t
      , r = n;
    return function(o) {
        var a = Math.round(e());
        return a !== n && a !== r && Math.abs(a - n) > 3 && Math.abs(a - r) > 3 && (o = a,
        i && i()),
        r = n,
        n = o,
        o
    }
}, ql = function(e, t, i) {
    var n = {};
    n[t.p] = "+=" + i,
    Fe.set(e, n)
}, kp = function(e, t) {
    var i = hs(e, t)
      , n = "_scroll" + t.p2
      , r = function o(a, l, c, h, u) {
        var d = o.tween
          , f = l.onComplete
          , m = {};
        c = c || i();
        var _ = X0(i, c, function() {
            d.kill(),
            o.tween = 0
        });
        return u = h && u || 0,
        h = h || a - c,
        d && d.kill(),
        l[n] = a,
        l.modifiers = m,
        m[n] = function() {
            return _(c + h * d.ratio + u * d.ratio * d.ratio)
        }
        ,
        l.onUpdate = function() {
            pt.cache++,
            o.tween && Sr()
        }
        ,
        l.onComplete = function() {
            o.tween = 0,
            f && f.call(d)
        }
        ,
        d = o.tween = Fe.to(e, l),
        d
    };
    return e[n] = i,
    i.wheelHandler = function() {
        return r.tween && r.tween.kill() && (r.tween = 0)
    }
    ,
    oi(e, "wheel", i.wheelHandler),
    _t.isTouch && oi(e, "touchmove", i.wheelHandler),
    r
}, _t = function() {
    function s(t, i) {
        Ho || s.register(Fe) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        Gd(this),
        this.init(t, i)
    }
    var e = s.prototype;
    return e.init = function(i, n) {
        if (this.progress = this.start = 0,
        this.vars && this.kill(!0, !0),
        !Ha) {
            this.update = this.refresh = this.kill = kn;
            return
        }
        i = Dp(nn(i) || eh(i) || i.nodeType ? {
            trigger: i
        } : i, Vl);
        var r = i, o = r.onUpdate, a = r.toggleClass, l = r.id, c = r.onToggle, h = r.onRefresh, u = r.scrub, d = r.trigger, f = r.pin, m = r.pinSpacing, _ = r.invalidateOnRefresh, p = r.anticipatePin, g = r.onScrubComplete, M = r.onSnapComplete, y = r.once, S = r.snap, C = r.pinReparent, w = r.pinSpacer, T = r.containerAnimation, B = r.fastScrollEnd, b = r.preventOverlaps, E = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? Ni : Qt, G = !u && u !== 0, k = zi(i.scroller || xt), te = Fe.core.getCache(k), O = Qs(k), H = ("pinType"in i ? i.pinType : ns(k, "pinType") || O && "fixed") === "fixed", V = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack], Y = G && i.toggleActions.split(" "), K = "markers"in i ? i.markers : Vl.markers, J = O ? 0 : parseFloat(_n(k)["border" + E.p2 + ua]) || 0, D = this, se = i.onRefreshInit && function() {
            return i.onRefreshInit(D)
        }
        , de = Av(k, O, E), Q = Rv(k, O), re = 0, ge = 0, fe = 0, ve = hs(k, E), Ue, ke, Ve, Ke, $, Qe, Re, ze, Pe, Z, Ye, L, R, X, ue, ce, pe, be, me, Ee, Oe, Je, le, lt, Ze, We, Ce, Le, $e, et, st, we, j, z, _e, xe, Xe, He, ut;
        if (D._startClamp = D._endClamp = !1,
        D._dir = E,
        p *= 45,
        D.scroller = k,
        D.scroll = T ? T.time.bind(T) : ve,
        Ke = ve(),
        D.vars = i,
        n = n || i.animation,
        "refreshPriority"in i && (C0 = 1,
        i.refreshPriority === -9999 && (el = D)),
        te.tweenScroll = te.tweenScroll || {
            top: kp(k, Qt),
            left: kp(k, Ni)
        },
        D.tweenTo = Ue = te.tweenScroll[E.p],
        D.scrubDuration = function(Me) {
            j = eh(Me) && Me,
            j ? we ? we.duration(Me) : we = Fe.to(n, {
                ease: "expo",
                totalProgress: "+=0",
                duration: j,
                paused: !0,
                onComplete: function() {
                    return g && g(D)
                }
            }) : (we && we.progress(1).kill(),
            we = 0)
        }
        ,
        n && (n.vars.lazy = !1,
        n._initted && !D.isReverted || n.vars.immediateRender !== !1 && i.immediateRender !== !1 && n.duration() && n.render(0, !0, !0),
        D.animation = n.pause(),
        n.scrollTrigger = D,
        D.scrubDuration(u),
        et = 0,
        l || (l = n.vars.id)),
        S && ((!Rs(S) || S.push) && (S = {
            snapTo: S
        }),
        "scrollBehavior"in Dt.style && Fe.set(O ? [Dt, Dn] : k, {
            scrollBehavior: "auto"
        }),
        pt.forEach(function(Me) {
            return Fi(Me) && Me.target === (O ? Bt.scrollingElement || Dn : k) && (Me.smooth = !1)
        }),
        Ve = Fi(S.snapTo) ? S.snapTo : S.snapTo === "labels" ? Pv(n) : S.snapTo === "labelsDirectional" ? Lv(n) : S.directional !== !1 ? function(Me, tt) {
            return kf(S.snapTo)(Me, Li() - ge < 500 ? 0 : tt.direction)
        }
        : Fe.utils.snap(S.snapTo),
        z = S.duration || {
            min: .1,
            max: 2
        },
        z = Rs(z) ? qo(z.min, z.max) : qo(z, z),
        _e = Fe.delayedCall(S.delay || j / 2 || .1, function() {
            var Me = ve()
              , tt = Li() - ge < 500
              , je = Ue.tween;
            if ((tt || Math.abs(D.getVelocity()) < 10) && !je && !Ih && re !== Me) {
                var ct = (Me - Qe) / X
                  , St = n && !G ? n.totalProgress() : ct
                  , at = tt ? 0 : (St - st) / (Li() - Qc) * 1e3 || 0
                  , Be = Fe.utils.clamp(-ct, 1 - ct, ao(at / 2) * at / .185)
                  , Vt = ct + (S.inertia === !1 ? 0 : Be)
                  , Ft = qo(0, 1, Ve(Vt, D))
                  , v = Math.round(Qe + Ft * X)
                  , A = S
                  , F = A.onStart
                  , x = A.onInterrupt
                  , P = A.onComplete;
                if (Me <= Re && Me >= Qe && v !== Me) {
                    if (je && !je._initted && je.data <= ao(v - Me))
                        return;
                    S.inertia === !1 && (Be = Ft - ct),
                    Ue(v, {
                        duration: z(ao(Math.max(ao(Vt - St), ao(Ft - St)) * .185 / at / .05 || 0)),
                        ease: S.ease || "power3",
                        data: ao(v - Me),
                        onInterrupt: function() {
                            return _e.restart(!0) && x && x(D)
                        },
                        onComplete: function() {
                            D.update(),
                            re = ve(),
                            we && n && n.progress(Ft),
                            et = st = n && !G ? n.totalProgress() : D.progress,
                            M && M(D),
                            P && P(D)
                        }
                    }, Me, Be * X, v - Me - Be * X),
                    F && F(D, Ue.tween)
                }
            } else
                D.isActive && re !== Me && _e.restart(!0)
        }).pause()),
        l && (Xd[l] = D),
        d = D.trigger = zi(d || f !== !0 && f),
        ut = d && d._gsap && d._gsap.stRevert,
        ut && (ut = ut(D)),
        f = f === !0 ? d : zi(f),
        nn(a) && (a = {
            targets: d,
            className: a
        }),
        f && (m === !1 || m === gn || (m = !m && f.parentNode && f.parentNode.style && _n(f.parentNode).display === "flex" ? !1 : jt),
        D.pin = f,
        ke = Fe.core.getCache(f),
        ke.spacer ? ue = ke.pinState : (w && (w = zi(w),
        w && !w.nodeType && (w = w.current || w.nativeElement),
        ke.spacerIsNative = !!w,
        w && (ke.spacerState = Xl(w))),
        ke.spacer = be = w || Bt.createElement("div"),
        be.classList.add("pin-spacer"),
        l && be.classList.add("pin-spacer-" + l),
        ke.pinState = ue = Xl(f)),
        i.force3D !== !1 && Fe.set(f, {
            force3D: !0
        }),
        D.spacer = be = ke.spacer,
        $e = _n(f),
        lt = $e[m + E.os2],
        Ee = Fe.getProperty(f),
        Oe = Fe.quickSetter(f, E.a, ri),
        iu(f, be, $e),
        pe = Xl(f)),
        K) {
            L = Rs(K) ? Dp(K, Up) : Up,
            Z = Wl("scroller-start", l, k, E, L, 0),
            Ye = Wl("scroller-end", l, k, E, L, 0, Z),
            me = Z["offset" + E.op.d2];
            var Ie = zi(ns(k, "content") || k);
            ze = this.markerStart = Wl("start", l, Ie, E, L, me, 0, T),
            Pe = this.markerEnd = Wl("end", l, Ie, E, L, me, 0, T),
            T && (He = Fe.quickSetter([ze, Pe], E.a, ri)),
            !H && !(jn.length && ns(k, "fixedMarkers") === !0) && (Cv(O ? Dt : k),
            Fe.set([Z, Ye], {
                force3D: !0
            }),
            We = Fe.quickSetter(Z, E.a, ri),
            Le = Fe.quickSetter(Ye, E.a, ri))
        }
        if (T) {
            var De = T.vars.onUpdate
              , nt = T.vars.onUpdateParams;
            T.eventCallback("onUpdate", function() {
                D.update(0, 0, 1),
                De && De.apply(T, nt || [])
            })
        }
        if (D.previous = function() {
            return ft[ft.indexOf(D) - 1]
        }
        ,
        D.next = function() {
            return ft[ft.indexOf(D) + 1]
        }
        ,
        D.revert = function(Me, tt) {
            if (!tt)
                return D.kill(!0);
            var je = Me !== !1 || !D.enabled
              , ct = yi;
            je !== D.isReverted && (je && (xe = Math.max(ve(), D.scroll.rec || 0),
            fe = D.progress,
            Xe = n && n.progress()),
            ze && [ze, Pe, Z, Ye].forEach(function(St) {
                return St.style.display = je ? "none" : "block"
            }),
            je && (yi = D,
            D.update(je)),
            f && (!C || !D.isActive) && (je ? Uv(f, be, ue) : iu(f, be, _n(f), Ze)),
            je || D.update(je),
            yi = ct,
            D.isReverted = je)
        }
        ,
        D.refresh = function(Me, tt, je, ct) {
            if (!((yi || !D.enabled) && !tt)) {
                if (f && Me && Sn) {
                    oi(s, "scrollEnd", H0);
                    return
                }
                !Pi && se && se(D),
                yi = D,
                Ue.tween && !je && (Ue.tween.kill(),
                Ue.tween = 0),
                we && we.pause(),
                _ && n && n.revert({
                    kill: !1
                }).invalidate(),
                D.isReverted || D.revert(!0, !0),
                D._subPinOffset = !1;
                var St = de(), at = Q(), Be = T ? T.duration() : qn(k, E), Vt = X <= .01, Ft = 0, v = ct || 0, A = Rs(je) ? je.end : i.end, F = i.endTrigger || d, x = Rs(je) ? je.start : i.start || (i.start === 0 || !d ? 0 : f ? "0 0" : "0 100%"), P = D.pinnedContainer = i.pinnedContainer && zi(i.pinnedContainer, D), I = d && Math.max(0, ft.indexOf(D)) || 0, U = I, N, W, q, ie, oe, ae, he, ye, Se, Ae, Ne, dt, it;
                for (K && Rs(je) && (dt = Fe.getProperty(Z, E.p),
                it = Fe.getProperty(Ye, E.p)); U--; )
                    ae = ft[U],
                    ae.end || ae.refresh(0, 1) || (yi = D),
                    he = ae.pin,
                    he && (he === d || he === f || he === P) && !ae.isReverted && (Ae || (Ae = []),
                    Ae.unshift(ae),
                    ae.revert(!0, !0)),
                    ae !== ft[U] && (I--,
                    U--);
                for (Fi(x) && (x = x(D)),
                x = Cp(x, "start", D),
                Qe = Bp(x, d, St, E, ve(), ze, Z, D, at, J, H, Be, T, D._startClamp && "_startClamp") || (f ? -.001 : 0),
                Fi(A) && (A = A(D)),
                nn(A) && !A.indexOf("+=") && (~A.indexOf(" ") ? A = (nn(x) ? x.split(" ")[0] : "") + A : (Ft = th(A.substr(2), St),
                A = nn(x) ? x : (T ? Fe.utils.mapRange(0, T.duration(), T.scrollTrigger.start, T.scrollTrigger.end, Qe) : Qe) + Ft,
                F = d)),
                A = Cp(A, "end", D),
                Re = Math.max(Qe, Bp(A || (F ? "100% 0" : Be), F, St, E, ve() + Ft, Pe, Ye, D, at, J, H, Be, T, D._endClamp && "_endClamp")) || -.001,
                Ft = 0,
                U = I; U--; )
                    ae = ft[U],
                    he = ae.pin,
                    he && ae.start - ae._pinPush <= Qe && !T && ae.end > 0 && (N = ae.end - (D._startClamp ? Math.max(0, ae.start) : ae.start),
                    (he === d && ae.start - ae._pinPush < Qe || he === P) && isNaN(x) && (Ft += N * (1 - ae.progress)),
                    he === f && (v += N));
                if (Qe += Ft,
                Re += Ft,
                D._startClamp && (D._startClamp += Ft),
                D._endClamp && !Pi && (D._endClamp = Re || -.001,
                Re = Math.min(Re, qn(k, E))),
                X = Re - Qe || (Qe -= .01) && .001,
                Vt && (fe = Fe.utils.clamp(0, 1, Fe.utils.normalize(Qe, Re, xe))),
                D._pinPush = v,
                ze && Ft && (N = {},
                N[E.a] = "+=" + Ft,
                P && (N[E.p] = "-=" + ve()),
                Fe.set([ze, Pe], N)),
                f && !(Vd && D.end >= qn(k, E)))
                    N = _n(f),
                    ie = E === Qt,
                    q = ve(),
                    Je = parseFloat(Ee(E.a)) + v,
                    !Be && Re > 1 && (Ne = (O ? Bt.scrollingElement || Dn : k).style,
                    Ne = {
                        style: Ne,
                        value: Ne["overflow" + E.a.toUpperCase()]
                    },
                    O && _n(Dt)["overflow" + E.a.toUpperCase()] !== "scroll" && (Ne.style["overflow" + E.a.toUpperCase()] = "scroll")),
                    iu(f, be, N),
                    pe = Xl(f),
                    W = mr(f, !0),
                    ye = H && hs(k, ie ? Ni : Qt)(),
                    m && (Ze = [m + E.os2, X + v + ri],
                    Ze.t = be,
                    U = m === jt ? Wd(f, E) + X + v : 0,
                    U && (Ze.push(E.d, U + ri),
                    be.style.flexBasis !== "auto" && (be.style.flexBasis = U + ri)),
                    ta(Ze),
                    P && ft.forEach(function(Ge) {
                        Ge.pin === P && Ge.vars.pinSpacing !== !1 && (Ge._subPinOffset = !0)
                    }),
                    H && ve(xe)),
                    H && (oe = {
                        top: W.top + (ie ? q - Qe : ye) + ri,
                        left: W.left + (ie ? ye : q - Qe) + ri,
                        boxSizing: "border-box",
                        position: "fixed"
                    },
                    oe[Gs] = oe["max" + ua] = Math.ceil(W.width) + ri,
                    oe[Vs] = oe["max" + zf] = Math.ceil(W.height) + ri,
                    oe[gn] = oe[gn + Ja] = oe[gn + Za] = oe[gn + Qa] = oe[gn + Ka] = "0",
                    oe[jt] = N[jt],
                    oe[jt + Ja] = N[jt + Ja],
                    oe[jt + Za] = N[jt + Za],
                    oe[jt + Qa] = N[jt + Qa],
                    oe[jt + Ka] = N[jt + Ka],
                    ce = Fv(ue, oe, C),
                    Pi && ve(0)),
                    n ? (Se = n._initted,
                    Kh(1),
                    n.render(n.duration(), !0, !0),
                    le = Ee(E.a) - Je + X + v,
                    Ce = Math.abs(X - le) > 1,
                    H && Ce && ce.splice(ce.length - 2, 2),
                    n.render(0, !0, !0),
                    Se || n.invalidate(!0),
                    n.parent || n.totalTime(n.totalTime()),
                    Kh(0)) : le = X,
                    Ne && (Ne.value ? Ne.style["overflow" + E.a.toUpperCase()] = Ne.value : Ne.style.removeProperty("overflow-" + E.a));
                else if (d && ve() && !T)
                    for (W = d.parentNode; W && W !== Dt; )
                        W._pinOffset && (Qe -= W._pinOffset,
                        Re -= W._pinOffset),
                        W = W.parentNode;
                Ae && Ae.forEach(function(Ge) {
                    return Ge.revert(!1, !0)
                }),
                D.start = Qe,
                D.end = Re,
                Ke = $ = Pi ? xe : ve(),
                !T && !Pi && (Ke < xe && ve(xe),
                D.scroll.rec = 0),
                D.revert(!1, !0),
                ge = Li(),
                _e && (re = -1,
                _e.restart(!0)),
                yi = 0,
                n && G && (n._initted || Xe) && n.progress() !== Xe && n.progress(Xe || 0, !0).render(n.time(), !0, !0),
                (Vt || fe !== D.progress || T) && (n && !G && n.totalProgress(T && Qe < -.001 && !fe ? Fe.utils.normalize(Qe, Re, 0) : fe, !0),
                D.progress = Vt || (Ke - Qe) / X === fe ? 0 : fe),
                f && m && (be._pinOffset = Math.round(D.progress * le)),
                we && we.invalidate(),
                isNaN(dt) || (dt -= Fe.getProperty(Z, E.p),
                it -= Fe.getProperty(Ye, E.p),
                ql(Z, E, dt),
                ql(ze, E, dt - (ct || 0)),
                ql(Ye, E, it),
                ql(Pe, E, it - (ct || 0))),
                Vt && !Pi && D.update(),
                h && !Pi && !R && (R = !0,
                h(D),
                R = !1)
            }
        }
        ,
        D.getVelocity = function() {
            return (ve() - $) / (Li() - Qc) * 1e3 || 0
        }
        ,
        D.endAnimation = function() {
            Ea(D.callbackAnimation),
            n && (we ? we.progress(1) : n.paused() ? G || Ea(n, D.direction < 0, 1) : Ea(n, n.reversed()))
        }
        ,
        D.labelToScroll = function(Me) {
            return n && n.labels && (Qe || D.refresh() || Qe) + n.labels[Me] / n.duration() * X || 0
        }
        ,
        D.getTrailing = function(Me) {
            var tt = ft.indexOf(D)
              , je = D.direction > 0 ? ft.slice(0, tt).reverse() : ft.slice(tt + 1);
            return (nn(Me) ? je.filter(function(ct) {
                return ct.vars.preventOverlaps === Me
            }) : je).filter(function(ct) {
                return D.direction > 0 ? ct.end <= Qe : ct.start >= Re
            })
        }
        ,
        D.update = function(Me, tt, je) {
            if (!(T && !je && !Me)) {
                var ct = Pi === !0 ? xe : D.scroll(), St = Me ? 0 : (ct - Qe) / X, at = St < 0 ? 0 : St > 1 ? 1 : St || 0, Be = D.progress, Vt, Ft, v, A, F, x, P, I;
                if (tt && ($ = Ke,
                Ke = T ? ve() : ct,
                S && (st = et,
                et = n && !G ? n.totalProgress() : at)),
                p && !at && f && !yi && !zl && Sn && Qe < ct + (ct - $) / (Li() - Qc) * p && (at = 1e-4),
                at !== Be && D.enabled) {
                    if (Vt = D.isActive = !!at && at < 1,
                    Ft = !!Be && Be < 1,
                    x = Vt !== Ft,
                    F = x || !!at != !!Be,
                    D.direction = at > Be ? 1 : -1,
                    D.progress = at,
                    F && !yi && (v = at && !Be ? 0 : at === 1 ? 1 : Be === 1 ? 2 : 3,
                    G && (A = !x && Y[v + 1] !== "none" && Y[v + 1] || Y[v],
                    I = n && (A === "complete" || A === "reset" || A in n))),
                    b && (x || I) && (I || u || !n) && (Fi(b) ? b(D) : D.getTrailing(b).forEach(function(q) {
                        return q.endAnimation()
                    })),
                    G || (we && !yi && !zl ? (we._dp._time - we._start !== we._time && we.render(we._dp._time - we._start),
                    we.resetTo ? we.resetTo("totalProgress", at, n._tTime / n._tDur) : (we.vars.totalProgress = at,
                    we.invalidate().restart())) : n && n.totalProgress(at, !!(yi && (ge || Me)))),
                    f) {
                        if (Me && m && (be.style[m + E.os2] = lt),
                        !H)
                            Oe(Ga(Je + le * at));
                        else if (F) {
                            if (P = !Me && at > Be && Re + 1 > ct && ct + 1 >= qn(k, E),
                            C)
                                if (!Me && (Vt || P)) {
                                    var U = mr(f, !0)
                                      , N = ct - Qe;
                                    zp(f, Dt, U.top + (E === Qt ? N : 0) + ri, U.left + (E === Qt ? 0 : N) + ri)
                                } else
                                    zp(f, be);
                            ta(Vt || P ? ce : pe),
                            Ce && at < 1 && Vt || Oe(Je + (at === 1 && !P ? le : 0))
                        }
                    }
                    S && !Ue.tween && !yi && !zl && _e.restart(!0),
                    a && (x || y && at && (at < 1 || !Jh)) && ml(a.targets).forEach(function(q) {
                        return q.classList[Vt || y ? "add" : "remove"](a.className)
                    }),
                    o && !G && !Me && o(D),
                    F && !yi ? (G && (I && (A === "complete" ? n.pause().totalProgress(1) : A === "reset" ? n.restart(!0).pause() : A === "restart" ? n.restart(!0) : n[A]()),
                    o && o(D)),
                    (x || !Jh) && (c && x && eu(D, c),
                    V[v] && eu(D, V[v]),
                    y && (at === 1 ? D.kill(!1, 1) : V[v] = 0),
                    x || (v = at === 1 ? 1 : 3,
                    V[v] && eu(D, V[v]))),
                    B && !Vt && Math.abs(D.getVelocity()) > (eh(B) ? B : 2500) && (Ea(D.callbackAnimation),
                    we ? we.progress(1) : Ea(n, A === "reverse" ? 1 : !at, 1))) : G && o && !yi && o(D)
                }
                if (Le) {
                    var W = T ? ct / T.duration() * (T._caScrollDist || 0) : ct;
                    We(W + (Z._isFlipped ? 1 : 0)),
                    Le(W)
                }
                He && He(-ct / T.duration() * (T._caScrollDist || 0))
            }
        }
        ,
        D.enable = function(Me, tt) {
            D.enabled || (D.enabled = !0,
            oi(k, "resize", Va),
            O || oi(k, "scroll", lo),
            se && oi(s, "refreshInit", se),
            Me !== !1 && (D.progress = fe = 0,
            Ke = $ = re = ve()),
            tt !== !1 && D.refresh())
        }
        ,
        D.getTween = function(Me) {
            return Me && Ue ? Ue.tween : we
        }
        ,
        D.setPositions = function(Me, tt, je, ct) {
            if (T) {
                var St = T.scrollTrigger
                  , at = T.duration()
                  , Be = St.end - St.start;
                Me = St.start + Be * Me / at,
                tt = St.start + Be * tt / at
            }
            D.refresh(!1, !1, {
                start: Pp(Me, je && !!D._startClamp),
                end: Pp(tt, je && !!D._endClamp)
            }, ct),
            D.update()
        }
        ,
        D.adjustPinSpacing = function(Me) {
            if (Ze && Me) {
                var tt = Ze.indexOf(E.d) + 1;
                Ze[tt] = parseFloat(Ze[tt]) + Me + ri,
                Ze[1] = parseFloat(Ze[1]) + Me + ri,
                ta(Ze)
            }
        }
        ,
        D.disable = function(Me, tt) {
            if (D.enabled && (Me !== !1 && D.revert(!0, !0),
            D.enabled = D.isActive = !1,
            tt || we && we.pause(),
            xe = 0,
            ke && (ke.uncache = 1),
            se && si(s, "refreshInit", se),
            _e && (_e.pause(),
            Ue.tween && Ue.tween.kill() && (Ue.tween = 0)),
            !O)) {
                for (var je = ft.length; je--; )
                    if (ft[je].scroller === k && ft[je] !== D)
                        return;
                si(k, "resize", Va),
                O || si(k, "scroll", lo)
            }
        }
        ,
        D.kill = function(Me, tt) {
            D.disable(Me, tt),
            we && !tt && we.kill(),
            l && delete Xd[l];
            var je = ft.indexOf(D);
            je >= 0 && ft.splice(je, 1),
            je === Ci && nh > 0 && Ci--,
            je = 0,
            ft.forEach(function(ct) {
                return ct.scroller === D.scroller && (je = 1)
            }),
            je || Pi || (D.scroll.rec = 0),
            n && (n.scrollTrigger = null,
            Me && n.revert({
                kill: !1
            }),
            tt || n.kill()),
            ze && [ze, Pe, Z, Ye].forEach(function(ct) {
                return ct.parentNode && ct.parentNode.removeChild(ct)
            }),
            el === D && (el = 0),
            f && (ke && (ke.uncache = 1),
            je = 0,
            ft.forEach(function(ct) {
                return ct.pin === f && je++
            }),
            je || (ke.spacer = 0)),
            i.onKill && i.onKill(D)
        }
        ,
        ft.push(D),
        D.enable(!1, !1),
        ut && ut(D),
        n && n.add && !X) {
            var rt = D.update;
            D.update = function() {
                D.update = rt,
                Qe || Re || D.refresh()
            }
            ,
            Fe.delayedCall(.01, D.update),
            X = .01,
            Qe = Re = 0
        } else
            D.refresh();
        f && Dv()
    }
    ,
    s.register = function(i) {
        return Ho || (Fe = i || N0(),
        U0() && window.document && s.enable(),
        Ho = Ha),
        Ho
    }
    ,
    s.defaults = function(i) {
        if (i)
            for (var n in i)
                Vl[n] = i[n];
        return Vl
    }
    ,
    s.disable = function(i, n) {
        Ha = 0,
        ft.forEach(function(o) {
            return o[n ? "kill" : "disable"](i)
        }),
        si(xt, "wheel", lo),
        si(Bt, "scroll", lo),
        clearInterval(Bl),
        si(Bt, "touchcancel", kn),
        si(Dt, "touchstart", kn),
        Hl(si, Bt, "pointerdown,touchstart,mousedown", Lp),
        Hl(si, Bt, "pointerup,touchend,mouseup", Ip),
        xh.kill(),
        kl(si);
        for (var r = 0; r < pt.length; r += 3)
            Gl(si, pt[r], pt[r + 1]),
            Gl(si, pt[r], pt[r + 2])
    }
    ,
    s.enable = function() {
        if (xt = window,
        Bt = document,
        Dn = Bt.documentElement,
        Dt = Bt.body,
        Fe && (ml = Fe.utils.toArray,
        qo = Fe.utils.clamp,
        Gd = Fe.core.context || kn,
        Kh = Fe.core.suppressOverwrites || kn,
        Nf = xt.history.scrollRestoration || "auto",
        qd = xt.pageYOffset,
        Fe.core.globals("ScrollTrigger", s),
        Dt)) {
            Ha = 1,
            ea = document.createElement("div"),
            ea.style.height = "100vh",
            ea.style.position = "absolute",
            W0(),
            wv(),
            Kt.register(Fe),
            s.isTouch = Kt.isTouch,
            Wr = Kt.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
            oi(xt, "wheel", lo),
            R0 = [xt, Bt, Dn, Dt],
            Fe.matchMedia ? (s.matchMedia = function(l) {
                var c = Fe.matchMedia(), h;
                for (h in l)
                    c.add(h, l[h]);
                return c
            }
            ,
            Fe.addEventListener("matchMediaInit", function() {
                return Hf()
            }),
            Fe.addEventListener("matchMediaRevert", function() {
                return G0()
            }),
            Fe.addEventListener("matchMedia", function() {
                Ns(0, 1),
                to("matchMedia")
            }),
            Fe.matchMedia("(orientation: portrait)", function() {
                return tu(),
                tu
            })) : console.warn("Requires GSAP 3.11.0 or later"),
            tu(),
            oi(Bt, "scroll", lo);
            var i = Dt.style, n = i.borderTopStyle, r = Fe.core.Animation.prototype, o, a;
            for (r.revert || Object.defineProperty(r, "revert", {
                value: function() {
                    return this.time(-.01, !0)
                }
            }),
            i.borderTopStyle = "solid",
            o = mr(Dt),
            Qt.m = Math.round(o.top + Qt.sc()) || 0,
            Ni.m = Math.round(o.left + Ni.sc()) || 0,
            n ? i.borderTopStyle = n : i.removeProperty("border-top-style"),
            Bl = setInterval(Np, 250),
            Fe.delayedCall(.5, function() {
                return zl = 0
            }),
            oi(Bt, "touchcancel", kn),
            oi(Dt, "touchstart", kn),
            Hl(oi, Bt, "pointerdown,touchstart,mousedown", Lp),
            Hl(oi, Bt, "pointerup,touchend,mouseup", Ip),
            Hd = Fe.utils.checkPrefix("transform"),
            rh.push(Hd),
            Ho = Li(),
            xh = Fe.delayedCall(.2, Ns).pause(),
            Go = [Bt, "visibilitychange", function() {
                var l = xt.innerWidth
                  , c = xt.innerHeight;
                Bt.hidden ? (Ap = l,
                Rp = c) : (Ap !== l || Rp !== c) && Va()
            }
            , Bt, "DOMContentLoaded", Ns, xt, "load", Ns, xt, "resize", Va],
            kl(oi),
            ft.forEach(function(l) {
                return l.enable(0, 1)
            }),
            a = 0; a < pt.length; a += 3)
                Gl(si, pt[a], pt[a + 1]),
                Gl(si, pt[a], pt[a + 2])
        }
    }
    ,
    s.config = function(i) {
        "limitCallbacks"in i && (Jh = !!i.limitCallbacks);
        var n = i.syncInterval;
        n && clearInterval(Bl) || (Bl = n) && setInterval(Np, n),
        "ignoreMobileResize"in i && (L0 = s.isTouch === 1 && i.ignoreMobileResize),
        "autoRefreshEvents"in i && (kl(si) || kl(oi, i.autoRefreshEvents || "none"),
        P0 = (i.autoRefreshEvents + "").indexOf("resize") === -1)
    }
    ,
    s.scrollerProxy = function(i, n) {
        var r = zi(i)
          , o = pt.indexOf(r)
          , a = Qs(r);
        ~o && pt.splice(o, a ? 6 : 2),
        n && (a ? jn.unshift(xt, n, Dt, n, Dn, n) : jn.unshift(r, n))
    }
    ,
    s.clearMatchMedia = function(i) {
        ft.forEach(function(n) {
            return n._ctx && n._ctx.query === i && n._ctx.kill(!0, !0)
        })
    }
    ,
    s.isInViewport = function(i, n, r) {
        var o = (nn(i) ? zi(i) : i).getBoundingClientRect()
          , a = o[r ? Gs : Vs] * n || 0;
        return r ? o.right - a > 0 && o.left + a < xt.innerWidth : o.bottom - a > 0 && o.top + a < xt.innerHeight
    }
    ,
    s.positionInViewport = function(i, n, r) {
        nn(i) && (i = zi(i));
        var o = i.getBoundingClientRect()
          , a = o[r ? Gs : Vs]
          , l = n == null ? a / 2 : n in vh ? vh[n] * a : ~n.indexOf("%") ? parseFloat(n) * a / 100 : parseFloat(n) || 0;
        return r ? (o.left + l) / xt.innerWidth : (o.top + l) / xt.innerHeight
    }
    ,
    s.killAll = function(i) {
        if (ft.slice(0).forEach(function(r) {
            return r.vars.id !== "ScrollSmoother" && r.kill()
        }),
        i !== !0) {
            var n = eo.killAll || [];
            eo = {},
            n.forEach(function(r) {
                return r()
            })
        }
    }
    ,
    s
}();
_t.version = "3.12.4";
_t.saveStyles = function(s) {
    return s ? ml(s).forEach(function(e) {
        if (e && e.style) {
            var t = tn.indexOf(e);
            t >= 0 && tn.splice(t, 5),
            tn.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Fe.core.getCache(e), Gd())
        }
    }) : tn
}
;
_t.revert = function(s, e) {
    return Hf(!s, e)
}
;
_t.create = function(s, e) {
    return new _t(s,e)
}
;
_t.refresh = function(s) {
    return s ? Va() : (Ho || _t.register()) && Ns(!0)
}
;
_t.update = function(s) {
    return ++pt.cache && Sr(s === !0 ? 2 : 0)
}
;
_t.clearScrollMemory = V0;
_t.maxScroll = function(s, e) {
    return qn(s, e ? Ni : Qt)
}
;
_t.getScrollFunc = function(s, e) {
    return hs(zi(s), e ? Ni : Qt)
}
;
_t.getById = function(s) {
    return Xd[s]
}
;
_t.getAll = function() {
    return ft.filter(function(s) {
        return s.vars.id !== "ScrollSmoother"
    })
}
;
_t.isScrolling = function() {
    return !!Sn
}
;
_t.snapDirectional = kf;
_t.addEventListener = function(s, e) {
    var t = eo[s] || (eo[s] = []);
    ~t.indexOf(e) || t.push(e)
}
;
_t.removeEventListener = function(s, e) {
    var t = eo[s]
      , i = t && t.indexOf(e);
    i >= 0 && t.splice(i, 1)
}
;
_t.batch = function(s, e) {
    var t = [], i = {}, n = e.interval || .016, r = e.batchMax || 1e9, o = function(c, h) {
        var u = []
          , d = []
          , f = Fe.delayedCall(n, function() {
            h(u, d),
            u = [],
            d = []
        }).pause();
        return function(m) {
            u.length || f.restart(!0),
            u.push(m.trigger),
            d.push(m),
            r <= u.length && f.progress(1)
        }
    }, a;
    for (a in e)
        i[a] = a.substr(0, 2) === "on" && Fi(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
    return Fi(r) && (r = r(),
    oi(_t, "refresh", function() {
        return r = e.batchMax()
    })),
    ml(s).forEach(function(l) {
        var c = {};
        for (a in i)
            c[a] = i[a];
        c.trigger = l,
        t.push(_t.create(c))
    }),
    t
}
;
var Hp = function(e, t, i, n) {
    return t > n ? e(n) : t < 0 && e(0),
    i > n ? (n - t) / (i - t) : i < 0 ? t / (t - i) : 1
}, nu = function s(e, t) {
    t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Kt.isTouch ? " pinch-zoom" : "") : "none",
    e === Dn && s(Dt, t)
}, Yl = {
    auto: 1,
    scroll: 1
}, Bv = function(e) {
    var t = e.event, i = e.target, n = e.axis, r = (t.changedTouches ? t.changedTouches[0] : t).target, o = r._gsap || Fe.core.getCache(r), a = Li(), l;
    if (!o._isScrollT || a - o._isScrollT > 2e3) {
        for (; r && r !== Dt && (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth || !(Yl[(l = _n(r)).overflowY] || Yl[l.overflowX])); )
            r = r.parentNode;
        o._isScroll = r && r !== i && !Qs(r) && (Yl[(l = _n(r)).overflowY] || Yl[l.overflowX]),
        o._isScrollT = a
    }
    (o._isScroll || n === "x") && (t.stopPropagation(),
    t._gsapAllow = !0)
}, q0 = function(e, t, i, n) {
    return Kt.create({
        target: e,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: t,
        onWheel: n = n && Bv,
        onPress: n,
        onDrag: n,
        onScroll: n,
        onEnable: function() {
            return i && oi(Bt, Kt.eventTypes[0], Vp, !1, !0)
        },
        onDisable: function() {
            return si(Bt, Kt.eventTypes[0], Vp, !0)
        }
    })
}, zv = /(input|label|select|textarea)/i, Gp, Vp = function(e) {
    var t = zv.test(e.target.tagName);
    (t || Gp) && (e._gsapAllow = !0,
    Gp = t)
}, kv = function(e) {
    Rs(e) || (e = {}),
    e.preventDefault = e.isNormalizer = e.allowClicks = !0,
    e.type || (e.type = "wheel,touch"),
    e.debounce = !!e.debounce,
    e.id = e.id || "normalizer";
    var t = e, i = t.normalizeScrollX, n = t.momentum, r = t.allowNestedScroll, o = t.onRelease, a, l, c = zi(e.target) || Dn, h = Fe.core.globals().ScrollSmoother, u = h && h.get(), d = Wr && (e.content && zi(e.content) || u && e.content !== !1 && !u.smooth() && u.content()), f = hs(c, Qt), m = hs(c, Ni), _ = 1, p = (Kt.isTouch && xt.visualViewport ? xt.visualViewport.scale * xt.visualViewport.width : xt.outerWidth) / xt.innerWidth, g = 0, M = Fi(n) ? function() {
        return n(a)
    }
    : function() {
        return n || 2.8
    }
    , y, S, C = q0(c, e.type, !0, r), w = function() {
        return S = !1
    }, T = kn, B = kn, b = function() {
        l = qn(c, Qt),
        B = qo(Wr ? 1 : 0, l),
        i && (T = qo(0, qn(c, Ni))),
        y = Ws
    }, E = function() {
        d._gsap.y = Ga(parseFloat(d._gsap.y) + f.offset) + "px",
        d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)",
        f.offset = f.cacheID = 0
    }, G = function() {
        if (S) {
            requestAnimationFrame(w);
            var K = Ga(a.deltaY / 2)
              , J = B(f.v - K);
            if (d && J !== f.v + f.offset) {
                f.offset = J - f.v;
                var D = Ga((parseFloat(d && d._gsap.y) || 0) - f.offset);
                d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + D + ", 0, 1)",
                d._gsap.y = D + "px",
                f.cacheID = pt.cache,
                Sr()
            }
            return !0
        }
        f.offset && E(),
        S = !0
    }, k, te, O, H, V = function() {
        b(),
        k.isActive() && k.vars.scrollY > l && (f() > l ? k.progress(1) && f(l) : k.resetTo("scrollY", l))
    };
    return d && Fe.set(d, {
        y: "+=0"
    }),
    e.ignoreCheck = function(Y) {
        return Wr && Y.type === "touchmove" && G() || _ > 1.05 && Y.type !== "touchstart" || a.isGesturing || Y.touches && Y.touches.length > 1
    }
    ,
    e.onPress = function() {
        S = !1;
        var Y = _;
        _ = Ga((xt.visualViewport && xt.visualViewport.scale || 1) / p),
        k.pause(),
        Y !== _ && nu(c, _ > 1.01 ? !0 : i ? !1 : "x"),
        te = m(),
        O = f(),
        b(),
        y = Ws
    }
    ,
    e.onRelease = e.onGestureStart = function(Y, K) {
        if (f.offset && E(),
        !K)
            H.restart(!0);
        else {
            pt.cache++;
            var J = M(), D, se;
            i && (D = m(),
            se = D + J * .05 * -Y.velocityX / .227,
            J *= Hp(m, D, se, qn(c, Ni)),
            k.vars.scrollX = T(se)),
            D = f(),
            se = D + J * .05 * -Y.velocityY / .227,
            J *= Hp(f, D, se, qn(c, Qt)),
            k.vars.scrollY = B(se),
            k.invalidate().duration(J).play(.01),
            (Wr && k.vars.scrollY >= l || D >= l - 1) && Fe.to({}, {
                onUpdate: V,
                duration: J
            })
        }
        o && o(Y)
    }
    ,
    e.onWheel = function() {
        k._ts && k.pause(),
        Li() - g > 1e3 && (y = 0,
        g = Li())
    }
    ,
    e.onChange = function(Y, K, J, D, se) {
        if (Ws !== y && b(),
        K && i && m(T(D[2] === K ? te + (Y.startX - Y.x) : m() + K - D[1])),
        J) {
            f.offset && E();
            var de = se[2] === J
              , Q = de ? O + Y.startY - Y.y : f() + J - se[1]
              , re = B(Q);
            de && Q !== re && (O += re - Q),
            f(re)
        }
        (J || K) && Sr()
    }
    ,
    e.onEnable = function() {
        nu(c, i ? !1 : "x"),
        _t.addEventListener("refresh", V),
        oi(xt, "resize", V),
        f.smooth && (f.target.style.scrollBehavior = "auto",
        f.smooth = m.smooth = !1),
        C.enable()
    }
    ,
    e.onDisable = function() {
        nu(c, !0),
        si(xt, "resize", V),
        _t.removeEventListener("refresh", V),
        C.kill()
    }
    ,
    e.lockAxis = e.lockAxis !== !1,
    a = new Kt(e),
    a.iOS = Wr,
    Wr && !f() && f(1),
    Wr && Fe.ticker.add(kn),
    H = a._dc,
    k = Fe.to(a, {
        ease: "power4",
        paused: !0,
        scrollX: i ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
            scrollY: X0(f, f(), function() {
                return k.pause()
            })
        },
        onUpdate: Sr,
        onComplete: H.vars.onComplete
    }),
    a
};
_t.sort = function(s) {
    return ft.sort(s || function(e, t) {
        return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
    }
    )
}
;
_t.observe = function(s) {
    return new Kt(s)
}
;
_t.normalizeScroll = function(s) {
    if (typeof s > "u")
        return Ri;
    if (s === !0 && Ri)
        return Ri.enable();
    if (s === !1) {
        Ri && Ri.kill(),
        Ri = s;
        return
    }
    var e = s instanceof Kt ? s : kv(s);
    return Ri && Ri.target === e.target && Ri.kill(),
    Qs(e.target) && (Ri = e),
    e
}
;
_t.core = {
    _getVelocityProp: kd,
    _inputObserver: q0,
    _scrollers: pt,
    _proxies: jn,
    bridge: {
        ss: function() {
            Sn || to("scrollStart"),
            Sn = Li()
        },
        ref: function() {
            return yi
        }
    }
};
N0() && Fe.registerPlugin(_t);
class _l {
    static random(e, t) {
        return typeof e > "u" ? Math.random() : typeof t > "u" ? Math.random() * e : e + Math.random() * (t - e)
    }
    static randomInt(e, t) {
        return Math.floor(_l.random(e, t))
    }
    static constrain(e, t, i) {
        return Math.max(Math.min(e, i), t)
    }
    static map(e, t, i, n, r) {
        return (e - t) / (i - t) * (r - n) + n
    }
    static radians(e) {
        return e * (2 * Math.PI / 360)
    }
    static magnitude(e, t) {
        return _l.dist(0, 0, e, t)
    }
    static dist(e, t, i, n) {
        return Math.sqrt((e - i) * (e - i) + (t - n) * (t - n))
    }
    static lerp(e, t, i) {
        return e + (t - e) * i
    }
    static lerp2d = (e, t, i) => {
        const n = this.lerp(e.x, t.x, i)
          , r = this.lerp(e.y, t.y, i);
        return {
            x: n,
            y: r
        }
    }
    ;
    static lerp3d = (e, t, i) => {
        const n = this.lerp(e.x, t.x, i)
          , r = this.lerp(e.y, t.y, i)
          , o = this.lerp(e.z, t.z, i);
        return {
            x: n,
            y: r,
            z: o
        }
    }
}
const Y0 = 768
  , Xs = `(max-width: ${Y0}px)`
  , Hv = 1440
  , Gv = 375
  , Vv = 16
  , Wv = .8
  , Xv = "phamminhtuan16204@gmail.com"
  , ru = document.querySelector('[data-js="grid"]')
  , $l = document.querySelector('[data-js="grid-columns"]')
  , jl = document.querySelector('[data-js="grid-rows"]');
let su = 0
  , ou = 0;
const Wp = () => {
    const s = window.matchMedia(Xs).matches
      , e = s ? 24 : 32
      , t = s ? 32 : 48
      , i = e
      , n = Math.floor(e * (window.innerWidth / (s ? Gv : Hv)))
      , r = _l.constrain(n, i, t);
    ru.style.setProperty("--gap", `${r}px`);
    const o = Math.floor(ru.clientWidth / r)
      , a = Math.floor(ru.clientHeight / r);
    if (o !== su || a !== ou) {
        for (; $l.firstChild; )
            $l.removeChild($l.firstChild);
        for (; jl.firstChild; )
            jl.removeChild(jl.firstChild);
        for (let l = 0; l <= o; l++) {
            const c = document.createElement("span");
            c.style.height = `${(r + 1) * a + 1}px`,
            $l.appendChild(c),
            c.style.setProperty("--this-scale", su === 0 ? 0 : 1)
        }
        for (let l = 0; l <= a; l++) {
            const c = document.createElement("span");
            c.style.width = `${(r + 1) * o + 1}px`,
            jl.appendChild(c),
            c.style.setProperty("--this-scale", ou === 0 ? 0 : 1)
        }
    }
    su = o,
    ou = a
}
  , $0 = () => {
    document.documentElement.style.setProperty("--padding-outside", Vv)
}
;
let au = 0;
const qv = () => {
    const s = document.body.clientWidth;
    if (s === au) {
        au = s;
        return
    }
    $0(),
    au = s
}
  , Yv = () => {
    const s = new ResizeObserver(qv);
    return s.observe(document.body),
    $0(),
    () => {
        s.disconnect()
    }
}
  , Mh = s => {
    if (!["light", "dark"].includes(s))
        throw new Error("");
    document.documentElement.setAttribute("data-theme", s),
    sessionStorage.setItem("theme", s)
}
  , $v = () => {
    Mh("light")
}
  , jv = () => {
    Mh("dark")
}
  , Zv = () => {
    const s = [...document.querySelectorAll('[data-js="theme-light"]')]
      , e = [...document.querySelectorAll('[data-js="theme-dark"]')];
    s.forEach(r => r.addEventListener("click", $v)),
    e.forEach(r => r.addEventListener("click", jv));
    const t = sessionStorage.getItem("theme");
    if (t) {
        Mh(t);
        return
    }
    window.matchMedia("(prefers-color-scheme: dark)").matches && Mh("dark")
}
;
let Xp = 0
  , qp = 0;
const Yp = () => {
    document.documentElement.style.setProperty("--vw", `${document.documentElement.offsetWidth / 100}px`),
    document.documentElement.style.setProperty("--vh", `${window.innerHeight / 100}px`),
    window.innerHeight > qp && document.documentElement.style.setProperty("--larger-vh", `${window.innerHeight / 100}px`),
    window.innerWidth !== Xp && document.documentElement.style.setProperty("--initial-vh", `${window.innerHeight / 100}px`),
    Xp = window.innerWidth,
    qp = window.innerHeight
}
  , mi = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
  , lu = Math.PI / 180
  , $d = 180 / Math.PI;
function Al() {
    const s = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (mi[s & 255] + mi[s >> 8 & 255] + mi[s >> 16 & 255] + mi[s >> 24 & 255] + "-" + mi[e & 255] + mi[e >> 8 & 255] + "-" + mi[e >> 16 & 15 | 64] + mi[e >> 24 & 255] + "-" + mi[t & 63 | 128] + mi[t >> 8 & 255] + "-" + mi[t >> 16 & 255] + mi[t >> 24 & 255] + mi[i & 255] + mi[i >> 8 & 255] + mi[i >> 16 & 255] + mi[i >> 24 & 255]).toLowerCase()
}
function ki(s, e, t) {
    return Math.max(e, Math.min(t, s))
}
function Kv(s, e) {
    return (s % e + e) % e
}
function cu(s, e, t) {
    return (1 - t) * s + t * e
}
function $p(s) {
    return (s & s - 1) === 0 && s !== 0
}
function jd(s) {
    return Math.pow(2, Math.floor(Math.log(s) / Math.LN2))
}
function wa(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return s / 4294967295;
    case Uint16Array:
        return s / 65535;
    case Uint8Array:
        return s / 255;
    case Int32Array:
        return Math.max(s / 2147483647, -1);
    case Int16Array:
        return Math.max(s / 32767, -1);
    case Int8Array:
        return Math.max(s / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Bi(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return Math.round(s * 4294967295);
    case Uint16Array:
        return Math.round(s * 65535);
    case Uint8Array:
        return Math.round(s * 255);
    case Int32Array:
        return Math.round(s * 2147483647);
    case Int16Array:
        return Math.round(s * 32767);
    case Int8Array:
        return Math.round(s * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
let Rl = class {
    constructor(e=0, t=0, i=0, n=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = n
    }
    static slerpFlat(e, t, i, n, r, o, a) {
        let l = i[n + 0]
          , c = i[n + 1]
          , h = i[n + 2]
          , u = i[n + 3];
        const d = r[o + 0]
          , f = r[o + 1]
          , m = r[o + 2]
          , _ = r[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = h,
            e[t + 3] = u;
            return
        }
        if (a === 1) {
            e[t + 0] = d,
            e[t + 1] = f,
            e[t + 2] = m,
            e[t + 3] = _;
            return
        }
        if (u !== _ || l !== d || c !== f || h !== m) {
            let p = 1 - a;
            const g = l * d + c * f + h * m + u * _
              , M = g >= 0 ? 1 : -1
              , y = 1 - g * g;
            if (y > Number.EPSILON) {
                const C = Math.sqrt(y)
                  , w = Math.atan2(C, g * M);
                p = Math.sin(p * w) / C,
                a = Math.sin(a * w) / C
            }
            const S = a * M;
            if (l = l * p + d * S,
            c = c * p + f * S,
            h = h * p + m * S,
            u = u * p + _ * S,
            p === 1 - a) {
                const C = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
                l *= C,
                c *= C,
                h *= C,
                u *= C
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = h,
        e[t + 3] = u
    }
    static multiplyQuaternionsFlat(e, t, i, n, r, o) {
        const a = i[n]
          , l = i[n + 1]
          , c = i[n + 2]
          , h = i[n + 3]
          , u = r[o]
          , d = r[o + 1]
          , f = r[o + 2]
          , m = r[o + 3];
        return e[t] = a * m + h * u + l * f - c * d,
        e[t + 1] = l * m + h * d + c * u - a * f,
        e[t + 2] = c * m + h * f + a * d - l * u,
        e[t + 3] = h * m - a * u - l * d - c * f,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, n) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = n,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const i = e._x
          , n = e._y
          , r = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(i / 2)
          , h = a(n / 2)
          , u = a(r / 2)
          , d = l(i / 2)
          , f = l(n / 2)
          , m = l(r / 2);
        switch (o) {
        case "XYZ":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "YXZ":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        case "ZXY":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "ZYX":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        case "YZX":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "XZY":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , n = Math.sin(i);
        return this._x = e.x * n,
        this._y = e.y * n,
        this._z = e.z * n,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , n = t[4]
          , r = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , h = t[6]
          , u = t[10]
          , d = i + a + u;
        if (d > 0) {
            const f = .5 / Math.sqrt(d + 1);
            this._w = .25 / f,
            this._x = (h - l) * f,
            this._y = (r - c) * f,
            this._z = (o - n) * f
        } else if (i > a && i > u) {
            const f = 2 * Math.sqrt(1 + i - a - u);
            this._w = (h - l) / f,
            this._x = .25 * f,
            this._y = (n + o) / f,
            this._z = (r + c) / f
        } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - i - u);
            this._w = (r - c) / f,
            this._x = (n + o) / f,
            this._y = .25 * f,
            this._z = (l + h) / f
        } else {
            const f = 2 * Math.sqrt(1 + u - i - a);
            this._w = (o - n) / f,
            this._x = (r + c) / f,
            this._y = (l + h) / f,
            this._z = .25 * f
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(ki(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const n = Math.min(1, t / i);
        return this.slerp(e, n),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , n = e._y
          , r = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , h = t._w;
        return this._x = i * h + o * a + n * c - r * l,
        this._y = n * h + o * l + r * a - i * c,
        this._z = r * h + o * c + i * l - n * a,
        this._w = o * h - i * a - n * l - r * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , n = this._y
          , r = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + n * e._y + r * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = n,
            this._z = r,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const f = 1 - t;
            return this._w = f * o + t * this._w,
            this._x = f * i + t * this._x,
            this._y = f * n + t * this._y,
            this._z = f * r + t * this._z,
            this.normalize(),
            this
        }
        const c = Math.sqrt(l)
          , h = Math.atan2(c, a)
          , u = Math.sin((1 - t) * h) / c
          , d = Math.sin(t * h) / c;
        return this._w = o * u + this._w * d,
        this._x = i * u + this._x * d,
        this._y = n * u + this._y * d,
        this._z = r * u + this._z * d,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , i = Math.sqrt(e)
          , n = 2 * Math.PI * Math.random()
          , r = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(n), i * Math.sin(r), i * Math.cos(r), t * Math.sin(n))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
  , ne = class j0 {
    constructor(e=0, t=0, i=0) {
        j0.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(jp.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(jp.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6] * n,
        this.y = r[1] * t + r[4] * i + r[7] * n,
        this.z = r[2] * t + r[5] * i + r[8] * n,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = e.elements
          , o = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
        return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * o,
        this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * o,
        this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = 2 * (o * n - a * i)
          , h = 2 * (a * t - r * n)
          , u = 2 * (r * i - o * t);
        return this.x = t + l * c + o * u - a * h,
        this.y = i + l * h + a * c - r * u,
        this.z = n + l * u + r * h - o * c,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[4] * i + r[8] * n,
        this.y = r[1] * t + r[5] * i + r[9] * n,
        this.z = r[2] * t + r[6] * i + r[10] * n,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , n = e.y
          , r = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = n * l - r * a,
        this.y = r * o - i * l,
        this.z = i * a - n * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return hu.copy(this).projectOnVector(e),
        this.sub(hu)
    }
    reflect(e) {
        return this.sub(hu.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(ki(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , n = this.z - e.z;
        return t * t + i * i + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const n = Math.sin(t) * e;
        return this.x = n * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = n * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , n = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = n,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t),
        this.y = i * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
;
const hu = new ne
  , jp = new Rl
  , Jv = "160"
  , Qv = 0
  , Zp = 1
  , eM = 2
  , Z0 = 1
  , tM = 2
  , dr = 3
  , us = 0
  , Yi = 1
  , gr = 2
  , rs = 0
  , ia = 1
  , Kp = 2
  , Jp = 3
  , Qp = 4
  , iM = 5
  , Is = 100
  , nM = 101
  , rM = 102
  , em = 103
  , tm = 104
  , sM = 200
  , oM = 201
  , aM = 202
  , lM = 203
  , Zd = 204
  , Kd = 205
  , cM = 206
  , hM = 207
  , uM = 208
  , dM = 209
  , fM = 210
  , pM = 211
  , mM = 212
  , gM = 213
  , _M = 214
  , xM = 0
  , yM = 1
  , vM = 2
  , Sh = 3
  , MM = 4
  , SM = 5
  , bM = 6
  , TM = 7
  , K0 = 0
  , EM = 1
  , wM = 2
  , ss = 0
  , AM = 1
  , RM = 2
  , CM = 3
  , PM = 4
  , LM = 5
  , IM = 6
  , J0 = 300
  , da = 301
  , fa = 302
  , Jd = 303
  , Qd = 304
  , Dh = 306
  , ef = 1e3
  , Fn = 1001
  , tf = 1002
  , Ii = 1003
  , im = 1004
  , uu = 1005
  , Hi = 1006
  , DM = 1007
  , xl = 1008
  , os = 1009
  , UM = 1010
  , NM = 1011
  , Gf = 1012
  , Q0 = 1013
  , Kr = 1014
  , Jr = 1015
  , yl = 1016
  , ex = 1017
  , tx = 1018
  , qs = 1020
  , FM = 1021
  , On = 1023
  , OM = 1024
  , BM = 1025
  , Ys = 1026
  , pa = 1027
  , zM = 1028
  , ix = 1029
  , kM = 1030
  , nx = 1031
  , rx = 1033
  , du = 33776
  , fu = 33777
  , pu = 33778
  , mu = 33779
  , nm = 35840
  , rm = 35841
  , sm = 35842
  , om = 35843
  , sx = 36196
  , am = 37492
  , lm = 37496
  , cm = 37808
  , hm = 37809
  , um = 37810
  , dm = 37811
  , fm = 37812
  , pm = 37813
  , mm = 37814
  , gm = 37815
  , _m = 37816
  , xm = 37817
  , ym = 37818
  , vm = 37819
  , Mm = 37820
  , Sm = 37821
  , gu = 36492
  , bm = 36494
  , Tm = 36495
  , HM = 36283
  , Em = 36284
  , wm = 36285
  , Am = 36286
  , ox = 3e3
  , $s = 3001
  , GM = 3200
  , VM = 3201
  , WM = 0
  , XM = 1
  , xn = ""
  , ui = "srgb"
  , Er = "srgb-linear"
  , Vf = "display-p3"
  , Uh = "display-p3-linear"
  , bh = "linear"
  , It = "srgb"
  , Th = "rec709"
  , Eh = "p3"
  , co = 7680
  , Rm = 519
  , qM = 512
  , YM = 513
  , $M = 514
  , ax = 515
  , jM = 516
  , ZM = 517
  , KM = 518
  , JM = 519
  , Cm = 35044
  , Pm = "300 es"
  , nf = 1035
  , vr = 2e3
  , wh = 2001;
let $i = class rf {
    constructor(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, p) {
        rf.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, p)
    }
    set(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, p) {
        const g = this.elements;
        return g[0] = e,
        g[4] = t,
        g[8] = i,
        g[12] = n,
        g[1] = r,
        g[5] = o,
        g[9] = a,
        g[13] = l,
        g[2] = c,
        g[6] = h,
        g[10] = u,
        g[14] = d,
        g[3] = f,
        g[7] = m,
        g[11] = _,
        g[15] = p,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new rf().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , n = 1 / ho.setFromMatrixColumn(e, 0).length()
          , r = 1 / ho.setFromMatrixColumn(e, 1).length()
          , o = 1 / ho.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * n,
        t[1] = i[1] * n,
        t[2] = i[2] * n,
        t[3] = 0,
        t[4] = i[4] * r,
        t[5] = i[5] * r,
        t[6] = i[6] * r,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , n = e.y
          , r = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , l = Math.cos(n)
          , c = Math.sin(n)
          , h = Math.cos(r)
          , u = Math.sin(r);
        if (e.order === "XYZ") {
            const d = o * h
              , f = o * u
              , m = a * h
              , _ = a * u;
            t[0] = l * h,
            t[4] = -l * u,
            t[8] = c,
            t[1] = f + m * c,
            t[5] = d - _ * c,
            t[9] = -a * l,
            t[2] = _ - d * c,
            t[6] = m + f * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const d = l * h
              , f = l * u
              , m = c * h
              , _ = c * u;
            t[0] = d + _ * a,
            t[4] = m * a - f,
            t[8] = o * c,
            t[1] = o * u,
            t[5] = o * h,
            t[9] = -a,
            t[2] = f * a - m,
            t[6] = _ + d * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const d = l * h
              , f = l * u
              , m = c * h
              , _ = c * u;
            t[0] = d - _ * a,
            t[4] = -o * u,
            t[8] = m + f * a,
            t[1] = f + m * a,
            t[5] = o * h,
            t[9] = _ - d * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const d = o * h
              , f = o * u
              , m = a * h
              , _ = a * u;
            t[0] = l * h,
            t[4] = m * c - f,
            t[8] = d * c + _,
            t[1] = l * u,
            t[5] = _ * c + d,
            t[9] = f * c - m,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const d = o * l
              , f = o * c
              , m = a * l
              , _ = a * c;
            t[0] = l * h,
            t[4] = _ - d * u,
            t[8] = m * u + f,
            t[1] = u,
            t[5] = o * h,
            t[9] = -a * h,
            t[2] = -c * h,
            t[6] = f * u + m,
            t[10] = d - _ * u
        } else if (e.order === "XZY") {
            const d = o * l
              , f = o * c
              , m = a * l
              , _ = a * c;
            t[0] = l * h,
            t[4] = -u,
            t[8] = c * h,
            t[1] = d * u + _,
            t[5] = o * h,
            t[9] = f * u - m,
            t[2] = m * u - f,
            t[6] = a * h,
            t[10] = _ * u + d
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(QM, e, eS)
    }
    lookAt(e, t, i) {
        const n = this.elements;
        return Zi.subVectors(e, t),
        Zi.lengthSq() === 0 && (Zi.z = 1),
        Zi.normalize(),
        Ir.crossVectors(i, Zi),
        Ir.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Zi.x += 1e-4 : Zi.z += 1e-4,
        Zi.normalize(),
        Ir.crossVectors(i, Zi)),
        Ir.normalize(),
        Zl.crossVectors(Zi, Ir),
        n[0] = Ir.x,
        n[4] = Zl.x,
        n[8] = Zi.x,
        n[1] = Ir.y,
        n[5] = Zl.y,
        n[9] = Zi.y,
        n[2] = Ir.z,
        n[6] = Zl.z,
        n[10] = Zi.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , n = t.elements
          , r = this.elements
          , o = i[0]
          , a = i[4]
          , l = i[8]
          , c = i[12]
          , h = i[1]
          , u = i[5]
          , d = i[9]
          , f = i[13]
          , m = i[2]
          , _ = i[6]
          , p = i[10]
          , g = i[14]
          , M = i[3]
          , y = i[7]
          , S = i[11]
          , C = i[15]
          , w = n[0]
          , T = n[4]
          , B = n[8]
          , b = n[12]
          , E = n[1]
          , G = n[5]
          , k = n[9]
          , te = n[13]
          , O = n[2]
          , H = n[6]
          , V = n[10]
          , Y = n[14]
          , K = n[3]
          , J = n[7]
          , D = n[11]
          , se = n[15];
        return r[0] = o * w + a * E + l * O + c * K,
        r[4] = o * T + a * G + l * H + c * J,
        r[8] = o * B + a * k + l * V + c * D,
        r[12] = o * b + a * te + l * Y + c * se,
        r[1] = h * w + u * E + d * O + f * K,
        r[5] = h * T + u * G + d * H + f * J,
        r[9] = h * B + u * k + d * V + f * D,
        r[13] = h * b + u * te + d * Y + f * se,
        r[2] = m * w + _ * E + p * O + g * K,
        r[6] = m * T + _ * G + p * H + g * J,
        r[10] = m * B + _ * k + p * V + g * D,
        r[14] = m * b + _ * te + p * Y + g * se,
        r[3] = M * w + y * E + S * O + C * K,
        r[7] = M * T + y * G + S * H + C * J,
        r[11] = M * B + y * k + S * V + C * D,
        r[15] = M * b + y * te + S * Y + C * se,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , n = e[8]
          , r = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , h = e[2]
          , u = e[6]
          , d = e[10]
          , f = e[14]
          , m = e[3]
          , _ = e[7]
          , p = e[11]
          , g = e[15];
        return m * (+r * l * u - n * c * u - r * a * d + i * c * d + n * a * f - i * l * f) + _ * (+t * l * f - t * c * d + r * o * d - n * o * f + n * c * h - r * l * h) + p * (+t * c * u - t * a * f - r * o * u + i * o * f + r * a * h - i * c * h) + g * (-n * a * h - t * l * u + t * a * d + n * o * u - i * o * d + i * l * h)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const n = this.elements;
        return e.isVector3 ? (n[12] = e.x,
        n[13] = e.y,
        n[14] = e.z) : (n[12] = e,
        n[13] = t,
        n[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , n = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8]
          , u = e[9]
          , d = e[10]
          , f = e[11]
          , m = e[12]
          , _ = e[13]
          , p = e[14]
          , g = e[15]
          , M = u * p * c - _ * d * c + _ * l * f - a * p * f - u * l * g + a * d * g
          , y = m * d * c - h * p * c - m * l * f + o * p * f + h * l * g - o * d * g
          , S = h * _ * c - m * u * c + m * a * f - o * _ * f - h * a * g + o * u * g
          , C = m * u * l - h * _ * l - m * a * d + o * _ * d + h * a * p - o * u * p
          , w = t * M + i * y + n * S + r * C;
        if (w === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / w;
        return e[0] = M * T,
        e[1] = (_ * d * r - u * p * r - _ * n * f + i * p * f + u * n * g - i * d * g) * T,
        e[2] = (a * p * r - _ * l * r + _ * n * c - i * p * c - a * n * g + i * l * g) * T,
        e[3] = (u * l * r - a * d * r - u * n * c + i * d * c + a * n * f - i * l * f) * T,
        e[4] = y * T,
        e[5] = (h * p * r - m * d * r + m * n * f - t * p * f - h * n * g + t * d * g) * T,
        e[6] = (m * l * r - o * p * r - m * n * c + t * p * c + o * n * g - t * l * g) * T,
        e[7] = (o * d * r - h * l * r + h * n * c - t * d * c - o * n * f + t * l * f) * T,
        e[8] = S * T,
        e[9] = (m * u * r - h * _ * r - m * i * f + t * _ * f + h * i * g - t * u * g) * T,
        e[10] = (o * _ * r - m * a * r + m * i * c - t * _ * c - o * i * g + t * a * g) * T,
        e[11] = (h * a * r - o * u * r - h * i * c + t * u * c + o * i * f - t * a * f) * T,
        e[12] = C * T,
        e[13] = (h * _ * n - m * u * n + m * i * d - t * _ * d - h * i * p + t * u * p) * T,
        e[14] = (m * a * n - o * _ * n - m * i * l + t * _ * l + o * i * p - t * a * p) * T,
        e[15] = (o * u * n - h * a * n + h * i * l - t * u * l - o * i * d + t * a * d) * T,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , n = e.y
          , r = e.z;
        return t[0] *= i,
        t[4] *= n,
        t[8] *= r,
        t[1] *= i,
        t[5] *= n,
        t[9] *= r,
        t[2] *= i,
        t[6] *= n,
        t[10] *= r,
        t[3] *= i,
        t[7] *= n,
        t[11] *= r,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, n))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , n = Math.sin(t)
          , r = 1 - i
          , o = e.x
          , a = e.y
          , l = e.z
          , c = r * o
          , h = r * a;
        return this.set(c * o + i, c * a - n * l, c * l + n * a, 0, c * a + n * l, h * a + i, h * l - n * o, 0, c * l - n * a, h * l + n * o, r * l * l + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, n, r, o) {
        return this.set(1, i, r, 0, e, 1, o, 0, t, n, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const n = this.elements
          , r = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = r + r
          , h = o + o
          , u = a + a
          , d = r * c
          , f = r * h
          , m = r * u
          , _ = o * h
          , p = o * u
          , g = a * u
          , M = l * c
          , y = l * h
          , S = l * u
          , C = i.x
          , w = i.y
          , T = i.z;
        return n[0] = (1 - (_ + g)) * C,
        n[1] = (f + S) * C,
        n[2] = (m - y) * C,
        n[3] = 0,
        n[4] = (f - S) * w,
        n[5] = (1 - (d + g)) * w,
        n[6] = (p + M) * w,
        n[7] = 0,
        n[8] = (m + y) * T,
        n[9] = (p - M) * T,
        n[10] = (1 - (d + _)) * T,
        n[11] = 0,
        n[12] = e.x,
        n[13] = e.y,
        n[14] = e.z,
        n[15] = 1,
        this
    }
    decompose(e, t, i) {
        const n = this.elements;
        let r = ho.set(n[0], n[1], n[2]).length();
        const o = ho.set(n[4], n[5], n[6]).length()
          , a = ho.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (r = -r),
        e.x = n[12],
        e.y = n[13],
        e.z = n[14],
        En.copy(this);
        const c = 1 / r
          , h = 1 / o
          , u = 1 / a;
        return En.elements[0] *= c,
        En.elements[1] *= c,
        En.elements[2] *= c,
        En.elements[4] *= h,
        En.elements[5] *= h,
        En.elements[6] *= h,
        En.elements[8] *= u,
        En.elements[9] *= u,
        En.elements[10] *= u,
        t.setFromRotationMatrix(En),
        i.x = r,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, n, r, o, a=vr) {
        const l = this.elements
          , c = 2 * r / (t - e)
          , h = 2 * r / (i - n)
          , u = (t + e) / (t - e)
          , d = (i + n) / (i - n);
        let f, m;
        if (a === vr)
            f = -(o + r) / (o - r),
            m = -2 * o * r / (o - r);
        else if (a === wh)
            f = -o / (o - r),
            m = -o * r / (o - r);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c,
        l[4] = 0,
        l[8] = u,
        l[12] = 0,
        l[1] = 0,
        l[5] = h,
        l[9] = d,
        l[13] = 0,
        l[2] = 0,
        l[6] = 0,
        l[10] = f,
        l[14] = m,
        l[3] = 0,
        l[7] = 0,
        l[11] = -1,
        l[15] = 0,
        this
    }
    makeOrthographic(e, t, i, n, r, o, a=vr) {
        const l = this.elements
          , c = 1 / (t - e)
          , h = 1 / (i - n)
          , u = 1 / (o - r)
          , d = (t + e) * c
          , f = (i + n) * h;
        let m, _;
        if (a === vr)
            m = (o + r) * u,
            _ = -2 * u;
        else if (a === wh)
            m = r * u,
            _ = -1 * u;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c,
        l[4] = 0,
        l[8] = 0,
        l[12] = -d,
        l[1] = 0,
        l[5] = 2 * h,
        l[9] = 0,
        l[13] = -f,
        l[2] = 0,
        l[6] = 0,
        l[10] = _,
        l[14] = -m,
        l[3] = 0,
        l[7] = 0,
        l[11] = 0,
        l[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let n = 0; n < 16; n++)
            if (t[n] !== i[n])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
;
const ho = new ne
  , En = new $i
  , QM = new ne(0,0,0)
  , eS = new ne(1,1,1)
  , Ir = new ne
  , Zl = new ne
  , Zi = new ne;
let ya = class {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[e];
        if (n !== void 0) {
            const r = n.indexOf(t);
            r !== -1 && n.splice(r, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const n = i.slice(0);
            for (let r = 0, o = n.length; r < o; r++)
                n[r].call(this, e);
            e.target = null
        }
    }
}
;
const Lm = new $i
  , Im = new Rl;
let lx = class cx {
    constructor(e=0, t=0, i=0, n=cx.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = n
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, n=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = n,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const n = e.elements
          , r = n[0]
          , o = n[4]
          , a = n[8]
          , l = n[1]
          , c = n[5]
          , h = n[9]
          , u = n[2]
          , d = n[6]
          , f = n[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(ki(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, f),
            this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(d, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-ki(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, f),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, r),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(ki(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, f),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, r));
            break;
        case "ZYX":
            this._y = Math.asin(-ki(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, f),
            this._z = Math.atan2(l, r)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(ki(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c),
            this._y = Math.atan2(-u, r)) : (this._x = 0,
            this._y = Math.atan2(a, f));
            break;
        case "XZY":
            this._z = Math.asin(-ki(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c),
            this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, f),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return Lm.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(Lm, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return Im.setFromEuler(this),
        this.setFromQuaternion(Im, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
;
lx.DEFAULT_ORDER = "XYZ";
let hx = class {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
  , mt = class ux {
    constructor(e, t, i, n, r, o, a, l, c) {
        ux.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, n, r, o, a, l, c)
    }
    set(e, t, i, n, r, o, a, l, c) {
        const h = this.elements;
        return h[0] = e,
        h[1] = n,
        h[2] = a,
        h[3] = t,
        h[4] = r,
        h[5] = l,
        h[6] = i,
        h[7] = o,
        h[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , n = t.elements
          , r = this.elements
          , o = i[0]
          , a = i[3]
          , l = i[6]
          , c = i[1]
          , h = i[4]
          , u = i[7]
          , d = i[2]
          , f = i[5]
          , m = i[8]
          , _ = n[0]
          , p = n[3]
          , g = n[6]
          , M = n[1]
          , y = n[4]
          , S = n[7]
          , C = n[2]
          , w = n[5]
          , T = n[8];
        return r[0] = o * _ + a * M + l * C,
        r[3] = o * p + a * y + l * w,
        r[6] = o * g + a * S + l * T,
        r[1] = c * _ + h * M + u * C,
        r[4] = c * p + h * y + u * w,
        r[7] = c * g + h * S + u * T,
        r[2] = d * _ + f * M + m * C,
        r[5] = d * p + f * y + m * w,
        r[8] = d * g + f * S + m * T,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , n = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8];
        return t * o * h - t * a * c - i * r * h + i * a * l + n * r * c - n * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , n = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8]
          , u = h * o - a * c
          , d = a * l - h * r
          , f = c * r - o * l
          , m = t * u + i * d + n * f;
        if (m === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const _ = 1 / m;
        return e[0] = u * _,
        e[1] = (n * c - h * i) * _,
        e[2] = (a * i - n * o) * _,
        e[3] = d * _,
        e[4] = (h * t - n * l) * _,
        e[5] = (n * r - a * t) * _,
        e[6] = f * _,
        e[7] = (i * l - c * t) * _,
        e[8] = (o * t - i * r) * _,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, n, r, o, a) {
        const l = Math.cos(r)
          , c = Math.sin(r);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -n * c, n * l, -n * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(_u.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(_u.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(_u.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let n = 0; n < 9; n++)
            if (t[n] !== i[n])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
;
const _u = new mt;
let tS = 0;
const Dm = new ne
  , uo = new Rl
  , tr = new $i
  , Kl = new ne
  , Aa = new ne
  , iS = new ne
  , nS = new Rl
  , Um = new ne(1,0,0)
  , Nm = new ne(0,1,0)
  , Fm = new ne(0,0,1)
  , rS = {
    type: "added"
}
  , sS = {
    type: "removed"
};
let Ar = class oh extends ya {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: tS++
        }),
        this.uuid = Al(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = oh.DEFAULT_UP.clone();
        const e = new ne
          , t = new lx
          , i = new Rl
          , n = new ne(1,1,1);
        function r() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(r),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new $i
            },
            normalMatrix: {
                value: new mt
            }
        }),
        this.matrix = new $i,
        this.matrixWorld = new $i,
        this.matrixAutoUpdate = oh.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = oh.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new hx,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return uo.setFromAxisAngle(e, t),
        this.quaternion.multiply(uo),
        this
    }
    rotateOnWorldAxis(e, t) {
        return uo.setFromAxisAngle(e, t),
        this.quaternion.premultiply(uo),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(Um, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(Nm, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(Fm, e)
    }
    translateOnAxis(e, t) {
        return Dm.copy(e).applyQuaternion(this.quaternion),
        this.position.add(Dm.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(Um, e)
    }
    translateY(e) {
        return this.translateOnAxis(Nm, e)
    }
    translateZ(e) {
        return this.translateOnAxis(Fm, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(tr.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? Kl.copy(e) : Kl.set(e, t, i);
        const n = this.parent;
        this.updateWorldMatrix(!0, !1),
        Aa.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? tr.lookAt(Aa, Kl, this.up) : tr.lookAt(Kl, Aa, this.up),
        this.quaternion.setFromRotationMatrix(tr),
        n && (tr.extractRotation(n.matrixWorld),
        uo.setFromRotationMatrix(tr),
        this.quaternion.premultiply(uo.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(rS)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(sS)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        tr.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        tr.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(tr),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, i=[]) {
        this[e] === t && i.push(this);
        const n = this.children;
        for (let r = 0, o = n.length; r < o; r++)
            n[r].getObjectsByProperty(e, t, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Aa, e, iS),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Aa, nS, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) {
            const r = t[i];
            (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const n = this.children;
            for (let r = 0, o = n.length; r < o; r++) {
                const a = n[r];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const n = {};
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.castShadow === !0 && (n.castShadow = !0),
        this.receiveShadow === !0 && (n.receiveShadow = !0),
        this.visible === !1 && (n.visible = !1),
        this.frustumCulled === !1 && (n.frustumCulled = !1),
        this.renderOrder !== 0 && (n.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        n.layers = this.layers.mask,
        n.matrix = this.matrix.toArray(),
        n.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1),
        this.isInstancedMesh && (n.type = "InstancedMesh",
        n.count = this.count,
        n.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (n.type = "BatchedMesh",
        n.perObjectFrustumCulled = this.perObjectFrustumCulled,
        n.sortObjects = this.sortObjects,
        n.drawRanges = this._drawRanges,
        n.reservedRanges = this._reservedRanges,
        n.visibility = this._visibility,
        n.active = this._active,
        n.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        n.maxGeometryCount = this._maxGeometryCount,
        n.maxVertexCount = this._maxVertexCount,
        n.maxIndexCount = this._maxIndexCount,
        n.geometryInitialized = this._geometryInitialized,
        n.geometryCount = this._geometryCount,
        n.matricesTexture = this._matricesTexture.toJSON(e),
        this.boundingSphere !== null && (n.boundingSphere = {
            center: n.boundingSphere.center.toArray(),
            radius: n.boundingSphere.radius
        }),
        this.boundingBox !== null && (n.boundingBox = {
            min: n.boundingBox.min.toArray(),
            max: n.boundingBox.max.toArray()
        }));
        function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, h = l.length; c < h; c++) {
                        const u = l[c];
                        r(e.shapes, u)
                    }
                else
                    r(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (n.bindMode = this.bindMode,
        n.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (r(e.skeletons, this.skeleton),
        n.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(r(e.materials, this.material[l]));
                n.material = a
            } else
                n.material = r(e.materials, this.material);
        if (this.children.length > 0) {
            n.children = [];
            for (let a = 0; a < this.children.length; a++)
                n.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            n.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                n.animations.push(r(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , h = o(e.images)
              , u = o(e.shapes)
              , d = o(e.skeletons)
              , f = o(e.animations)
              , m = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            l.length > 0 && (i.materials = l),
            c.length > 0 && (i.textures = c),
            h.length > 0 && (i.images = h),
            u.length > 0 && (i.shapes = u),
            d.length > 0 && (i.skeletons = d),
            f.length > 0 && (i.animations = f),
            m.length > 0 && (i.nodes = m)
        }
        return i.object = n,
        i;
        function o(a) {
            const l = [];
            for (const c in a) {
                const h = a[c];
                delete h.metadata,
                l.push(h)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const n = e.children[i];
                this.add(n.clone())
            }
        return this
    }
}
;
Ar.DEFAULT_UP = new ne(0,1,0);
Ar.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ar.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
class oS extends Ar {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t
    }
}
let Rt = class dx {
    constructor(e=0, t=0) {
        dx.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , n = e.elements;
        return this.x = n[0] * t + n[3] * i + n[6],
        this.y = n[1] * t + n[4] * i + n[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(ki(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , n = Math.sin(t)
          , r = this.x - e.x
          , o = this.y - e.y;
        return this.x = r * i - o * n + e.x,
        this.y = r * n + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
  , Cl = class {
    constructor(e=new ne(1 / 0,1 / 0,1 / 0), t=new ne(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(wn.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(wn.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = wn.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const r = i.getAttribute("position");
            if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = r.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, wn) : wn.fromBufferAttribute(r, o),
                    wn.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(wn);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                Jl.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(),
                Jl.copy(i.boundingBox)),
                Jl.applyMatrix4(e.matrixWorld),
                this.union(Jl)
        }
        const n = e.children;
        for (let r = 0, o = n.length; r < o; r++)
            this.expandByObject(n[r], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, wn),
        wn.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Ra),
        Ql.subVectors(this.max, Ra),
        fo.subVectors(e.a, Ra),
        po.subVectors(e.b, Ra),
        mo.subVectors(e.c, Ra),
        Dr.subVectors(po, fo),
        Ur.subVectors(mo, po),
        _s.subVectors(fo, mo);
        let t = [0, -Dr.z, Dr.y, 0, -Ur.z, Ur.y, 0, -_s.z, _s.y, Dr.z, 0, -Dr.x, Ur.z, 0, -Ur.x, _s.z, 0, -_s.x, -Dr.y, Dr.x, 0, -Ur.y, Ur.x, 0, -_s.y, _s.x, 0];
        return !xu(t, fo, po, mo, Ql) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !xu(t, fo, po, mo, Ql)) ? !1 : (ec.crossVectors(Dr, Ur),
        t = [ec.x, ec.y, ec.z],
        xu(t, fo, po, mo, Ql))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, wn).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(wn).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (ir[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        ir[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        ir[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        ir[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        ir[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        ir[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        ir[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        ir[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(ir),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
;
const ir = [new ne, new ne, new ne, new ne, new ne, new ne, new ne, new ne]
  , wn = new ne
  , Jl = new Cl
  , fo = new ne
  , po = new ne
  , mo = new ne
  , Dr = new ne
  , Ur = new ne
  , _s = new ne
  , Ra = new ne
  , Ql = new ne
  , ec = new ne
  , xs = new ne;
function xu(s, e, t, i, n) {
    for (let r = 0, o = s.length - 3; r <= o; r += 3) {
        xs.fromArray(s, r);
        const a = n.x * Math.abs(xs.x) + n.y * Math.abs(xs.y) + n.z * Math.abs(xs.z)
          , l = e.dot(xs)
          , c = t.dot(xs)
          , h = i.dot(xs);
        if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a)
            return !1
    }
    return !0
}
const Yt = new ne
  , tc = new Rt;
let Zn = class {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = Cm,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = Jr,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let n = 0, r = this.itemSize; n < r; n++)
            this.array[e + n] = t.array[i + n];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                tc.fromBufferAttribute(this, t),
                tc.applyMatrix3(e),
                this.setXY(t, tc.x, tc.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                Yt.fromBufferAttribute(this, t),
                Yt.applyMatrix3(e),
                this.setXYZ(t, Yt.x, Yt.y, Yt.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Yt.fromBufferAttribute(this, t),
            Yt.applyMatrix4(e),
            this.setXYZ(t, Yt.x, Yt.y, Yt.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Yt.fromBufferAttribute(this, t),
            Yt.applyNormalMatrix(e),
            this.setXYZ(t, Yt.x, Yt.y, Yt.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Yt.fromBufferAttribute(this, t),
            Yt.transformDirection(e),
            this.setXYZ(t, Yt.x, Yt.y, Yt.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = wa(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = Bi(i, this.array)),
        this.array[e * this.itemSize + t] = i,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = wa(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = Bi(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = wa(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = Bi(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = wa(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = Bi(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = wa(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = Bi(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = Bi(t, this.array),
        i = Bi(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, n) {
        return e *= this.itemSize,
        this.normalized && (t = Bi(t, this.array),
        i = Bi(i, this.array),
        n = Bi(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = n,
        this
    }
    setXYZW(e, t, i, n, r) {
        return e *= this.itemSize,
        this.normalized && (t = Bi(t, this.array),
        i = Bi(i, this.array),
        n = Bi(n, this.array),
        r = Bi(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = n,
        this.array[e + 3] = r,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Cm && (e.usage = this.usage),
        e
    }
}
  , fx = class extends Zn {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
  , px = class extends Zn {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
  , js = class extends Zn {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
;
const aS = new Cl
  , Ca = new ne
  , yu = new ne;
let Wf = class {
    constructor(e=new ne, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : aS.setFromPoints(e).getCenter(i);
        let n = 0;
        for (let r = 0, o = e.length; r < o; r++)
            n = Math.max(n, i.distanceToSquared(e[r]));
        return this.radius = Math.sqrt(n),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Ca.subVectors(e, this.center);
        const t = Ca.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , n = (i - this.radius) * .5;
            this.center.addScaledVector(Ca, n / i),
            this.radius += n
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (yu.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Ca.copy(e.center).add(yu)),
        this.expandByPoint(Ca.copy(e.center).sub(yu))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
function mx(s) {
    for (let e = s.length - 1; e >= 0; --e)
        if (s[e] >= 65535)
            return !0;
    return !1
}
function vl(s) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", s)
}
function lS() {
    const s = vl("canvas");
    return s.style.display = "block",
    s
}
const Om = {};
function tl(s) {
    s in Om || (Om[s] = !0,
    console.warn(s))
}
let cS = 0;
const un = new $i
  , vu = new Ar
  , go = new ne
  , Ki = new Cl
  , Pa = new Cl
  , ii = new ne;
let Pl = class gx extends ya {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: cS++
        }),
        this.uuid = Al(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (mx(e) ? px : fx)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const r = new mt().getNormalMatrix(e);
            i.applyNormalMatrix(r),
            i.needsUpdate = !0
        }
        const n = this.attributes.tangent;
        return n !== void 0 && (n.transformDirection(e),
        n.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return un.makeRotationFromQuaternion(e),
        this.applyMatrix4(un),
        this
    }
    rotateX(e) {
        return un.makeRotationX(e),
        this.applyMatrix4(un),
        this
    }
    rotateY(e) {
        return un.makeRotationY(e),
        this.applyMatrix4(un),
        this
    }
    rotateZ(e) {
        return un.makeRotationZ(e),
        this.applyMatrix4(un),
        this
    }
    translate(e, t, i) {
        return un.makeTranslation(e, t, i),
        this.applyMatrix4(un),
        this
    }
    scale(e, t, i) {
        return un.makeScale(e, t, i),
        this.applyMatrix4(un),
        this
    }
    lookAt(e) {
        return vu.lookAt(e),
        vu.updateMatrix(),
        this.applyMatrix4(vu.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(go).negate(),
        this.translate(go.x, go.y, go.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, n = e.length; i < n; i++) {
            const r = e[i];
            t.push(r.x, r.y, r.z || 0)
        }
        return this.setAttribute("position", new js(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Cl);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new ne(-1 / 0,-1 / 0,-1 / 0), new ne(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, n = t.length; i < n; i++) {
                    const r = t[i];
                    Ki.setFromBufferAttribute(r),
                    this.morphTargetsRelative ? (ii.addVectors(this.boundingBox.min, Ki.min),
                    this.boundingBox.expandByPoint(ii),
                    ii.addVectors(this.boundingBox.max, Ki.max),
                    this.boundingBox.expandByPoint(ii)) : (this.boundingBox.expandByPoint(Ki.min),
                    this.boundingBox.expandByPoint(Ki.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Wf);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new ne, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Ki.setFromBufferAttribute(e),
            t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r];
                    Pa.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (ii.addVectors(Ki.min, Pa.min),
                    Ki.expandByPoint(ii),
                    ii.addVectors(Ki.max, Pa.max),
                    Ki.expandByPoint(ii)) : (Ki.expandByPoint(Pa.min),
                    Ki.expandByPoint(Pa.max))
                }
            Ki.getCenter(i);
            let n = 0;
            for (let r = 0, o = e.count; r < o; r++)
                ii.fromBufferAttribute(e, r),
                n = Math.max(n, i.distanceToSquared(ii));
            if (t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, h = a.count; c < h; c++)
                        ii.fromBufferAttribute(a, c),
                        l && (go.fromBufferAttribute(e, c),
                        ii.add(go)),
                        n = Math.max(n, i.distanceToSquared(ii))
                }
            this.boundingSphere.radius = Math.sqrt(n),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array
          , n = t.position.array
          , r = t.normal.array
          , o = t.uv.array
          , a = n.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Zn(new Float32Array(4 * a),4));
        const l = this.getAttribute("tangent").array
          , c = []
          , h = [];
        for (let E = 0; E < a; E++)
            c[E] = new ne,
            h[E] = new ne;
        const u = new ne
          , d = new ne
          , f = new ne
          , m = new Rt
          , _ = new Rt
          , p = new Rt
          , g = new ne
          , M = new ne;
        function y(E, G, k) {
            u.fromArray(n, E * 3),
            d.fromArray(n, G * 3),
            f.fromArray(n, k * 3),
            m.fromArray(o, E * 2),
            _.fromArray(o, G * 2),
            p.fromArray(o, k * 2),
            d.sub(u),
            f.sub(u),
            _.sub(m),
            p.sub(m);
            const te = 1 / (_.x * p.y - p.x * _.y);
            isFinite(te) && (g.copy(d).multiplyScalar(p.y).addScaledVector(f, -_.y).multiplyScalar(te),
            M.copy(f).multiplyScalar(_.x).addScaledVector(d, -p.x).multiplyScalar(te),
            c[E].add(g),
            c[G].add(g),
            c[k].add(g),
            h[E].add(M),
            h[G].add(M),
            h[k].add(M))
        }
        let S = this.groups;
        S.length === 0 && (S = [{
            start: 0,
            count: i.length
        }]);
        for (let E = 0, G = S.length; E < G; ++E) {
            const k = S[E]
              , te = k.start
              , O = k.count;
            for (let H = te, V = te + O; H < V; H += 3)
                y(i[H + 0], i[H + 1], i[H + 2])
        }
        const C = new ne
          , w = new ne
          , T = new ne
          , B = new ne;
        function b(E) {
            T.fromArray(r, E * 3),
            B.copy(T);
            const G = c[E];
            C.copy(G),
            C.sub(T.multiplyScalar(T.dot(G))).normalize(),
            w.crossVectors(B, G);
            const te = w.dot(h[E]) < 0 ? -1 : 1;
            l[E * 4] = C.x,
            l[E * 4 + 1] = C.y,
            l[E * 4 + 2] = C.z,
            l[E * 4 + 3] = te
        }
        for (let E = 0, G = S.length; E < G; ++E) {
            const k = S[E]
              , te = k.start
              , O = k.count;
            for (let H = te, V = te + O; H < V; H += 3)
                b(i[H + 0]),
                b(i[H + 1]),
                b(i[H + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new Zn(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let d = 0, f = i.count; d < f; d++)
                    i.setXYZ(d, 0, 0, 0);
            const n = new ne
              , r = new ne
              , o = new ne
              , a = new ne
              , l = new ne
              , c = new ne
              , h = new ne
              , u = new ne;
            if (e)
                for (let d = 0, f = e.count; d < f; d += 3) {
                    const m = e.getX(d + 0)
                      , _ = e.getX(d + 1)
                      , p = e.getX(d + 2);
                    n.fromBufferAttribute(t, m),
                    r.fromBufferAttribute(t, _),
                    o.fromBufferAttribute(t, p),
                    h.subVectors(o, r),
                    u.subVectors(n, r),
                    h.cross(u),
                    a.fromBufferAttribute(i, m),
                    l.fromBufferAttribute(i, _),
                    c.fromBufferAttribute(i, p),
                    a.add(h),
                    l.add(h),
                    c.add(h),
                    i.setXYZ(m, a.x, a.y, a.z),
                    i.setXYZ(_, l.x, l.y, l.z),
                    i.setXYZ(p, c.x, c.y, c.z)
                }
            else
                for (let d = 0, f = t.count; d < f; d += 3)
                    n.fromBufferAttribute(t, d + 0),
                    r.fromBufferAttribute(t, d + 1),
                    o.fromBufferAttribute(t, d + 2),
                    h.subVectors(o, r),
                    u.subVectors(n, r),
                    h.cross(u),
                    i.setXYZ(d + 0, h.x, h.y, h.z),
                    i.setXYZ(d + 1, h.x, h.y, h.z),
                    i.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            ii.fromBufferAttribute(e, t),
            ii.normalize(),
            e.setXYZ(t, ii.x, ii.y, ii.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , h = a.itemSize
              , u = a.normalized
              , d = new c.constructor(l.length * h);
            let f = 0
              , m = 0;
            for (let _ = 0, p = l.length; _ < p; _++) {
                a.isInterleavedBufferAttribute ? f = l[_] * a.data.stride + a.offset : f = l[_] * h;
                for (let g = 0; g < h; g++)
                    d[m++] = c[f++]
            }
            return new Zn(d,h,u)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new gx
          , i = this.index.array
          , n = this.attributes;
        for (const a in n) {
            const l = n[a]
              , c = e(l, i);
            t.setAttribute(a, c)
        }
        const r = this.morphAttributes;
        for (const a in r) {
            const l = []
              , c = r[a];
            for (let h = 0, u = c.length; h < u; h++) {
                const d = c[h]
                  , f = e(d, i);
                l.push(f)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const n = {};
        let r = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , h = [];
            for (let u = 0, d = c.length; u < d; u++) {
                const f = c[u];
                h.push(f.toJSON(e.data))
            }
            h.length > 0 && (n[l] = h,
            r = !0)
        }
        r && (e.data.morphAttributes = n,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const n = e.attributes;
        for (const c in n) {
            const h = n[c];
            this.setAttribute(c, h.clone(t))
        }
        const r = e.morphAttributes;
        for (const c in r) {
            const h = []
              , u = r[c];
            for (let d = 0, f = u.length; d < f; d++)
                h.push(u[d].clone(t));
            this.morphAttributes[c] = h
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
;
class Ll extends Pl {
    constructor(e=1, t=1, i=1, n=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        };
        const r = e / 2
          , o = t / 2
          , a = Math.floor(i)
          , l = Math.floor(n)
          , c = a + 1
          , h = l + 1
          , u = e / a
          , d = t / l
          , f = []
          , m = []
          , _ = []
          , p = [];
        for (let g = 0; g < h; g++) {
            const M = g * d - o;
            for (let y = 0; y < c; y++) {
                const S = y * u - r;
                m.push(S, -M, 0),
                _.push(0, 0, 1),
                p.push(y / a),
                p.push(1 - g / l)
            }
        }
        for (let g = 0; g < l; g++)
            for (let M = 0; M < a; M++) {
                const y = M + c * g
                  , S = M + c * (g + 1)
                  , C = M + 1 + c * (g + 1)
                  , w = M + 1 + c * g;
                f.push(y, S, w),
                f.push(S, C, w)
            }
        this.setIndex(f),
        this.setAttribute("position", new js(m,3)),
        this.setAttribute("normal", new js(_,3)),
        this.setAttribute("uv", new js(p,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ll(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
const Bm = new mt().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , zm = new mt().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , ic = {
    [Er]: {
        transfer: bh,
        primaries: Th,
        toReference: s => s,
        fromReference: s => s
    },
    [ui]: {
        transfer: It,
        primaries: Th,
        toReference: s => s.convertSRGBToLinear(),
        fromReference: s => s.convertLinearToSRGB()
    },
    [Uh]: {
        transfer: bh,
        primaries: Eh,
        toReference: s => s.applyMatrix3(zm),
        fromReference: s => s.applyMatrix3(Bm)
    },
    [Vf]: {
        transfer: It,
        primaries: Eh,
        toReference: s => s.convertSRGBToLinear().applyMatrix3(zm),
        fromReference: s => s.applyMatrix3(Bm).convertLinearToSRGB()
    }
}
  , hS = new Set([Er, Uh])
  , wt = {
    enabled: !0,
    _workingColorSpace: Er,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(s) {
        if (!hS.has(s))
            throw new Error(`Unsupported working color space, "${s}".`);
        this._workingColorSpace = s
    },
    convert: function(s, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return s;
        const i = ic[e].toReference
          , n = ic[t].fromReference;
        return n(i(s))
    },
    fromWorkingColorSpace: function(s, e) {
        return this.convert(s, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(s, e) {
        return this.convert(s, e, this._workingColorSpace)
    },
    getPrimaries: function(s) {
        return ic[s].primaries
    },
    getTransfer: function(s) {
        return s === xn ? bh : ic[s].transfer
    }
};
function na(s) {
    return s < .04045 ? s * .0773993808 : Math.pow(s * .9478672986 + .0521327014, 2.4)
}
function Mu(s) {
    return s < .0031308 ? s * 12.92 : 1.055 * Math.pow(s, .41666) - .055
}
const _x = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Nr = {
    h: 0,
    s: 0,
    l: 0
}
  , nc = {
    h: 0,
    s: 0,
    l: 0
};
function Su(s, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s
}
let At = class {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const n = e;
            n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n)
        } else
            this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=ui) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        wt.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, n=wt.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        wt.toWorkingColorSpace(this, n),
        this
    }
    setHSL(e, t, i, n=wt.workingColorSpace) {
        if (e = Kv(e, 1),
        t = ki(t, 0, 1),
        i = ki(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const r = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - r;
            this.r = Su(o, r, e + 1 / 3),
            this.g = Su(o, r, e),
            this.b = Su(o, r, e - 1 / 3)
        }
        return wt.toWorkingColorSpace(this, n),
        this
    }
    setStyle(e, t=ui) {
        function i(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let n;
        if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let r;
            const o = n[1]
              , a = n[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(r[4]),
                    this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(r[4]),
                    this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(r[4]),
                    this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const r = n[1]
              , o = r.length;
            if (o === 3)
                return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(r, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=ui) {
        const i = _x[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = na(e.r),
        this.g = na(e.g),
        this.b = na(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = Mu(e.r),
        this.g = Mu(e.g),
        this.b = Mu(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=ui) {
        return wt.fromWorkingColorSpace(gi.copy(this), e),
        Math.round(ki(gi.r * 255, 0, 255)) * 65536 + Math.round(ki(gi.g * 255, 0, 255)) * 256 + Math.round(ki(gi.b * 255, 0, 255))
    }
    getHexString(e=ui) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=wt.workingColorSpace) {
        wt.fromWorkingColorSpace(gi.copy(this), t);
        const i = gi.r
          , n = gi.g
          , r = gi.b
          , o = Math.max(i, n, r)
          , a = Math.min(i, n, r);
        let l, c;
        const h = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const u = o - a;
            switch (c = h <= .5 ? u / (o + a) : u / (2 - o - a),
            o) {
            case i:
                l = (n - r) / u + (n < r ? 6 : 0);
                break;
            case n:
                l = (r - i) / u + 2;
                break;
            case r:
                l = (i - n) / u + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = h,
        e
    }
    getRGB(e, t=wt.workingColorSpace) {
        return wt.fromWorkingColorSpace(gi.copy(this), t),
        e.r = gi.r,
        e.g = gi.g,
        e.b = gi.b,
        e
    }
    getStyle(e=ui) {
        wt.fromWorkingColorSpace(gi.copy(this), e);
        const t = gi.r
          , i = gi.g
          , n = gi.b;
        return e !== ui ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Nr),
        this.setHSL(Nr.h + e, Nr.s + t, Nr.l + i)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Nr),
        e.getHSL(nc);
        const i = cu(Nr.h, nc.h, t)
          , n = cu(Nr.s, nc.s, t)
          , r = cu(Nr.l, nc.l, t);
        return this.setHSL(i, n, r),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , i = this.g
          , n = this.b
          , r = e.elements;
        return this.r = r[0] * t + r[3] * i + r[6] * n,
        this.g = r[1] * t + r[4] * i + r[7] * n,
        this.b = r[2] * t + r[5] * i + r[8] * n,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
;
const gi = new At;
At.NAMES = _x;
let uS = 0
  , Nh = class extends ya {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: uS++
        }),
        this.uuid = Al(),
        this.name = "",
        this.type = "Material",
        this.blending = ia,
        this.side = us,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = Zd,
        this.blendDst = Kd,
        this.blendEquation = Is,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new At(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Sh,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = Rm,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = co,
        this.stencilZFail = co,
        this.stencilZPass = co,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const n = this[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== ia && (i.blending = this.blending),
        this.side !== us && (i.side = this.side),
        this.vertexColors === !0 && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = !0),
        this.blendSrc !== Zd && (i.blendSrc = this.blendSrc),
        this.blendDst !== Kd && (i.blendDst = this.blendDst),
        this.blendEquation !== Is && (i.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
        this.depthFunc !== Sh && (i.depthFunc = this.depthFunc),
        this.depthTest === !1 && (i.depthTest = this.depthTest),
        this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== Rm && (i.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== co && (i.stencilFail = this.stencilFail),
        this.stencilZFail !== co && (i.stencilZFail = this.stencilZFail),
        this.stencilZPass !== co && (i.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (i.alphaHash = !0),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (i.forceSinglePass = !0),
        this.wireframe === !0 && (i.wireframe = !0),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = !0),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function n(r) {
            const o = [];
            for (const a in r) {
                const l = r[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const r = n(e.textures)
              , o = n(e.images);
            r.length > 0 && (i.textures = r),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const n = t.length;
            i = new Array(n);
            for (let r = 0; r !== n; ++r)
                i[r] = t[r].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
;
function ma(s) {
    const e = {};
    for (const t in s) {
        e[t] = {};
        for (const i in s[t]) {
            const n = s[t][i];
            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][i] = null) : e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n
        }
    }
    return e
}
function Ai(s) {
    const e = {};
    for (let t = 0; t < s.length; t++) {
        const i = ma(s[t]);
        for (const n in i)
            e[n] = i[n]
    }
    return e
}
function dS(s) {
    const e = [];
    for (let t = 0; t < s.length; t++)
        e.push(s[t].clone());
    return e
}
function xx(s) {
    return s.getRenderTarget() === null ? s.outputColorSpace : wt.workingColorSpace
}
const fS = {
    clone: ma,
    merge: Ai
}
  , pS = `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`
  , mS = `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;
class wr extends Nh {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = pS,
        this.fragmentShader = mS,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
            clipCullDistance: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = ma(e.uniforms),
        this.uniformsGroups = dS(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const n in this.uniforms) {
            const o = this.uniforms[n].value;
            o && o.isTexture ? t.uniforms[n] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[n] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[n] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[n] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[n] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[n] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[n] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[n] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const i = {};
        for (const n in this.extensions)
            this.extensions[n] === !0 && (i[n] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
const nr = new ne
  , bu = new ne
  , rc = new ne
  , Fr = new ne
  , Tu = new ne
  , sc = new ne
  , Eu = new ne;
let gS = class {
    constructor(e=new ne, t=new ne(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, nr)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = nr.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (nr.copy(this.origin).addScaledVector(this.direction, t),
        nr.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, n) {
        bu.copy(e).add(t).multiplyScalar(.5),
        rc.copy(t).sub(e).normalize(),
        Fr.copy(this.origin).sub(bu);
        const r = e.distanceTo(t) * .5
          , o = -this.direction.dot(rc)
          , a = Fr.dot(this.direction)
          , l = -Fr.dot(rc)
          , c = Fr.lengthSq()
          , h = Math.abs(1 - o * o);
        let u, d, f, m;
        if (h > 0)
            if (u = o * l - a,
            d = o * a - l,
            m = r * h,
            u >= 0)
                if (d >= -m)
                    if (d <= m) {
                        const _ = 1 / h;
                        u *= _,
                        d *= _,
                        f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c
                    } else
                        d = r,
                        u = Math.max(0, -(o * d + a)),
                        f = -u * u + d * (d + 2 * l) + c;
                else
                    d = -r,
                    u = Math.max(0, -(o * d + a)),
                    f = -u * u + d * (d + 2 * l) + c;
            else
                d <= -m ? (u = Math.max(0, -(-o * r + a)),
                d = u > 0 ? -r : Math.min(Math.max(-r, -l), r),
                f = -u * u + d * (d + 2 * l) + c) : d <= m ? (u = 0,
                d = Math.min(Math.max(-r, -l), r),
                f = d * (d + 2 * l) + c) : (u = Math.max(0, -(o * r + a)),
                d = u > 0 ? r : Math.min(Math.max(-r, -l), r),
                f = -u * u + d * (d + 2 * l) + c);
        else
            d = o > 0 ? -r : r,
            u = Math.max(0, -(o * d + a)),
            f = -u * u + d * (d + 2 * l) + c;
        return i && i.copy(this.origin).addScaledVector(this.direction, u),
        n && n.copy(bu).addScaledVector(rc, d),
        f
    }
    intersectSphere(e, t) {
        nr.subVectors(e.center, this.origin);
        const i = nr.dot(this.direction)
          , n = nr.dot(nr) - i * i
          , r = e.radius * e.radius;
        if (n > r)
            return null;
        const o = Math.sqrt(r - n)
          , a = i - o
          , l = i + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, n, r, o, a, l;
        const c = 1 / this.direction.x
          , h = 1 / this.direction.y
          , u = 1 / this.direction.z
          , d = this.origin;
        return c >= 0 ? (i = (e.min.x - d.x) * c,
        n = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c,
        n = (e.min.x - d.x) * c),
        h >= 0 ? (r = (e.min.y - d.y) * h,
        o = (e.max.y - d.y) * h) : (r = (e.max.y - d.y) * h,
        o = (e.min.y - d.y) * h),
        i > o || r > n || ((r > i || isNaN(i)) && (i = r),
        (o < n || isNaN(n)) && (n = o),
        u >= 0 ? (a = (e.min.z - d.z) * u,
        l = (e.max.z - d.z) * u) : (a = (e.max.z - d.z) * u,
        l = (e.min.z - d.z) * u),
        i > l || a > n) || ((a > i || i !== i) && (i = a),
        (l < n || n !== n) && (n = l),
        n < 0) ? null : this.at(i >= 0 ? i : n, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, nr) !== null
    }
    intersectTriangle(e, t, i, n, r) {
        Tu.subVectors(t, e),
        sc.subVectors(i, e),
        Eu.crossVectors(Tu, sc);
        let o = this.direction.dot(Eu), a;
        if (o > 0) {
            if (n)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        Fr.subVectors(this.origin, e);
        const l = a * this.direction.dot(sc.crossVectors(Fr, sc));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(Tu.cross(Fr));
        if (c < 0 || l + c > o)
            return null;
        const h = -a * Fr.dot(Eu);
        return h < 0 ? null : this.at(h / o, r)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
const An = new ne
  , rr = new ne
  , wu = new ne
  , sr = new ne
  , _o = new ne
  , xo = new ne
  , km = new ne
  , Au = new ne
  , Ru = new ne
  , Cu = new ne;
let oc = !1
  , ac = class Cs {
    constructor(e=new ne, t=new ne, i=new ne) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, n) {
        n.subVectors(i, t),
        An.subVectors(e, t),
        n.cross(An);
        const r = n.lengthSq();
        return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, n, r) {
        An.subVectors(n, t),
        rr.subVectors(i, t),
        wu.subVectors(e, t);
        const o = An.dot(An)
          , a = An.dot(rr)
          , l = An.dot(wu)
          , c = rr.dot(rr)
          , h = rr.dot(wu)
          , u = o * c - a * a;
        if (u === 0)
            return r.set(0, 0, 0),
            null;
        const d = 1 / u
          , f = (c * l - a * h) * d
          , m = (o * h - a * l) * d;
        return r.set(1 - f - m, m, f)
    }
    static containsPoint(e, t, i, n) {
        return this.getBarycoord(e, t, i, n, sr) === null ? !1 : sr.x >= 0 && sr.y >= 0 && sr.x + sr.y <= 1
    }
    static getUV(e, t, i, n, r, o, a, l) {
        return oc === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        oc = !0),
        this.getInterpolation(e, t, i, n, r, o, a, l)
    }
    static getInterpolation(e, t, i, n, r, o, a, l) {
        return this.getBarycoord(e, t, i, n, sr) === null ? (l.x = 0,
        l.y = 0,
        "z"in l && (l.z = 0),
        "w"in l && (l.w = 0),
        null) : (l.setScalar(0),
        l.addScaledVector(r, sr.x),
        l.addScaledVector(o, sr.y),
        l.addScaledVector(a, sr.z),
        l)
    }
    static isFrontFacing(e, t, i, n) {
        return An.subVectors(i, t),
        rr.subVectors(e, t),
        An.cross(rr).dot(n) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, n) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[n]),
        this
    }
    setFromAttributeAndIndices(e, t, i, n) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, n),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return An.subVectors(this.c, this.b),
        rr.subVectors(this.a, this.b),
        An.cross(rr).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Cs.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Cs.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, n, r) {
        return oc === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        oc = !0),
        Cs.getInterpolation(e, this.a, this.b, this.c, t, i, n, r)
    }
    getInterpolation(e, t, i, n, r) {
        return Cs.getInterpolation(e, this.a, this.b, this.c, t, i, n, r)
    }
    containsPoint(e) {
        return Cs.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Cs.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , n = this.b
          , r = this.c;
        let o, a;
        _o.subVectors(n, i),
        xo.subVectors(r, i),
        Au.subVectors(e, i);
        const l = _o.dot(Au)
          , c = xo.dot(Au);
        if (l <= 0 && c <= 0)
            return t.copy(i);
        Ru.subVectors(e, n);
        const h = _o.dot(Ru)
          , u = xo.dot(Ru);
        if (h >= 0 && u <= h)
            return t.copy(n);
        const d = l * u - h * c;
        if (d <= 0 && l >= 0 && h <= 0)
            return o = l / (l - h),
            t.copy(i).addScaledVector(_o, o);
        Cu.subVectors(e, r);
        const f = _o.dot(Cu)
          , m = xo.dot(Cu);
        if (m >= 0 && f <= m)
            return t.copy(r);
        const _ = f * c - l * m;
        if (_ <= 0 && c >= 0 && m <= 0)
            return a = c / (c - m),
            t.copy(i).addScaledVector(xo, a);
        const p = h * m - f * u;
        if (p <= 0 && u - h >= 0 && f - m >= 0)
            return km.subVectors(r, n),
            a = (u - h) / (u - h + (f - m)),
            t.copy(n).addScaledVector(km, a);
        const g = 1 / (p + _ + d);
        return o = _ * g,
        a = d * g,
        t.copy(i).addScaledVector(_o, o).addScaledVector(xo, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
  , yx = class extends Nh {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new At(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = K0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
;
const Hm = new $i
  , ys = new gS
  , lc = new Wf
  , Gm = new ne
  , yo = new ne
  , vo = new ne
  , Mo = new ne
  , Pu = new ne
  , cc = new ne
  , hc = new Rt
  , uc = new Rt
  , dc = new Rt
  , Vm = new ne
  , Wm = new ne
  , Xm = new ne
  , fc = new ne
  , pc = new ne;
let Yn = class extends Ar {
    constructor(e=new Pl, t=new yx) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, o = n.length; r < o; r++) {
                    const a = n[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , n = i.attributes.position
          , r = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(n, e);
        const a = this.morphTargetInfluences;
        if (r && a) {
            cc.set(0, 0, 0);
            for (let l = 0, c = r.length; l < c; l++) {
                const h = a[l]
                  , u = r[l];
                h !== 0 && (Pu.fromBufferAttribute(u, e),
                o ? cc.addScaledVector(Pu, h) : cc.addScaledVector(Pu.sub(t), h))
            }
            t.add(cc)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry
          , n = this.material
          , r = this.matrixWorld;
        n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        lc.copy(i.boundingSphere),
        lc.applyMatrix4(r),
        ys.copy(e.ray).recast(e.near),
        !(lc.containsPoint(ys.origin) === !1 && (ys.intersectSphere(lc, Gm) === null || ys.origin.distanceToSquared(Gm) > (e.far - e.near) ** 2)) && (Hm.copy(r).invert(),
        ys.copy(e.ray).applyMatrix4(Hm),
        !(i.boundingBox !== null && ys.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, ys)))
    }
    _computeIntersections(e, t, i) {
        let n;
        const r = this.geometry
          , o = this.material
          , a = r.index
          , l = r.attributes.position
          , c = r.attributes.uv
          , h = r.attributes.uv1
          , u = r.attributes.normal
          , d = r.groups
          , f = r.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let m = 0, _ = d.length; m < _; m++) {
                    const p = d[m]
                      , g = o[p.materialIndex]
                      , M = Math.max(p.start, f.start)
                      , y = Math.min(a.count, Math.min(p.start + p.count, f.start + f.count));
                    for (let S = M, C = y; S < C; S += 3) {
                        const w = a.getX(S)
                          , T = a.getX(S + 1)
                          , B = a.getX(S + 2);
                        n = mc(this, g, e, i, c, h, u, w, T, B),
                        n && (n.faceIndex = Math.floor(S / 3),
                        n.face.materialIndex = p.materialIndex,
                        t.push(n))
                    }
                }
            else {
                const m = Math.max(0, f.start)
                  , _ = Math.min(a.count, f.start + f.count);
                for (let p = m, g = _; p < g; p += 3) {
                    const M = a.getX(p)
                      , y = a.getX(p + 1)
                      , S = a.getX(p + 2);
                    n = mc(this, o, e, i, c, h, u, M, y, S),
                    n && (n.faceIndex = Math.floor(p / 3),
                    t.push(n))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let m = 0, _ = d.length; m < _; m++) {
                    const p = d[m]
                      , g = o[p.materialIndex]
                      , M = Math.max(p.start, f.start)
                      , y = Math.min(l.count, Math.min(p.start + p.count, f.start + f.count));
                    for (let S = M, C = y; S < C; S += 3) {
                        const w = S
                          , T = S + 1
                          , B = S + 2;
                        n = mc(this, g, e, i, c, h, u, w, T, B),
                        n && (n.faceIndex = Math.floor(S / 3),
                        n.face.materialIndex = p.materialIndex,
                        t.push(n))
                    }
                }
            else {
                const m = Math.max(0, f.start)
                  , _ = Math.min(l.count, f.start + f.count);
                for (let p = m, g = _; p < g; p += 3) {
                    const M = p
                      , y = p + 1
                      , S = p + 2;
                    n = mc(this, o, e, i, c, h, u, M, y, S),
                    n && (n.faceIndex = Math.floor(p / 3),
                    t.push(n))
                }
            }
    }
}
;
function _S(s, e, t, i, n, r, o, a) {
    let l;
    if (e.side === Yi ? l = i.intersectTriangle(o, r, n, !0, a) : l = i.intersectTriangle(n, r, o, e.side === us, a),
    l === null)
        return null;
    pc.copy(a),
    pc.applyMatrix4(s.matrixWorld);
    const c = t.ray.origin.distanceTo(pc);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: pc.clone(),
        object: s
    }
}
function mc(s, e, t, i, n, r, o, a, l, c) {
    s.getVertexPosition(a, yo),
    s.getVertexPosition(l, vo),
    s.getVertexPosition(c, Mo);
    const h = _S(s, e, t, i, yo, vo, Mo, fc);
    if (h) {
        n && (hc.fromBufferAttribute(n, a),
        uc.fromBufferAttribute(n, l),
        dc.fromBufferAttribute(n, c),
        h.uv = ac.getInterpolation(fc, yo, vo, Mo, hc, uc, dc, new Rt)),
        r && (hc.fromBufferAttribute(r, a),
        uc.fromBufferAttribute(r, l),
        dc.fromBufferAttribute(r, c),
        h.uv1 = ac.getInterpolation(fc, yo, vo, Mo, hc, uc, dc, new Rt),
        h.uv2 = h.uv1),
        o && (Vm.fromBufferAttribute(o, a),
        Wm.fromBufferAttribute(o, l),
        Xm.fromBufferAttribute(o, c),
        h.normal = ac.getInterpolation(fc, yo, vo, Mo, Vm, Wm, Xm, new ne),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
        const u = {
            a,
            b: l,
            c,
            normal: new ne,
            materialIndex: 0
        };
        ac.getNormal(yo, vo, Mo, u.normal),
        h.face = u
    }
    return h
}
const vx = `varying vec2 vUv;

void main() {
  vUv = uv;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`
  , xS = `precision mediump float;

#define PI 3.14159265359

struct TextureData {
  sampler2D texture;
  float aspect;
};

uniform vec2 uResolution;
uniform float uTime;
uniform TextureData uImage;
uniform sampler2D uBlockNoiseTexture;
uniform float uShake;
uniform float uIconVisible;
uniform float uPaused;
uniform float uDpr;

varying vec2 vUv;

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float random(vec2 c){
  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);

  // Four corners in 2D of a tile
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  // Smooth Interpolation

  // Cubic Hermine Curve.  Same as SmoothStep()
  vec2 u = f*f*(3.0-2.0*f);
  // u = smoothstep(0.,1.,f);

  // Mix 4 coorners percentages
  return mix(a, b, u.x) +
          (c - a)* u.y * (1.0 - u.x) +
          (d - b) * u.x * u.y;
}

// uv
vec2 normalizeUv(vec2 uv, float aspect) {
  vec2 uvScale = vec2(min(aspect, 1.0), min(1.0 / aspect, 1.0));
  return (uv - 0.5) * uvScale + 0.5;
}

float circle(vec2 uv, vec2 pos, float r, float edge) {
  return 1.0 - smoothstep(r - edge * 0.5, r + edge * 0.5, length(uv - pos));
}

float rectangle(vec2 uv, vec2 pos, vec2 size, float edge) {
  vec2 rect =
  smoothstep(pos - size * 0.5 - edge * 0.5, pos - size * 0.5 + edge * 0.5, uv) * 
  smoothstep(pos + size * 0.5 + edge * 0.5, pos + size * 0.5 - edge * 0.5, uv);

   return rect.x * rect.y;
}

float triangle(vec2 uv, float size, float rotate, float edge) {
  vec2 uuv = uv * 2.0 - 1.0;
  float angle = atan(uuv.x, uuv.y) + PI * rotate;
  float radius = 2.0 * PI / 3.0; // 3.0
  float dist = cos(floor(0.5 + angle / radius) * radius - angle) * length(uuv);

  return 1.0 - smoothstep(size - edge * 0.5, size + edge * 0.5, dist);
}

void main() {
  float aspect = uResolution.x / uResolution.y;
    
  // uvRGB
  vec2 uvR = vUv;
  vec2 uvG = vUv;
  vec2 uvB = vUv;

  // xRGB
  float shiftOffset = 0.003;
  uvR.x = uvR.x + shiftOffset;
  uvG.x = uvG.x - shiftOffset;
  uvB.x = uvB.x - shiftOffset;


  // Glitch
  vec3 blockColor = texture2D(uBlockNoiseTexture, vUv).rgb;
  float blockMask = length(blockColor);
  float blockFlag = step(noise(vec2(uTime)), 0.5); // noise
  float blockActive = blockMask * blockFlag;
  float blockShiftOffsetX = 0.1 * blockActive;
  float blockShiftOffsetY = 0.002 * blockActive;
  // R,Gx,y
  uvR.x += (blockColor.r - 0.5) * blockShiftOffsetX;
  uvR.y += (blockColor.g - 0.5) * blockShiftOffsetY;

  uvG.x += (blockColor.r - 0.5) * blockShiftOffsetX;
  uvG.y += (blockColor.g - 0.5) * blockShiftOffsetY;

  uvB.x += (blockColor.r - 0.5) * blockShiftOffsetX;
  uvB.y += (blockColor.g - 0.5) * blockShiftOffsetY;
  

  // 
  float hBlockSpeed = 0.5;
  float hBlockInterval = 5.0;
  float hBlockY = mod(-uTime, hBlockInterval) * hBlockSpeed; // 
  float hBlockHeight = 0.01;
  float hBlockStart = step(hBlockY - hBlockHeight * 0.5, vUv.y);
  float hBlockEnd = step(vUv.y, hBlockY + hBlockHeight * 0.5);
  float hBlockMask = hBlockStart * hBlockEnd;

  uvR.x -= 0.01 * hBlockMask;
  uvG.x -= 0.01 * hBlockMask;
  uvB.x -= 0.01 * hBlockMask;


  // 
  float shake = (noise(vec2(vUv.y) * sin(uTime * 400.0) * 100.0) - 0.5) * uShake;
  uvR.x += shake;
  uvG.x += shake;
  uvB.x += shake;


  // UV
  float r = texture2D(uImage.texture, uvR).r;
  float g = texture2D(uImage.texture, uvG).g;
  float b = texture2D(uImage.texture, uvB).b;

  vec3 color = vec3(r, g, b);

  // 
  vec2 iconUv = normalizeUv(uvR, uImage.aspect);
  // 
  float iconEdge = 0.005;
  float iconRingRadius = 0.1;
  float iconRingStroke = 0.01;
  float iconRingOuter = circle(iconUv, vec2(0.5), iconRingRadius, iconEdge);
  float iconRingInner = 1.0 - circle(iconUv, vec2(0.5), iconRingRadius - iconRingStroke, iconEdge);
  float iconRing = iconRingOuter * iconRingInner;
  // pause rect
  vec2 iconRectSize = vec2(0.02, 0.08);
  float iconRectLeft = rectangle(iconUv, vec2(0.5 - 0.02, 0.5), iconRectSize, iconEdge);
  float iconRectRight = rectangle(iconUv, vec2(0.5 + 0.02, 0.5), iconRectSize, iconEdge);
  float iconPause = iconRectLeft + iconRectRight;
  // play triangle
  // https://thndl.com/square-shaped-shaders.html
  // https://thebookofshaders.com/07/?lan=jp
  float iconTriSize = 0.05;
  float iconPlay = triangle(iconUv, iconTriSize, 0.5, iconEdge * 2.0); // edge

  float iconMark = mix(iconPause, iconPlay, uPaused);
  float icon = iconRing + iconMark;
  color = mix(color, vec3(1.0), icon * uIconVisible);


  // uv
  // grain effect
  vec2 grainedUv = vUv + noise(vUv * 400.0);
  float grainSpeed = 20.0;
  float grain = noise(grainedUv + uTime * random(grainedUv) * grainSpeed);
  float grainPower = 0.2 * uDpr; // 
  color += grain * grainPower;
  color -= grainPower * 0.5; // grain

  // halftone(line) effect
  float lines = sin(vUv.y * 800.0); // sin
  lines = map(lines, -1.0, 1.0, 0.7, 1.0); // -1.0 ~ 1.0
  color = color * lines;
  color += lines * 0.15; // 

  gl_FragColor = vec4(color, 1.0);
}`
  , qm = {
    enabled: !1,
    files: {},
    add: function(s, e) {
        this.enabled !== !1 && (this.files[s] = e)
    },
    get: function(s) {
        if (this.enabled !== !1)
            return this.files[s]
    },
    remove: function(s) {
        delete this.files[s]
    },
    clear: function() {
        this.files = {}
    }
};
let yS = class {
    constructor(e, t, i) {
        const n = this;
        let r = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(h) {
            a++,
            r === !1 && n.onStart !== void 0 && n.onStart(h, o, a),
            r = !0
        }
        ,
        this.itemEnd = function(h) {
            o++,
            n.onProgress !== void 0 && n.onProgress(h, o, a),
            o === a && (r = !1,
            n.onLoad !== void 0 && n.onLoad())
        }
        ,
        this.itemError = function(h) {
            n.onError !== void 0 && n.onError(h)
        }
        ,
        this.resolveURL = function(h) {
            return l ? l(h) : h
        }
        ,
        this.setURLModifier = function(h) {
            return l = h,
            this
        }
        ,
        this.addHandler = function(h, u) {
            return c.push(h, u),
            this
        }
        ,
        this.removeHandler = function(h) {
            const u = c.indexOf(h);
            return u !== -1 && c.splice(u, 2),
            this
        }
        ,
        this.getHandler = function(h) {
            for (let u = 0, d = c.length; u < d; u += 2) {
                const f = c[u]
                  , m = c[u + 1];
                if (f.global && (f.lastIndex = 0),
                f.test(h))
                    return m
            }
            return null
        }
    }
}
;
const vS = new yS;
let Xf = class {
    constructor(e) {
        this.manager = e !== void 0 ? e : vS,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(n, r) {
            i.load(e, n, t, r)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
;
Xf.DEFAULT_MATERIAL_NAME = "__DEFAULT";
let MS = class extends Xf {
    constructor(e) {
        super(e)
    }
    load(e, t, i, n) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , o = qm.get(e);
        if (o !== void 0)
            return r.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                r.manager.itemEnd(e)
            }, 0),
            o;
        const a = vl("img");
        function l() {
            h(),
            qm.add(e, this),
            t && t(this),
            r.manager.itemEnd(e)
        }
        function c(u) {
            h(),
            n && n(u),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
        function h() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        r.manager.itemStart(e),
        a.src = e,
        a
    }
}
, So, Mx = class {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            So === void 0 && (So = vl("canvas")),
            So.width = e.width,
            So.height = e.height;
            const i = So.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = So
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = vl("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const n = i.getImageData(0, 0, e.width, e.height)
              , r = n.data;
            for (let o = 0; o < r.length; o++)
                r[o] = na(r[o] / 255) * 255;
            return i.putImageData(n, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(na(t[i] / 255) * 255) : t[i] = na(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
, SS = 0, Sx = class {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: SS++
        }),
        this.uuid = Al(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , n = this.data;
        if (n !== null) {
            let r;
            if (Array.isArray(n)) {
                r = [];
                for (let o = 0, a = n.length; o < a; o++)
                    n[o].isDataTexture ? r.push(Lu(n[o].image)) : r.push(Lu(n[o]))
            } else
                r = Lu(n);
            i.url = r
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
;
function Lu(s) {
    return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Mx.getDataURL(s) : s.data ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let bS = 0
  , zn = class ah extends ya {
    constructor(e=ah.DEFAULT_IMAGE, t=ah.DEFAULT_MAPPING, i=Fn, n=Fn, r=Hi, o=xl, a=On, l=os, c=ah.DEFAULT_ANISOTROPY, h=xn) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: bS++
        }),
        this.uuid = Al(),
        this.name = "",
        this.source = new Sx(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = n,
        this.magFilter = r,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new Rt(0,0),
        this.repeat = new Rt(1,1),
        this.center = new Rt(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new mt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        typeof h == "string" ? this.colorSpace = h : (tl("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = h === $s ? ui : xn),
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== J0)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case ef:
                e.x = e.x - Math.floor(e.x);
                break;
            case Fn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case tf:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case ef:
                e.y = e.y - Math.floor(e.y);
                break;
            case Fn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case tf:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    get encoding() {
        return tl("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace === ui ? $s : ox
    }
    set encoding(e) {
        tl("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = e === $s ? ui : xn
    }
}
;
zn.DEFAULT_IMAGE = null;
zn.DEFAULT_MAPPING = J0;
zn.DEFAULT_ANISOTROPY = 1;
let TS = class extends Xf {
    constructor(e) {
        super(e)
    }
    load(e, t, i, n) {
        const r = new zn
          , o = new MS(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            r.image = a,
            r.needsUpdate = !0,
            t !== void 0 && t(r)
        }, i, n),
        r
    }
}
;
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const bx = "160"
  , Ah = 0
  , ES = 1
  , wS = 2
  , Ym = 1
  , $m = 100
  , jm = 204
  , Zm = 205
  , Km = 3
  , AS = 0
  , Jm = "attached"
  , RS = "detached"
  , Tx = 300
  , Ml = 1e3
  , Fs = 1001
  , sf = 1002
  , Sl = 1003
  , CS = 1004
  , PS = 1005
  , as = 1006
  , LS = 1007
  , Fh = 1008
  , IS = 1009
  , DS = 1014
  , il = 1015
  , gc = 1016
  , US = 1020
  , qf = 1023
  , Iu = 1026
  , Qm = 1027
  , NS = 1028
  , bl = 2300
  , ga = 2301
  , Du = 2302
  , eg = 2400
  , tg = 2401
  , ig = 2402
  , FS = 2500
  , OS = 0
  , Ex = 1
  , of = 2
  , BS = 3e3
  , Uu = 3001
  , zS = 0
  , nl = ""
  , ai = "srgb"
  , Oi = "srgb-linear"
  , kS = "display-p3"
  , wx = "display-p3-linear"
  , af = "linear"
  , ng = "srgb"
  , rg = "rec709"
  , sg = "p3"
  , bo = 7680
  , og = 519
  , HS = 515
  , lf = 35044
  , Os = 2e3
  , cf = 2001;
class Oh {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[e];
        if (n !== void 0) {
            const r = n.indexOf(t);
            r !== -1 && n.splice(r, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const n = i.slice(0);
            for (let r = 0, o = n.length; r < o; r++)
                n[r].call(this, e);
            e.target = null
        }
    }
}
const _i = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let ag = 1234567;
const rl = Math.PI / 180
  , Tl = 180 / Math.PI;
function Bn() {
    const s = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (_i[s & 255] + _i[s >> 8 & 255] + _i[s >> 16 & 255] + _i[s >> 24 & 255] + "-" + _i[e & 255] + _i[e >> 8 & 255] + "-" + _i[e >> 16 & 15 | 64] + _i[e >> 24 & 255] + "-" + _i[t & 63 | 128] + _i[t >> 8 & 255] + "-" + _i[t >> 16 & 255] + _i[t >> 24 & 255] + _i[i & 255] + _i[i >> 8 & 255] + _i[i >> 16 & 255] + _i[i >> 24 & 255]).toLowerCase()
}
function di(s, e, t) {
    return Math.max(e, Math.min(t, s))
}
function Yf(s, e) {
    return (s % e + e) % e
}
function GS(s, e, t, i, n) {
    return i + (s - e) * (n - i) / (t - e)
}
function VS(s, e, t) {
    return s !== e ? (t - s) / (e - s) : 0
}
function sl(s, e, t) {
    return (1 - t) * s + t * e
}
function WS(s, e, t, i) {
    return sl(s, e, 1 - Math.exp(-t * i))
}
function XS(s, e=1) {
    return e - Math.abs(Yf(s, e * 2) - e)
}
function qS(s, e, t) {
    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e),
    s * s * (3 - 2 * s))
}
function YS(s, e, t) {
    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e),
    s * s * s * (s * (s * 6 - 15) + 10))
}
function $S(s, e) {
    return s + Math.floor(Math.random() * (e - s + 1))
}
function jS(s, e) {
    return s + Math.random() * (e - s)
}
function ZS(s) {
    return s * (.5 - Math.random())
}
function KS(s) {
    s !== void 0 && (ag = s);
    let e = ag += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function JS(s) {
    return s * rl
}
function QS(s) {
    return s * Tl
}
function eb(s) {
    return (s & s - 1) === 0 && s !== 0
}
function tb(s) {
    return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2))
}
function ib(s) {
    return Math.pow(2, Math.floor(Math.log(s) / Math.LN2))
}
function nb(s, e, t, i, n) {
    const r = Math.cos
      , o = Math.sin
      , a = r(t / 2)
      , l = o(t / 2)
      , c = r((e + i) / 2)
      , h = o((e + i) / 2)
      , u = r((e - i) / 2)
      , d = o((e - i) / 2)
      , f = r((i - e) / 2)
      , m = o((i - e) / 2);
    switch (n) {
    case "XYX":
        s.set(a * h, l * u, l * d, a * c);
        break;
    case "YZY":
        s.set(l * d, a * h, l * u, a * c);
        break;
    case "ZXZ":
        s.set(l * u, l * d, a * h, a * c);
        break;
    case "XZX":
        s.set(a * h, l * m, l * f, a * c);
        break;
    case "YXY":
        s.set(l * f, a * h, l * m, a * c);
        break;
    case "ZYZ":
        s.set(l * m, l * f, a * h, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n)
    }
}
function Wn(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return s / 4294967295;
    case Uint16Array:
        return s / 65535;
    case Uint8Array:
        return s / 255;
    case Int32Array:
        return Math.max(s / 2147483647, -1);
    case Int16Array:
        return Math.max(s / 32767, -1);
    case Int8Array:
        return Math.max(s / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Et(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return Math.round(s * 4294967295);
    case Uint16Array:
        return Math.round(s * 65535);
    case Uint8Array:
        return Math.round(s * 255);
    case Int32Array:
        return Math.round(s * 2147483647);
    case Int16Array:
        return Math.round(s * 32767);
    case Int8Array:
        return Math.round(s * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const rb = {
    DEG2RAD: rl,
    RAD2DEG: Tl,
    generateUUID: Bn,
    clamp: di,
    euclideanModulo: Yf,
    mapLinear: GS,
    inverseLerp: VS,
    lerp: sl,
    damp: WS,
    pingpong: XS,
    smoothstep: qS,
    smootherstep: YS,
    randInt: $S,
    randFloat: jS,
    randFloatSpread: ZS,
    seededRandom: KS,
    degToRad: JS,
    radToDeg: QS,
    isPowerOfTwo: eb,
    ceilPowerOfTwo: tb,
    floorPowerOfTwo: ib,
    setQuaternionFromProperEuler: nb,
    normalize: Et,
    denormalize: Wn
};
class Xt {
    constructor(e=0, t=0) {
        Xt.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , n = e.elements;
        return this.x = n[0] * t + n[3] * i + n[6],
        this.y = n[1] * t + n[4] * i + n[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(di(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , n = Math.sin(t)
          , r = this.x - e.x
          , o = this.y - e.y;
        return this.x = r * i - o * n + e.x,
        this.y = r * n + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Rr {
    constructor(e, t, i, n, r, o, a, l, c) {
        Rr.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, n, r, o, a, l, c)
    }
    set(e, t, i, n, r, o, a, l, c) {
        const h = this.elements;
        return h[0] = e,
        h[1] = n,
        h[2] = a,
        h[3] = t,
        h[4] = r,
        h[5] = l,
        h[6] = i,
        h[7] = o,
        h[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , n = t.elements
          , r = this.elements
          , o = i[0]
          , a = i[3]
          , l = i[6]
          , c = i[1]
          , h = i[4]
          , u = i[7]
          , d = i[2]
          , f = i[5]
          , m = i[8]
          , _ = n[0]
          , p = n[3]
          , g = n[6]
          , M = n[1]
          , y = n[4]
          , S = n[7]
          , C = n[2]
          , w = n[5]
          , T = n[8];
        return r[0] = o * _ + a * M + l * C,
        r[3] = o * p + a * y + l * w,
        r[6] = o * g + a * S + l * T,
        r[1] = c * _ + h * M + u * C,
        r[4] = c * p + h * y + u * w,
        r[7] = c * g + h * S + u * T,
        r[2] = d * _ + f * M + m * C,
        r[5] = d * p + f * y + m * w,
        r[8] = d * g + f * S + m * T,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , n = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8];
        return t * o * h - t * a * c - i * r * h + i * a * l + n * r * c - n * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , n = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8]
          , u = h * o - a * c
          , d = a * l - h * r
          , f = c * r - o * l
          , m = t * u + i * d + n * f;
        if (m === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const _ = 1 / m;
        return e[0] = u * _,
        e[1] = (n * c - h * i) * _,
        e[2] = (a * i - n * o) * _,
        e[3] = d * _,
        e[4] = (h * t - n * l) * _,
        e[5] = (n * r - a * t) * _,
        e[6] = f * _,
        e[7] = (i * l - c * t) * _,
        e[8] = (o * t - i * r) * _,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, n, r, o, a) {
        const l = Math.cos(r)
          , c = Math.sin(r);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -n * c, n * l, -n * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(Nu.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(Nu.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(Nu.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let n = 0; n < 9; n++)
            if (t[n] !== i[n])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const Nu = new Rr;
function sb(s) {
    for (let e = s.length - 1; e >= 0; --e)
        if (s[e] >= 65535)
            return !0;
    return !1
}
function hf(s) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", s)
}
const lg = {};
function Fu(s) {
    s in lg || (lg[s] = !0,
    console.warn(s))
}
const cg = new Rr().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , hg = new Rr().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , _c = {
    [Oi]: {
        transfer: af,
        primaries: rg,
        toReference: s => s,
        fromReference: s => s
    },
    [ai]: {
        transfer: ng,
        primaries: rg,
        toReference: s => s.convertSRGBToLinear(),
        fromReference: s => s.convertLinearToSRGB()
    },
    [wx]: {
        transfer: af,
        primaries: sg,
        toReference: s => s.applyMatrix3(hg),
        fromReference: s => s.applyMatrix3(cg)
    },
    [kS]: {
        transfer: ng,
        primaries: sg,
        toReference: s => s.convertSRGBToLinear().applyMatrix3(hg),
        fromReference: s => s.applyMatrix3(cg).convertLinearToSRGB()
    }
}
  , ob = new Set([Oi, wx])
  , en = {
    enabled: !0,
    _workingColorSpace: Oi,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(s) {
        if (!ob.has(s))
            throw new Error(`Unsupported working color space, "${s}".`);
        this._workingColorSpace = s
    },
    convert: function(s, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return s;
        const i = _c[e].toReference
          , n = _c[t].fromReference;
        return n(i(s))
    },
    fromWorkingColorSpace: function(s, e) {
        return this.convert(s, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(s, e) {
        return this.convert(s, e, this._workingColorSpace)
    },
    getPrimaries: function(s) {
        return _c[s].primaries
    },
    getTransfer: function(s) {
        return s === nl ? af : _c[s].transfer
    }
};
function ra(s) {
    return s < .04045 ? s * .0773993808 : Math.pow(s * .9478672986 + .0521327014, 2.4)
}
function Ou(s) {
    return s < .0031308 ? s * 12.92 : 1.055 * Math.pow(s, .41666) - .055
}
let To;
class ab {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            To === void 0 && (To = hf("canvas")),
            To.width = e.width,
            To.height = e.height;
            const i = To.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = To
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = hf("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const n = i.getImageData(0, 0, e.width, e.height)
              , r = n.data;
            for (let o = 0; o < r.length; o++)
                r[o] = ra(r[o] / 255) * 255;
            return i.putImageData(n, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(ra(t[i] / 255) * 255) : t[i] = ra(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let lb = 0;
class cb {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: lb++
        }),
        this.uuid = Bn(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , n = this.data;
        if (n !== null) {
            let r;
            if (Array.isArray(n)) {
                r = [];
                for (let o = 0, a = n.length; o < a; o++)
                    n[o].isDataTexture ? r.push(Bu(n[o].image)) : r.push(Bu(n[o]))
            } else
                r = Bu(n);
            i.url = r
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function Bu(s) {
    return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? ab.getDataURL(s) : s.data ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let hb = 0;
class bn extends Oh {
    constructor(e=bn.DEFAULT_IMAGE, t=bn.DEFAULT_MAPPING, i=Fs, n=Fs, r=as, o=Fh, a=qf, l=IS, c=bn.DEFAULT_ANISOTROPY, h=nl) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: hb++
        }),
        this.uuid = Bn(),
        this.name = "",
        this.source = new cb(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = n,
        this.magFilter = r,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new Xt(0,0),
        this.repeat = new Xt(1,1),
        this.center = new Xt(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Rr,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        typeof h == "string" ? this.colorSpace = h : (Fu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = h === Uu ? ai : nl),
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Tx)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Ml:
                e.x = e.x - Math.floor(e.x);
                break;
            case Fs:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case sf:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Ml:
                e.y = e.y - Math.floor(e.y);
                break;
            case Fs:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case sf:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    get encoding() {
        return Fu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace === ai ? Uu : BS
    }
    set encoding(e) {
        Fu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        this.colorSpace = e === Uu ? ai : nl
    }
}
bn.DEFAULT_IMAGE = null;
bn.DEFAULT_MAPPING = Tx;
bn.DEFAULT_ANISOTROPY = 1;
let Hn = class Ax {
    constructor(e=0, t=0, i=0, n=1) {
        Ax.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = n
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, n) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * n + o[12] * r,
        this.y = o[1] * t + o[5] * i + o[9] * n + o[13] * r,
        this.z = o[2] * t + o[6] * i + o[10] * n + o[14] * r,
        this.w = o[3] * t + o[7] * i + o[11] * n + o[15] * r,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, n, r;
        const l = e.elements
          , c = l[0]
          , h = l[4]
          , u = l[8]
          , d = l[1]
          , f = l[5]
          , m = l[9]
          , _ = l[2]
          , p = l[6]
          , g = l[10];
        if (Math.abs(h - d) < .01 && Math.abs(u - _) < .01 && Math.abs(m - p) < .01) {
            if (Math.abs(h + d) < .1 && Math.abs(u + _) < .1 && Math.abs(m + p) < .1 && Math.abs(c + f + g - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const y = (c + 1) / 2
              , S = (f + 1) / 2
              , C = (g + 1) / 2
              , w = (h + d) / 4
              , T = (u + _) / 4
              , B = (m + p) / 4;
            return y > S && y > C ? y < .01 ? (i = 0,
            n = .707106781,
            r = .707106781) : (i = Math.sqrt(y),
            n = w / i,
            r = T / i) : S > C ? S < .01 ? (i = .707106781,
            n = 0,
            r = .707106781) : (n = Math.sqrt(S),
            i = w / n,
            r = B / n) : C < .01 ? (i = .707106781,
            n = .707106781,
            r = 0) : (r = Math.sqrt(C),
            i = T / r,
            n = B / r),
            this.set(i, n, r, t),
            this
        }
        let M = Math.sqrt((p - m) * (p - m) + (u - _) * (u - _) + (d - h) * (d - h));
        return Math.abs(M) < .001 && (M = 1),
        this.x = (p - m) / M,
        this.y = (u - _) / M,
        this.z = (d - h) / M,
        this.w = Math.acos((c + f + g - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
;
class fs {
    constructor(e=0, t=0, i=0, n=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = n
    }
    static slerpFlat(e, t, i, n, r, o, a) {
        let l = i[n + 0]
          , c = i[n + 1]
          , h = i[n + 2]
          , u = i[n + 3];
        const d = r[o + 0]
          , f = r[o + 1]
          , m = r[o + 2]
          , _ = r[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = h,
            e[t + 3] = u;
            return
        }
        if (a === 1) {
            e[t + 0] = d,
            e[t + 1] = f,
            e[t + 2] = m,
            e[t + 3] = _;
            return
        }
        if (u !== _ || l !== d || c !== f || h !== m) {
            let p = 1 - a;
            const g = l * d + c * f + h * m + u * _
              , M = g >= 0 ? 1 : -1
              , y = 1 - g * g;
            if (y > Number.EPSILON) {
                const C = Math.sqrt(y)
                  , w = Math.atan2(C, g * M);
                p = Math.sin(p * w) / C,
                a = Math.sin(a * w) / C
            }
            const S = a * M;
            if (l = l * p + d * S,
            c = c * p + f * S,
            h = h * p + m * S,
            u = u * p + _ * S,
            p === 1 - a) {
                const C = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
                l *= C,
                c *= C,
                h *= C,
                u *= C
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = h,
        e[t + 3] = u
    }
    static multiplyQuaternionsFlat(e, t, i, n, r, o) {
        const a = i[n]
          , l = i[n + 1]
          , c = i[n + 2]
          , h = i[n + 3]
          , u = r[o]
          , d = r[o + 1]
          , f = r[o + 2]
          , m = r[o + 3];
        return e[t] = a * m + h * u + l * f - c * d,
        e[t + 1] = l * m + h * d + c * u - a * f,
        e[t + 2] = c * m + h * f + a * d - l * u,
        e[t + 3] = h * m - a * u - l * d - c * f,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, n) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = n,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const i = e._x
          , n = e._y
          , r = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(i / 2)
          , h = a(n / 2)
          , u = a(r / 2)
          , d = l(i / 2)
          , f = l(n / 2)
          , m = l(r / 2);
        switch (o) {
        case "XYZ":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "YXZ":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        case "ZXY":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "ZYX":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        case "YZX":
            this._x = d * h * u + c * f * m,
            this._y = c * f * u + d * h * m,
            this._z = c * h * m - d * f * u,
            this._w = c * h * u - d * f * m;
            break;
        case "XZY":
            this._x = d * h * u - c * f * m,
            this._y = c * f * u - d * h * m,
            this._z = c * h * m + d * f * u,
            this._w = c * h * u + d * f * m;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , n = Math.sin(i);
        return this._x = e.x * n,
        this._y = e.y * n,
        this._z = e.z * n,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , n = t[4]
          , r = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , h = t[6]
          , u = t[10]
          , d = i + a + u;
        if (d > 0) {
            const f = .5 / Math.sqrt(d + 1);
            this._w = .25 / f,
            this._x = (h - l) * f,
            this._y = (r - c) * f,
            this._z = (o - n) * f
        } else if (i > a && i > u) {
            const f = 2 * Math.sqrt(1 + i - a - u);
            this._w = (h - l) / f,
            this._x = .25 * f,
            this._y = (n + o) / f,
            this._z = (r + c) / f
        } else if (a > u) {
            const f = 2 * Math.sqrt(1 + a - i - u);
            this._w = (r - c) / f,
            this._x = (n + o) / f,
            this._y = .25 * f,
            this._z = (l + h) / f
        } else {
            const f = 2 * Math.sqrt(1 + u - i - a);
            this._w = (o - n) / f,
            this._x = (r + c) / f,
            this._y = (l + h) / f,
            this._z = .25 * f
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(di(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const n = Math.min(1, t / i);
        return this.slerp(e, n),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , n = e._y
          , r = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , h = t._w;
        return this._x = i * h + o * a + n * c - r * l,
        this._y = n * h + o * l + r * a - i * c,
        this._z = r * h + o * c + i * l - n * a,
        this._w = o * h - i * a - n * l - r * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , n = this._y
          , r = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + n * e._y + r * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = n,
            this._z = r,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const f = 1 - t;
            return this._w = f * o + t * this._w,
            this._x = f * i + t * this._x,
            this._y = f * n + t * this._y,
            this._z = f * r + t * this._z,
            this.normalize(),
            this
        }
        const c = Math.sqrt(l)
          , h = Math.atan2(c, a)
          , u = Math.sin((1 - t) * h) / c
          , d = Math.sin(t * h) / c;
        return this._w = o * u + this._w * d,
        this._x = i * u + this._x * d,
        this._y = n * u + this._y * d,
        this._z = r * u + this._z * d,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , i = Math.sqrt(e)
          , n = 2 * Math.PI * Math.random()
          , r = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(n), i * Math.sin(r), i * Math.cos(r), t * Math.sin(n))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class ee {
    constructor(e=0, t=0, i=0) {
        ee.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(ug.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(ug.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6] * n,
        this.y = r[1] * t + r[4] * i + r[7] * n,
        this.z = r[2] * t + r[5] * i + r[8] * n,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = e.elements
          , o = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
        return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * o,
        this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * o,
        this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = 2 * (o * n - a * i)
          , h = 2 * (a * t - r * n)
          , u = 2 * (r * i - o * t);
        return this.x = t + l * c + o * u - a * h,
        this.y = i + l * h + a * c - r * u,
        this.z = n + l * u + r * h - o * c,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[4] * i + r[8] * n,
        this.y = r[1] * t + r[5] * i + r[9] * n,
        this.z = r[2] * t + r[6] * i + r[10] * n,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , n = e.y
          , r = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = n * l - r * a,
        this.y = r * o - i * l,
        this.z = i * a - n * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return zu.copy(this).projectOnVector(e),
        this.sub(zu)
    }
    reflect(e) {
        return this.sub(zu.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(di(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , n = this.z - e.z;
        return t * t + i * i + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const n = Math.sin(t) * e;
        return this.x = n * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = n * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , n = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = n,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t),
        this.y = i * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const zu = new ee
  , ug = new fs;
class Cr {
    constructor(e=new ee(1 / 0,1 / 0,1 / 0), t=new ee(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(Rn.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(Rn.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = Rn.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const r = i.getAttribute("position");
            if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = r.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, Rn) : Rn.fromBufferAttribute(r, o),
                    Rn.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Rn);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                xc.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(),
                xc.copy(i.boundingBox)),
                xc.applyMatrix4(e.matrixWorld),
                this.union(xc)
        }
        const n = e.children;
        for (let r = 0, o = n.length; r < o; r++)
            this.expandByObject(n[r], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Rn),
        Rn.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(La),
        yc.subVectors(this.max, La),
        Eo.subVectors(e.a, La),
        wo.subVectors(e.b, La),
        Ao.subVectors(e.c, La),
        Or.subVectors(wo, Eo),
        Br.subVectors(Ao, wo),
        vs.subVectors(Eo, Ao);
        let t = [0, -Or.z, Or.y, 0, -Br.z, Br.y, 0, -vs.z, vs.y, Or.z, 0, -Or.x, Br.z, 0, -Br.x, vs.z, 0, -vs.x, -Or.y, Or.x, 0, -Br.y, Br.x, 0, -vs.y, vs.x, 0];
        return !ku(t, Eo, wo, Ao, yc) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !ku(t, Eo, wo, Ao, yc)) ? !1 : (vc.crossVectors(Or, Br),
        t = [vc.x, vc.y, vc.z],
        ku(t, Eo, wo, Ao, yc))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Rn).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(Rn).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (or[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        or[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        or[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        or[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        or[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        or[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        or[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        or[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(or),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const or = [new ee, new ee, new ee, new ee, new ee, new ee, new ee, new ee]
  , Rn = new ee
  , xc = new Cr
  , Eo = new ee
  , wo = new ee
  , Ao = new ee
  , Or = new ee
  , Br = new ee
  , vs = new ee
  , La = new ee
  , yc = new ee
  , vc = new ee
  , Ms = new ee;
function ku(s, e, t, i, n) {
    for (let r = 0, o = s.length - 3; r <= o; r += 3) {
        Ms.fromArray(s, r);
        const a = n.x * Math.abs(Ms.x) + n.y * Math.abs(Ms.y) + n.z * Math.abs(Ms.z)
          , l = e.dot(Ms)
          , c = t.dot(Ms)
          , h = i.dot(Ms);
        if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a)
            return !1
    }
    return !0
}
const ub = new Cr
  , Ia = new ee
  , Hu = new ee;
class Jn {
    constructor(e=new ee, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : ub.setFromPoints(e).getCenter(i);
        let n = 0;
        for (let r = 0, o = e.length; r < o; r++)
            n = Math.max(n, i.distanceToSquared(e[r]));
        return this.radius = Math.sqrt(n),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Ia.subVectors(e, this.center);
        const t = Ia.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , n = (i - this.radius) * .5;
            this.center.addScaledVector(Ia, n / i),
            this.radius += n
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Hu.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Ia.copy(e.center).add(Hu)),
        this.expandByPoint(Ia.copy(e.center).sub(Hu))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ar = new ee
  , Gu = new ee
  , Mc = new ee
  , zr = new ee
  , Vu = new ee
  , Sc = new ee
  , Wu = new ee;
class Bh {
    constructor(e=new ee, t=new ee(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, ar)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = ar.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (ar.copy(this.origin).addScaledVector(this.direction, t),
        ar.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, n) {
        Gu.copy(e).add(t).multiplyScalar(.5),
        Mc.copy(t).sub(e).normalize(),
        zr.copy(this.origin).sub(Gu);
        const r = e.distanceTo(t) * .5
          , o = -this.direction.dot(Mc)
          , a = zr.dot(this.direction)
          , l = -zr.dot(Mc)
          , c = zr.lengthSq()
          , h = Math.abs(1 - o * o);
        let u, d, f, m;
        if (h > 0)
            if (u = o * l - a,
            d = o * a - l,
            m = r * h,
            u >= 0)
                if (d >= -m)
                    if (d <= m) {
                        const _ = 1 / h;
                        u *= _,
                        d *= _,
                        f = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c
                    } else
                        d = r,
                        u = Math.max(0, -(o * d + a)),
                        f = -u * u + d * (d + 2 * l) + c;
                else
                    d = -r,
                    u = Math.max(0, -(o * d + a)),
                    f = -u * u + d * (d + 2 * l) + c;
            else
                d <= -m ? (u = Math.max(0, -(-o * r + a)),
                d = u > 0 ? -r : Math.min(Math.max(-r, -l), r),
                f = -u * u + d * (d + 2 * l) + c) : d <= m ? (u = 0,
                d = Math.min(Math.max(-r, -l), r),
                f = d * (d + 2 * l) + c) : (u = Math.max(0, -(o * r + a)),
                d = u > 0 ? r : Math.min(Math.max(-r, -l), r),
                f = -u * u + d * (d + 2 * l) + c);
        else
            d = o > 0 ? -r : r,
            u = Math.max(0, -(o * d + a)),
            f = -u * u + d * (d + 2 * l) + c;
        return i && i.copy(this.origin).addScaledVector(this.direction, u),
        n && n.copy(Gu).addScaledVector(Mc, d),
        f
    }
    intersectSphere(e, t) {
        ar.subVectors(e.center, this.origin);
        const i = ar.dot(this.direction)
          , n = ar.dot(ar) - i * i
          , r = e.radius * e.radius;
        if (n > r)
            return null;
        const o = Math.sqrt(r - n)
          , a = i - o
          , l = i + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, n, r, o, a, l;
        const c = 1 / this.direction.x
          , h = 1 / this.direction.y
          , u = 1 / this.direction.z
          , d = this.origin;
        return c >= 0 ? (i = (e.min.x - d.x) * c,
        n = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c,
        n = (e.min.x - d.x) * c),
        h >= 0 ? (r = (e.min.y - d.y) * h,
        o = (e.max.y - d.y) * h) : (r = (e.max.y - d.y) * h,
        o = (e.min.y - d.y) * h),
        i > o || r > n || ((r > i || isNaN(i)) && (i = r),
        (o < n || isNaN(n)) && (n = o),
        u >= 0 ? (a = (e.min.z - d.z) * u,
        l = (e.max.z - d.z) * u) : (a = (e.max.z - d.z) * u,
        l = (e.min.z - d.z) * u),
        i > l || a > n) || ((a > i || i !== i) && (i = a),
        (l < n || n !== n) && (n = l),
        n < 0) ? null : this.at(i >= 0 ? i : n, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, ar) !== null
    }
    intersectTriangle(e, t, i, n, r) {
        Vu.subVectors(t, e),
        Sc.subVectors(i, e),
        Wu.crossVectors(Vu, Sc);
        let o = this.direction.dot(Wu), a;
        if (o > 0) {
            if (n)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        zr.subVectors(this.origin, e);
        const l = a * this.direction.dot(Sc.crossVectors(zr, Sc));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(Vu.cross(zr));
        if (c < 0 || l + c > o)
            return null;
        const h = -a * zr.dot(Wu);
        return h < 0 ? null : this.at(h / o, r)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class vt {
    constructor(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, p) {
        vt.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, p)
    }
    set(e, t, i, n, r, o, a, l, c, h, u, d, f, m, _, p) {
        const g = this.elements;
        return g[0] = e,
        g[4] = t,
        g[8] = i,
        g[12] = n,
        g[1] = r,
        g[5] = o,
        g[9] = a,
        g[13] = l,
        g[2] = c,
        g[6] = h,
        g[10] = u,
        g[14] = d,
        g[3] = f,
        g[7] = m,
        g[11] = _,
        g[15] = p,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new vt().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , n = 1 / Ro.setFromMatrixColumn(e, 0).length()
          , r = 1 / Ro.setFromMatrixColumn(e, 1).length()
          , o = 1 / Ro.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * n,
        t[1] = i[1] * n,
        t[2] = i[2] * n,
        t[3] = 0,
        t[4] = i[4] * r,
        t[5] = i[5] * r,
        t[6] = i[6] * r,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , n = e.y
          , r = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , l = Math.cos(n)
          , c = Math.sin(n)
          , h = Math.cos(r)
          , u = Math.sin(r);
        if (e.order === "XYZ") {
            const d = o * h
              , f = o * u
              , m = a * h
              , _ = a * u;
            t[0] = l * h,
            t[4] = -l * u,
            t[8] = c,
            t[1] = f + m * c,
            t[5] = d - _ * c,
            t[9] = -a * l,
            t[2] = _ - d * c,
            t[6] = m + f * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const d = l * h
              , f = l * u
              , m = c * h
              , _ = c * u;
            t[0] = d + _ * a,
            t[4] = m * a - f,
            t[8] = o * c,
            t[1] = o * u,
            t[5] = o * h,
            t[9] = -a,
            t[2] = f * a - m,
            t[6] = _ + d * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const d = l * h
              , f = l * u
              , m = c * h
              , _ = c * u;
            t[0] = d - _ * a,
            t[4] = -o * u,
            t[8] = m + f * a,
            t[1] = f + m * a,
            t[5] = o * h,
            t[9] = _ - d * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const d = o * h
              , f = o * u
              , m = a * h
              , _ = a * u;
            t[0] = l * h,
            t[4] = m * c - f,
            t[8] = d * c + _,
            t[1] = l * u,
            t[5] = _ * c + d,
            t[9] = f * c - m,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const d = o * l
              , f = o * c
              , m = a * l
              , _ = a * c;
            t[0] = l * h,
            t[4] = _ - d * u,
            t[8] = m * u + f,
            t[1] = u,
            t[5] = o * h,
            t[9] = -a * h,
            t[2] = -c * h,
            t[6] = f * u + m,
            t[10] = d - _ * u
        } else if (e.order === "XZY") {
            const d = o * l
              , f = o * c
              , m = a * l
              , _ = a * c;
            t[0] = l * h,
            t[4] = -u,
            t[8] = c * h,
            t[1] = d * u + _,
            t[5] = o * h,
            t[9] = f * u - m,
            t[2] = m * u - f,
            t[6] = a * h,
            t[10] = _ * u + d
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(db, e, fb)
    }
    lookAt(e, t, i) {
        const n = this.elements;
        return Ji.subVectors(e, t),
        Ji.lengthSq() === 0 && (Ji.z = 1),
        Ji.normalize(),
        kr.crossVectors(i, Ji),
        kr.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Ji.x += 1e-4 : Ji.z += 1e-4,
        Ji.normalize(),
        kr.crossVectors(i, Ji)),
        kr.normalize(),
        bc.crossVectors(Ji, kr),
        n[0] = kr.x,
        n[4] = bc.x,
        n[8] = Ji.x,
        n[1] = kr.y,
        n[5] = bc.y,
        n[9] = Ji.y,
        n[2] = kr.z,
        n[6] = bc.z,
        n[10] = Ji.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , n = t.elements
          , r = this.elements
          , o = i[0]
          , a = i[4]
          , l = i[8]
          , c = i[12]
          , h = i[1]
          , u = i[5]
          , d = i[9]
          , f = i[13]
          , m = i[2]
          , _ = i[6]
          , p = i[10]
          , g = i[14]
          , M = i[3]
          , y = i[7]
          , S = i[11]
          , C = i[15]
          , w = n[0]
          , T = n[4]
          , B = n[8]
          , b = n[12]
          , E = n[1]
          , G = n[5]
          , k = n[9]
          , te = n[13]
          , O = n[2]
          , H = n[6]
          , V = n[10]
          , Y = n[14]
          , K = n[3]
          , J = n[7]
          , D = n[11]
          , se = n[15];
        return r[0] = o * w + a * E + l * O + c * K,
        r[4] = o * T + a * G + l * H + c * J,
        r[8] = o * B + a * k + l * V + c * D,
        r[12] = o * b + a * te + l * Y + c * se,
        r[1] = h * w + u * E + d * O + f * K,
        r[5] = h * T + u * G + d * H + f * J,
        r[9] = h * B + u * k + d * V + f * D,
        r[13] = h * b + u * te + d * Y + f * se,
        r[2] = m * w + _ * E + p * O + g * K,
        r[6] = m * T + _ * G + p * H + g * J,
        r[10] = m * B + _ * k + p * V + g * D,
        r[14] = m * b + _ * te + p * Y + g * se,
        r[3] = M * w + y * E + S * O + C * K,
        r[7] = M * T + y * G + S * H + C * J,
        r[11] = M * B + y * k + S * V + C * D,
        r[15] = M * b + y * te + S * Y + C * se,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , n = e[8]
          , r = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , h = e[2]
          , u = e[6]
          , d = e[10]
          , f = e[14]
          , m = e[3]
          , _ = e[7]
          , p = e[11]
          , g = e[15];
        return m * (+r * l * u - n * c * u - r * a * d + i * c * d + n * a * f - i * l * f) + _ * (+t * l * f - t * c * d + r * o * d - n * o * f + n * c * h - r * l * h) + p * (+t * c * u - t * a * f - r * o * u + i * o * f + r * a * h - i * c * h) + g * (-n * a * h - t * l * u + t * a * d + n * o * u - i * o * d + i * l * h)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const n = this.elements;
        return e.isVector3 ? (n[12] = e.x,
        n[13] = e.y,
        n[14] = e.z) : (n[12] = e,
        n[13] = t,
        n[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , n = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8]
          , u = e[9]
          , d = e[10]
          , f = e[11]
          , m = e[12]
          , _ = e[13]
          , p = e[14]
          , g = e[15]
          , M = u * p * c - _ * d * c + _ * l * f - a * p * f - u * l * g + a * d * g
          , y = m * d * c - h * p * c - m * l * f + o * p * f + h * l * g - o * d * g
          , S = h * _ * c - m * u * c + m * a * f - o * _ * f - h * a * g + o * u * g
          , C = m * u * l - h * _ * l - m * a * d + o * _ * d + h * a * p - o * u * p
          , w = t * M + i * y + n * S + r * C;
        if (w === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / w;
        return e[0] = M * T,
        e[1] = (_ * d * r - u * p * r - _ * n * f + i * p * f + u * n * g - i * d * g) * T,
        e[2] = (a * p * r - _ * l * r + _ * n * c - i * p * c - a * n * g + i * l * g) * T,
        e[3] = (u * l * r - a * d * r - u * n * c + i * d * c + a * n * f - i * l * f) * T,
        e[4] = y * T,
        e[5] = (h * p * r - m * d * r + m * n * f - t * p * f - h * n * g + t * d * g) * T,
        e[6] = (m * l * r - o * p * r - m * n * c + t * p * c + o * n * g - t * l * g) * T,
        e[7] = (o * d * r - h * l * r + h * n * c - t * d * c - o * n * f + t * l * f) * T,
        e[8] = S * T,
        e[9] = (m * u * r - h * _ * r - m * i * f + t * _ * f + h * i * g - t * u * g) * T,
        e[10] = (o * _ * r - m * a * r + m * i * c - t * _ * c - o * i * g + t * a * g) * T,
        e[11] = (h * a * r - o * u * r - h * i * c + t * u * c + o * i * f - t * a * f) * T,
        e[12] = C * T,
        e[13] = (h * _ * n - m * u * n + m * i * d - t * _ * d - h * i * p + t * u * p) * T,
        e[14] = (m * a * n - o * _ * n - m * i * l + t * _ * l + o * i * p - t * a * p) * T,
        e[15] = (o * u * n - h * a * n + h * i * l - t * u * l - o * i * d + t * a * d) * T,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , n = e.y
          , r = e.z;
        return t[0] *= i,
        t[4] *= n,
        t[8] *= r,
        t[1] *= i,
        t[5] *= n,
        t[9] *= r,
        t[2] *= i,
        t[6] *= n,
        t[10] *= r,
        t[3] *= i,
        t[7] *= n,
        t[11] *= r,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, n))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , n = Math.sin(t)
          , r = 1 - i
          , o = e.x
          , a = e.y
          , l = e.z
          , c = r * o
          , h = r * a;
        return this.set(c * o + i, c * a - n * l, c * l + n * a, 0, c * a + n * l, h * a + i, h * l - n * o, 0, c * l - n * a, h * l + n * o, r * l * l + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, n, r, o) {
        return this.set(1, i, r, 0, e, 1, o, 0, t, n, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const n = this.elements
          , r = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = r + r
          , h = o + o
          , u = a + a
          , d = r * c
          , f = r * h
          , m = r * u
          , _ = o * h
          , p = o * u
          , g = a * u
          , M = l * c
          , y = l * h
          , S = l * u
          , C = i.x
          , w = i.y
          , T = i.z;
        return n[0] = (1 - (_ + g)) * C,
        n[1] = (f + S) * C,
        n[2] = (m - y) * C,
        n[3] = 0,
        n[4] = (f - S) * w,
        n[5] = (1 - (d + g)) * w,
        n[6] = (p + M) * w,
        n[7] = 0,
        n[8] = (m + y) * T,
        n[9] = (p - M) * T,
        n[10] = (1 - (d + _)) * T,
        n[11] = 0,
        n[12] = e.x,
        n[13] = e.y,
        n[14] = e.z,
        n[15] = 1,
        this
    }
    decompose(e, t, i) {
        const n = this.elements;
        let r = Ro.set(n[0], n[1], n[2]).length();
        const o = Ro.set(n[4], n[5], n[6]).length()
          , a = Ro.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (r = -r),
        e.x = n[12],
        e.y = n[13],
        e.z = n[14],
        Cn.copy(this);
        const c = 1 / r
          , h = 1 / o
          , u = 1 / a;
        return Cn.elements[0] *= c,
        Cn.elements[1] *= c,
        Cn.elements[2] *= c,
        Cn.elements[4] *= h,
        Cn.elements[5] *= h,
        Cn.elements[6] *= h,
        Cn.elements[8] *= u,
        Cn.elements[9] *= u,
        Cn.elements[10] *= u,
        t.setFromRotationMatrix(Cn),
        i.x = r,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, n, r, o, a=Os) {
        const l = this.elements
          , c = 2 * r / (t - e)
          , h = 2 * r / (i - n)
          , u = (t + e) / (t - e)
          , d = (i + n) / (i - n);
        let f, m;
        if (a === Os)
            f = -(o + r) / (o - r),
            m = -2 * o * r / (o - r);
        else if (a === cf)
            f = -o / (o - r),
            m = -o * r / (o - r);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c,
        l[4] = 0,
        l[8] = u,
        l[12] = 0,
        l[1] = 0,
        l[5] = h,
        l[9] = d,
        l[13] = 0,
        l[2] = 0,
        l[6] = 0,
        l[10] = f,
        l[14] = m,
        l[3] = 0,
        l[7] = 0,
        l[11] = -1,
        l[15] = 0,
        this
    }
    makeOrthographic(e, t, i, n, r, o, a=Os) {
        const l = this.elements
          , c = 1 / (t - e)
          , h = 1 / (i - n)
          , u = 1 / (o - r)
          , d = (t + e) * c
          , f = (i + n) * h;
        let m, _;
        if (a === Os)
            m = (o + r) * u,
            _ = -2 * u;
        else if (a === cf)
            m = r * u,
            _ = -1 * u;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c,
        l[4] = 0,
        l[8] = 0,
        l[12] = -d,
        l[1] = 0,
        l[5] = 2 * h,
        l[9] = 0,
        l[13] = -f,
        l[2] = 0,
        l[6] = 0,
        l[10] = _,
        l[14] = -m,
        l[3] = 0,
        l[7] = 0,
        l[11] = 0,
        l[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let n = 0; n < 16; n++)
            if (t[n] !== i[n])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const Ro = new ee
  , Cn = new vt
  , db = new ee(0,0,0)
  , fb = new ee(1,1,1)
  , kr = new ee
  , bc = new ee
  , Ji = new ee
  , dg = new vt
  , fg = new fs;
class zh {
    constructor(e=0, t=0, i=0, n=zh.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = n
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, n=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = n,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const n = e.elements
          , r = n[0]
          , o = n[4]
          , a = n[8]
          , l = n[1]
          , c = n[5]
          , h = n[9]
          , u = n[2]
          , d = n[6]
          , f = n[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(di(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, f),
            this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(d, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-di(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, f),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, r),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(di(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, f),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, r));
            break;
        case "ZYX":
            this._y = Math.asin(-di(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, f),
            this._z = Math.atan2(l, r)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(di(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c),
            this._y = Math.atan2(-u, r)) : (this._x = 0,
            this._y = Math.atan2(a, f));
            break;
        case "XZY":
            this._z = Math.asin(-di(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c),
            this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, f),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return dg.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(dg, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return fg.setFromEuler(this),
        this.setFromQuaternion(fg, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
zh.DEFAULT_ORDER = "XYZ";
class pb {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let mb = 0;
const pg = new ee
  , Co = new fs
  , lr = new vt
  , Tc = new ee
  , Da = new ee
  , gb = new ee
  , _b = new fs
  , mg = new ee(1,0,0)
  , gg = new ee(0,1,0)
  , _g = new ee(0,0,1)
  , xb = {
    type: "added"
}
  , yb = {
    type: "removed"
};
class qt extends Oh {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: mb++
        }),
        this.uuid = Bn(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = qt.DEFAULT_UP.clone();
        const e = new ee
          , t = new zh
          , i = new fs
          , n = new ee(1,1,1);
        function r() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(r),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new vt
            },
            normalMatrix: {
                value: new Rr
            }
        }),
        this.matrix = new vt,
        this.matrixWorld = new vt,
        this.matrixAutoUpdate = qt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = qt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new pb,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Co.setFromAxisAngle(e, t),
        this.quaternion.multiply(Co),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Co.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Co),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(mg, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(gg, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(_g, e)
    }
    translateOnAxis(e, t) {
        return pg.copy(e).applyQuaternion(this.quaternion),
        this.position.add(pg.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(mg, e)
    }
    translateY(e) {
        return this.translateOnAxis(gg, e)
    }
    translateZ(e) {
        return this.translateOnAxis(_g, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(lr.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? Tc.copy(e) : Tc.set(e, t, i);
        const n = this.parent;
        this.updateWorldMatrix(!0, !1),
        Da.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? lr.lookAt(Da, Tc, this.up) : lr.lookAt(Tc, Da, this.up),
        this.quaternion.setFromRotationMatrix(lr),
        n && (lr.extractRotation(n.matrixWorld),
        Co.setFromRotationMatrix(lr),
        this.quaternion.premultiply(Co.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(xb)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(yb)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        lr.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        lr.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(lr),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, i=[]) {
        this[e] === t && i.push(this);
        const n = this.children;
        for (let r = 0, o = n.length; r < o; r++)
            n[r].getObjectsByProperty(e, t, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Da, e, gb),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Da, _b, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) {
            const r = t[i];
            (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            const n = this.children;
            for (let r = 0, o = n.length; r < o; r++) {
                const a = n[r];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const n = {};
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.castShadow === !0 && (n.castShadow = !0),
        this.receiveShadow === !0 && (n.receiveShadow = !0),
        this.visible === !1 && (n.visible = !1),
        this.frustumCulled === !1 && (n.frustumCulled = !1),
        this.renderOrder !== 0 && (n.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        n.layers = this.layers.mask,
        n.matrix = this.matrix.toArray(),
        n.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (n.matrixAutoUpdate = !1),
        this.isInstancedMesh && (n.type = "InstancedMesh",
        n.count = this.count,
        n.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (n.type = "BatchedMesh",
        n.perObjectFrustumCulled = this.perObjectFrustumCulled,
        n.sortObjects = this.sortObjects,
        n.drawRanges = this._drawRanges,
        n.reservedRanges = this._reservedRanges,
        n.visibility = this._visibility,
        n.active = this._active,
        n.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        n.maxGeometryCount = this._maxGeometryCount,
        n.maxVertexCount = this._maxVertexCount,
        n.maxIndexCount = this._maxIndexCount,
        n.geometryInitialized = this._geometryInitialized,
        n.geometryCount = this._geometryCount,
        n.matricesTexture = this._matricesTexture.toJSON(e),
        this.boundingSphere !== null && (n.boundingSphere = {
            center: n.boundingSphere.center.toArray(),
            radius: n.boundingSphere.radius
        }),
        this.boundingBox !== null && (n.boundingBox = {
            min: n.boundingBox.min.toArray(),
            max: n.boundingBox.max.toArray()
        }));
        function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (n.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, h = l.length; c < h; c++) {
                        const u = l[c];
                        r(e.shapes, u)
                    }
                else
                    r(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (n.bindMode = this.bindMode,
        n.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (r(e.skeletons, this.skeleton),
        n.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(r(e.materials, this.material[l]));
                n.material = a
            } else
                n.material = r(e.materials, this.material);
        if (this.children.length > 0) {
            n.children = [];
            for (let a = 0; a < this.children.length; a++)
                n.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            n.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                n.animations.push(r(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , h = o(e.images)
              , u = o(e.shapes)
              , d = o(e.skeletons)
              , f = o(e.animations)
              , m = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            l.length > 0 && (i.materials = l),
            c.length > 0 && (i.textures = c),
            h.length > 0 && (i.images = h),
            u.length > 0 && (i.shapes = u),
            d.length > 0 && (i.skeletons = d),
            f.length > 0 && (i.animations = f),
            m.length > 0 && (i.nodes = m)
        }
        return i.object = n,
        i;
        function o(a) {
            const l = [];
            for (const c in a) {
                const h = a[c];
                delete h.metadata,
                l.push(h)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const n = e.children[i];
                this.add(n.clone())
            }
        return this
    }
}
qt.DEFAULT_UP = new ee(0,1,0);
qt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
qt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Pn = new ee
  , cr = new ee
  , Xu = new ee
  , hr = new ee
  , Po = new ee
  , Lo = new ee
  , xg = new ee
  , qu = new ee
  , Yu = new ee
  , $u = new ee;
let Ec = !1;
class Un {
    constructor(e=new ee, t=new ee, i=new ee) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, n) {
        n.subVectors(i, t),
        Pn.subVectors(e, t),
        n.cross(Pn);
        const r = n.lengthSq();
        return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, n, r) {
        Pn.subVectors(n, t),
        cr.subVectors(i, t),
        Xu.subVectors(e, t);
        const o = Pn.dot(Pn)
          , a = Pn.dot(cr)
          , l = Pn.dot(Xu)
          , c = cr.dot(cr)
          , h = cr.dot(Xu)
          , u = o * c - a * a;
        if (u === 0)
            return r.set(0, 0, 0),
            null;
        const d = 1 / u
          , f = (c * l - a * h) * d
          , m = (o * h - a * l) * d;
        return r.set(1 - f - m, m, f)
    }
    static containsPoint(e, t, i, n) {
        return this.getBarycoord(e, t, i, n, hr) === null ? !1 : hr.x >= 0 && hr.y >= 0 && hr.x + hr.y <= 1
    }
    static getUV(e, t, i, n, r, o, a, l) {
        return Ec === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        Ec = !0),
        this.getInterpolation(e, t, i, n, r, o, a, l)
    }
    static getInterpolation(e, t, i, n, r, o, a, l) {
        return this.getBarycoord(e, t, i, n, hr) === null ? (l.x = 0,
        l.y = 0,
        "z"in l && (l.z = 0),
        "w"in l && (l.w = 0),
        null) : (l.setScalar(0),
        l.addScaledVector(r, hr.x),
        l.addScaledVector(o, hr.y),
        l.addScaledVector(a, hr.z),
        l)
    }
    static isFrontFacing(e, t, i, n) {
        return Pn.subVectors(i, t),
        cr.subVectors(e, t),
        Pn.cross(cr).dot(n) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, n) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[n]),
        this
    }
    setFromAttributeAndIndices(e, t, i, n) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, n),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Pn.subVectors(this.c, this.b),
        cr.subVectors(this.a, this.b),
        Pn.cross(cr).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Un.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Un.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, n, r) {
        return Ec === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
        Ec = !0),
        Un.getInterpolation(e, this.a, this.b, this.c, t, i, n, r)
    }
    getInterpolation(e, t, i, n, r) {
        return Un.getInterpolation(e, this.a, this.b, this.c, t, i, n, r)
    }
    containsPoint(e) {
        return Un.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Un.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , n = this.b
          , r = this.c;
        let o, a;
        Po.subVectors(n, i),
        Lo.subVectors(r, i),
        qu.subVectors(e, i);
        const l = Po.dot(qu)
          , c = Lo.dot(qu);
        if (l <= 0 && c <= 0)
            return t.copy(i);
        Yu.subVectors(e, n);
        const h = Po.dot(Yu)
          , u = Lo.dot(Yu);
        if (h >= 0 && u <= h)
            return t.copy(n);
        const d = l * u - h * c;
        if (d <= 0 && l >= 0 && h <= 0)
            return o = l / (l - h),
            t.copy(i).addScaledVector(Po, o);
        $u.subVectors(e, r);
        const f = Po.dot($u)
          , m = Lo.dot($u);
        if (m >= 0 && f <= m)
            return t.copy(r);
        const _ = f * c - l * m;
        if (_ <= 0 && c >= 0 && m <= 0)
            return a = c / (c - m),
            t.copy(i).addScaledVector(Lo, a);
        const p = h * m - f * u;
        if (p <= 0 && u - h >= 0 && f - m >= 0)
            return xg.subVectors(r, n),
            a = (u - h) / (u - h + (f - m)),
            t.copy(n).addScaledVector(xg, a);
        const g = 1 / (p + _ + d);
        return o = _ * g,
        a = d * g,
        t.copy(i).addScaledVector(Po, o).addScaledVector(Lo, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Rx = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Hr = {
    h: 0,
    s: 0,
    l: 0
}
  , wc = {
    h: 0,
    s: 0,
    l: 0
};
function ju(s, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s
}
class Jt {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const n = e;
            n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n)
        } else
            this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=ai) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        en.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, n=en.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        en.toWorkingColorSpace(this, n),
        this
    }
    setHSL(e, t, i, n=en.workingColorSpace) {
        if (e = Yf(e, 1),
        t = di(t, 0, 1),
        i = di(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const r = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - r;
            this.r = ju(o, r, e + 1 / 3),
            this.g = ju(o, r, e),
            this.b = ju(o, r, e - 1 / 3)
        }
        return en.toWorkingColorSpace(this, n),
        this
    }
    setStyle(e, t=ai) {
        function i(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let n;
        if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let r;
            const o = n[1]
              , a = n[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(r[4]),
                    this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(r[4]),
                    this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(r[4]),
                    this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const r = n[1]
              , o = r.length;
            if (o === 3)
                return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(r, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=ai) {
        const i = Rx[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = ra(e.r),
        this.g = ra(e.g),
        this.b = ra(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = Ou(e.r),
        this.g = Ou(e.g),
        this.b = Ou(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=ai) {
        return en.fromWorkingColorSpace(xi.copy(this), e),
        Math.round(di(xi.r * 255, 0, 255)) * 65536 + Math.round(di(xi.g * 255, 0, 255)) * 256 + Math.round(di(xi.b * 255, 0, 255))
    }
    getHexString(e=ai) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=en.workingColorSpace) {
        en.fromWorkingColorSpace(xi.copy(this), t);
        const i = xi.r
          , n = xi.g
          , r = xi.b
          , o = Math.max(i, n, r)
          , a = Math.min(i, n, r);
        let l, c;
        const h = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const u = o - a;
            switch (c = h <= .5 ? u / (o + a) : u / (2 - o - a),
            o) {
            case i:
                l = (n - r) / u + (n < r ? 6 : 0);
                break;
            case n:
                l = (r - i) / u + 2;
                break;
            case r:
                l = (i - n) / u + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = h,
        e
    }
    getRGB(e, t=en.workingColorSpace) {
        return en.fromWorkingColorSpace(xi.copy(this), t),
        e.r = xi.r,
        e.g = xi.g,
        e.b = xi.b,
        e
    }
    getStyle(e=ai) {
        en.fromWorkingColorSpace(xi.copy(this), e);
        const t = xi.r
          , i = xi.g
          , n = xi.b;
        return e !== ai ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Hr),
        this.setHSL(Hr.h + e, Hr.s + t, Hr.l + i)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Hr),
        e.getHSL(wc);
        const i = sl(Hr.h, wc.h, t)
          , n = sl(Hr.s, wc.s, t)
          , r = sl(Hr.l, wc.l, t);
        return this.setHSL(i, n, r),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , i = this.g
          , n = this.b
          , r = e.elements;
        return this.r = r[0] * t + r[3] * i + r[6] * n,
        this.g = r[1] * t + r[4] * i + r[7] * n,
        this.b = r[2] * t + r[5] * i + r[8] * n,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const xi = new Jt;
Jt.NAMES = Rx;
let vb = 0;
class Zs extends Oh {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: vb++
        }),
        this.uuid = Bn(),
        this.name = "",
        this.type = "Material",
        this.blending = Ym,
        this.side = Ah,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = jm,
        this.blendDst = Zm,
        this.blendEquation = $m,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Jt(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Km,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = og,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = bo,
        this.stencilZFail = bo,
        this.stencilZPass = bo,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const n = this[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Ym && (i.blending = this.blending),
        this.side !== Ah && (i.side = this.side),
        this.vertexColors === !0 && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = !0),
        this.blendSrc !== jm && (i.blendSrc = this.blendSrc),
        this.blendDst !== Zm && (i.blendDst = this.blendDst),
        this.blendEquation !== $m && (i.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
        this.depthFunc !== Km && (i.depthFunc = this.depthFunc),
        this.depthTest === !1 && (i.depthTest = this.depthTest),
        this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== og && (i.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== bo && (i.stencilFail = this.stencilFail),
        this.stencilZFail !== bo && (i.stencilZFail = this.stencilZFail),
        this.stencilZPass !== bo && (i.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (i.alphaHash = !0),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (i.forceSinglePass = !0),
        this.wireframe === !0 && (i.wireframe = !0),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = !0),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function n(r) {
            const o = [];
            for (const a in r) {
                const l = r[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const r = n(e.textures)
              , o = n(e.images);
            r.length > 0 && (i.textures = r),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const n = t.length;
            i = new Array(n);
            for (let r = 0; r !== n; ++r)
                i[r] = t[r].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class Yo extends Zs {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Jt(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = AS,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const _r = Mb();
function Mb() {
    const s = new ArrayBuffer(4)
      , e = new Float32Array(s)
      , t = new Uint32Array(s)
      , i = new Uint32Array(512)
      , n = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (i[l] = 0,
        i[l | 256] = 32768,
        n[l] = 24,
        n[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14,
        i[l | 256] = 1024 >> -c - 14 | 32768,
        n[l] = -c - 1,
        n[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10,
        i[l | 256] = c + 15 << 10 | 32768,
        n[l] = 13,
        n[l | 256] = 13) : c < 128 ? (i[l] = 31744,
        i[l | 256] = 64512,
        n[l] = 24,
        n[l | 256] = 24) : (i[l] = 31744,
        i[l | 256] = 64512,
        n[l] = 13,
        n[l | 256] = 13)
    }
    const r = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13
          , h = 0;
        for (; !(c & 8388608); )
            c <<= 1,
            h -= 8388608;
        c &= -8388609,
        h += 947912704,
        r[l] = c | h
    }
    for (let l = 1024; l < 2048; ++l)
        r[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: n,
        mantissaTable: r,
        exponentTable: o,
        offsetTable: a
    }
}
function Sb(s) {
    Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    s = di(s, -65504, 65504),
    _r.floatView[0] = s;
    const e = _r.uint32View[0]
      , t = e >> 23 & 511;
    return _r.baseTable[t] + ((e & 8388607) >> _r.shiftTable[t])
}
function bb(s) {
    const e = s >> 10;
    return _r.uint32View[0] = _r.mantissaTable[_r.offsetTable[e] + (s & 1023)] + _r.exponentTable[e],
    _r.floatView[0]
}
const yg = {
    toHalfFloat: Sb,
    fromHalfFloat: bb
}
  , $t = new ee
  , Ac = new Xt;
class cn {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = lf,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = il,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let n = 0, r = this.itemSize; n < r; n++)
            this.array[e + n] = t.array[i + n];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                Ac.fromBufferAttribute(this, t),
                Ac.applyMatrix3(e),
                this.setXY(t, Ac.x, Ac.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                $t.fromBufferAttribute(this, t),
                $t.applyMatrix3(e),
                this.setXYZ(t, $t.x, $t.y, $t.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            $t.fromBufferAttribute(this, t),
            $t.applyMatrix4(e),
            this.setXYZ(t, $t.x, $t.y, $t.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            $t.fromBufferAttribute(this, t),
            $t.applyNormalMatrix(e),
            this.setXYZ(t, $t.x, $t.y, $t.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            $t.fromBufferAttribute(this, t),
            $t.transformDirection(e),
            this.setXYZ(t, $t.x, $t.y, $t.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = Wn(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = Et(i, this.array)),
        this.array[e * this.itemSize + t] = i,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Wn(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = Et(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Wn(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = Et(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Wn(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = Et(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Wn(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = Et(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = Et(t, this.array),
        i = Et(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, n) {
        return e *= this.itemSize,
        this.normalized && (t = Et(t, this.array),
        i = Et(i, this.array),
        n = Et(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = n,
        this
    }
    setXYZW(e, t, i, n, r) {
        return e *= this.itemSize,
        this.normalized && (t = Et(t, this.array),
        i = Et(i, this.array),
        n = Et(n, this.array),
        r = Et(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = n,
        this.array[e + 3] = r,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== lf && (e.usage = this.usage),
        e
    }
}
class Tb extends cn {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class Eb extends cn {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class $f extends cn {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
let wb = 0;
const dn = new vt
  , Zu = new qt
  , Io = new ee
  , Qi = new Cr
  , Ua = new Cr
  , ni = new ee;
class so extends Oh {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: wb++
        }),
        this.uuid = Bn(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (sb(e) ? Eb : Tb)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const r = new Rr().getNormalMatrix(e);
            i.applyNormalMatrix(r),
            i.needsUpdate = !0
        }
        const n = this.attributes.tangent;
        return n !== void 0 && (n.transformDirection(e),
        n.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return dn.makeRotationFromQuaternion(e),
        this.applyMatrix4(dn),
        this
    }
    rotateX(e) {
        return dn.makeRotationX(e),
        this.applyMatrix4(dn),
        this
    }
    rotateY(e) {
        return dn.makeRotationY(e),
        this.applyMatrix4(dn),
        this
    }
    rotateZ(e) {
        return dn.makeRotationZ(e),
        this.applyMatrix4(dn),
        this
    }
    translate(e, t, i) {
        return dn.makeTranslation(e, t, i),
        this.applyMatrix4(dn),
        this
    }
    scale(e, t, i) {
        return dn.makeScale(e, t, i),
        this.applyMatrix4(dn),
        this
    }
    lookAt(e) {
        return Zu.lookAt(e),
        Zu.updateMatrix(),
        this.applyMatrix4(Zu.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Io).negate(),
        this.translate(Io.x, Io.y, Io.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, n = e.length; i < n; i++) {
            const r = e[i];
            t.push(r.x, r.y, r.z || 0)
        }
        return this.setAttribute("position", new $f(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Cr);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new ee(-1 / 0,-1 / 0,-1 / 0), new ee(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, n = t.length; i < n; i++) {
                    const r = t[i];
                    Qi.setFromBufferAttribute(r),
                    this.morphTargetsRelative ? (ni.addVectors(this.boundingBox.min, Qi.min),
                    this.boundingBox.expandByPoint(ni),
                    ni.addVectors(this.boundingBox.max, Qi.max),
                    this.boundingBox.expandByPoint(ni)) : (this.boundingBox.expandByPoint(Qi.min),
                    this.boundingBox.expandByPoint(Qi.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Jn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new ee, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Qi.setFromBufferAttribute(e),
            t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r];
                    Ua.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (ni.addVectors(Qi.min, Ua.min),
                    Qi.expandByPoint(ni),
                    ni.addVectors(Qi.max, Ua.max),
                    Qi.expandByPoint(ni)) : (Qi.expandByPoint(Ua.min),
                    Qi.expandByPoint(Ua.max))
                }
            Qi.getCenter(i);
            let n = 0;
            for (let r = 0, o = e.count; r < o; r++)
                ni.fromBufferAttribute(e, r),
                n = Math.max(n, i.distanceToSquared(ni));
            if (t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, h = a.count; c < h; c++)
                        ni.fromBufferAttribute(a, c),
                        l && (Io.fromBufferAttribute(e, c),
                        ni.add(Io)),
                        n = Math.max(n, i.distanceToSquared(ni))
                }
            this.boundingSphere.radius = Math.sqrt(n),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array
          , n = t.position.array
          , r = t.normal.array
          , o = t.uv.array
          , a = n.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new cn(new Float32Array(4 * a),4));
        const l = this.getAttribute("tangent").array
          , c = []
          , h = [];
        for (let E = 0; E < a; E++)
            c[E] = new ee,
            h[E] = new ee;
        const u = new ee
          , d = new ee
          , f = new ee
          , m = new Xt
          , _ = new Xt
          , p = new Xt
          , g = new ee
          , M = new ee;
        function y(E, G, k) {
            u.fromArray(n, E * 3),
            d.fromArray(n, G * 3),
            f.fromArray(n, k * 3),
            m.fromArray(o, E * 2),
            _.fromArray(o, G * 2),
            p.fromArray(o, k * 2),
            d.sub(u),
            f.sub(u),
            _.sub(m),
            p.sub(m);
            const te = 1 / (_.x * p.y - p.x * _.y);
            isFinite(te) && (g.copy(d).multiplyScalar(p.y).addScaledVector(f, -_.y).multiplyScalar(te),
            M.copy(f).multiplyScalar(_.x).addScaledVector(d, -p.x).multiplyScalar(te),
            c[E].add(g),
            c[G].add(g),
            c[k].add(g),
            h[E].add(M),
            h[G].add(M),
            h[k].add(M))
        }
        let S = this.groups;
        S.length === 0 && (S = [{
            start: 0,
            count: i.length
        }]);
        for (let E = 0, G = S.length; E < G; ++E) {
            const k = S[E]
              , te = k.start
              , O = k.count;
            for (let H = te, V = te + O; H < V; H += 3)
                y(i[H + 0], i[H + 1], i[H + 2])
        }
        const C = new ee
          , w = new ee
          , T = new ee
          , B = new ee;
        function b(E) {
            T.fromArray(r, E * 3),
            B.copy(T);
            const G = c[E];
            C.copy(G),
            C.sub(T.multiplyScalar(T.dot(G))).normalize(),
            w.crossVectors(B, G);
            const te = w.dot(h[E]) < 0 ? -1 : 1;
            l[E * 4] = C.x,
            l[E * 4 + 1] = C.y,
            l[E * 4 + 2] = C.z,
            l[E * 4 + 3] = te
        }
        for (let E = 0, G = S.length; E < G; ++E) {
            const k = S[E]
              , te = k.start
              , O = k.count;
            for (let H = te, V = te + O; H < V; H += 3)
                b(i[H + 0]),
                b(i[H + 1]),
                b(i[H + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new cn(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let d = 0, f = i.count; d < f; d++)
                    i.setXYZ(d, 0, 0, 0);
            const n = new ee
              , r = new ee
              , o = new ee
              , a = new ee
              , l = new ee
              , c = new ee
              , h = new ee
              , u = new ee;
            if (e)
                for (let d = 0, f = e.count; d < f; d += 3) {
                    const m = e.getX(d + 0)
                      , _ = e.getX(d + 1)
                      , p = e.getX(d + 2);
                    n.fromBufferAttribute(t, m),
                    r.fromBufferAttribute(t, _),
                    o.fromBufferAttribute(t, p),
                    h.subVectors(o, r),
                    u.subVectors(n, r),
                    h.cross(u),
                    a.fromBufferAttribute(i, m),
                    l.fromBufferAttribute(i, _),
                    c.fromBufferAttribute(i, p),
                    a.add(h),
                    l.add(h),
                    c.add(h),
                    i.setXYZ(m, a.x, a.y, a.z),
                    i.setXYZ(_, l.x, l.y, l.z),
                    i.setXYZ(p, c.x, c.y, c.z)
                }
            else
                for (let d = 0, f = t.count; d < f; d += 3)
                    n.fromBufferAttribute(t, d + 0),
                    r.fromBufferAttribute(t, d + 1),
                    o.fromBufferAttribute(t, d + 2),
                    h.subVectors(o, r),
                    u.subVectors(n, r),
                    h.cross(u),
                    i.setXYZ(d + 0, h.x, h.y, h.z),
                    i.setXYZ(d + 1, h.x, h.y, h.z),
                    i.setXYZ(d + 2, h.x, h.y, h.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            ni.fromBufferAttribute(e, t),
            ni.normalize(),
            e.setXYZ(t, ni.x, ni.y, ni.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , h = a.itemSize
              , u = a.normalized
              , d = new c.constructor(l.length * h);
            let f = 0
              , m = 0;
            for (let _ = 0, p = l.length; _ < p; _++) {
                a.isInterleavedBufferAttribute ? f = l[_] * a.data.stride + a.offset : f = l[_] * h;
                for (let g = 0; g < h; g++)
                    d[m++] = c[f++]
            }
            return new cn(d,h,u)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new so
          , i = this.index.array
          , n = this.attributes;
        for (const a in n) {
            const l = n[a]
              , c = e(l, i);
            t.setAttribute(a, c)
        }
        const r = this.morphAttributes;
        for (const a in r) {
            const l = []
              , c = r[a];
            for (let h = 0, u = c.length; h < u; h++) {
                const d = c[h]
                  , f = e(d, i);
                l.push(f)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const n = {};
        let r = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , h = [];
            for (let u = 0, d = c.length; u < d; u++) {
                const f = c[u];
                h.push(f.toJSON(e.data))
            }
            h.length > 0 && (n[l] = h,
            r = !0)
        }
        r && (e.data.morphAttributes = n,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const n = e.attributes;
        for (const c in n) {
            const h = n[c];
            this.setAttribute(c, h.clone(t))
        }
        const r = e.morphAttributes;
        for (const c in r) {
            const h = []
              , u = r[c];
            for (let d = 0, f = u.length; d < f; d++)
                h.push(u[d].clone(t));
            this.morphAttributes[c] = h
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, h = o.length; c < h; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const vg = new vt
  , Ss = new Bh
  , Rc = new Jn
  , Mg = new ee
  , Do = new ee
  , Uo = new ee
  , No = new ee
  , Ku = new ee
  , Cc = new ee
  , Pc = new Xt
  , Lc = new Xt
  , Ic = new Xt
  , Sg = new ee
  , bg = new ee
  , Tg = new ee
  , Dc = new ee
  , Uc = new ee;
class kh extends qt {
    constructor(e=new so, t=new Yo) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, o = n.length; r < o; r++) {
                    const a = n[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , n = i.attributes.position
          , r = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(n, e);
        const a = this.morphTargetInfluences;
        if (r && a) {
            Cc.set(0, 0, 0);
            for (let l = 0, c = r.length; l < c; l++) {
                const h = a[l]
                  , u = r[l];
                h !== 0 && (Ku.fromBufferAttribute(u, e),
                o ? Cc.addScaledVector(Ku, h) : Cc.addScaledVector(Ku.sub(t), h))
            }
            t.add(Cc)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry
          , n = this.material
          , r = this.matrixWorld;
        n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        Rc.copy(i.boundingSphere),
        Rc.applyMatrix4(r),
        Ss.copy(e.ray).recast(e.near),
        !(Rc.containsPoint(Ss.origin) === !1 && (Ss.intersectSphere(Rc, Mg) === null || Ss.origin.distanceToSquared(Mg) > (e.far - e.near) ** 2)) && (vg.copy(r).invert(),
        Ss.copy(e.ray).applyMatrix4(vg),
        !(i.boundingBox !== null && Ss.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, Ss)))
    }
    _computeIntersections(e, t, i) {
        let n;
        const r = this.geometry
          , o = this.material
          , a = r.index
          , l = r.attributes.position
          , c = r.attributes.uv
          , h = r.attributes.uv1
          , u = r.attributes.normal
          , d = r.groups
          , f = r.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let m = 0, _ = d.length; m < _; m++) {
                    const p = d[m]
                      , g = o[p.materialIndex]
                      , M = Math.max(p.start, f.start)
                      , y = Math.min(a.count, Math.min(p.start + p.count, f.start + f.count));
                    for (let S = M, C = y; S < C; S += 3) {
                        const w = a.getX(S)
                          , T = a.getX(S + 1)
                          , B = a.getX(S + 2);
                        n = Nc(this, g, e, i, c, h, u, w, T, B),
                        n && (n.faceIndex = Math.floor(S / 3),
                        n.face.materialIndex = p.materialIndex,
                        t.push(n))
                    }
                }
            else {
                const m = Math.max(0, f.start)
                  , _ = Math.min(a.count, f.start + f.count);
                for (let p = m, g = _; p < g; p += 3) {
                    const M = a.getX(p)
                      , y = a.getX(p + 1)
                      , S = a.getX(p + 2);
                    n = Nc(this, o, e, i, c, h, u, M, y, S),
                    n && (n.faceIndex = Math.floor(p / 3),
                    t.push(n))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let m = 0, _ = d.length; m < _; m++) {
                    const p = d[m]
                      , g = o[p.materialIndex]
                      , M = Math.max(p.start, f.start)
                      , y = Math.min(l.count, Math.min(p.start + p.count, f.start + f.count));
                    for (let S = M, C = y; S < C; S += 3) {
                        const w = S
                          , T = S + 1
                          , B = S + 2;
                        n = Nc(this, g, e, i, c, h, u, w, T, B),
                        n && (n.faceIndex = Math.floor(S / 3),
                        n.face.materialIndex = p.materialIndex,
                        t.push(n))
                    }
                }
            else {
                const m = Math.max(0, f.start)
                  , _ = Math.min(l.count, f.start + f.count);
                for (let p = m, g = _; p < g; p += 3) {
                    const M = p
                      , y = p + 1
                      , S = p + 2;
                    n = Nc(this, o, e, i, c, h, u, M, y, S),
                    n && (n.faceIndex = Math.floor(p / 3),
                    t.push(n))
                }
            }
    }
}
function Ab(s, e, t, i, n, r, o, a) {
    let l;
    if (e.side === ES ? l = i.intersectTriangle(o, r, n, !0, a) : l = i.intersectTriangle(n, r, o, e.side === Ah, a),
    l === null)
        return null;
    Uc.copy(a),
    Uc.applyMatrix4(s.matrixWorld);
    const c = t.ray.origin.distanceTo(Uc);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: Uc.clone(),
        object: s
    }
}
function Nc(s, e, t, i, n, r, o, a, l, c) {
    s.getVertexPosition(a, Do),
    s.getVertexPosition(l, Uo),
    s.getVertexPosition(c, No);
    const h = Ab(s, e, t, i, Do, Uo, No, Dc);
    if (h) {
        n && (Pc.fromBufferAttribute(n, a),
        Lc.fromBufferAttribute(n, l),
        Ic.fromBufferAttribute(n, c),
        h.uv = Un.getInterpolation(Dc, Do, Uo, No, Pc, Lc, Ic, new Xt)),
        r && (Pc.fromBufferAttribute(r, a),
        Lc.fromBufferAttribute(r, l),
        Ic.fromBufferAttribute(r, c),
        h.uv1 = Un.getInterpolation(Dc, Do, Uo, No, Pc, Lc, Ic, new Xt),
        h.uv2 = h.uv1),
        o && (Sg.fromBufferAttribute(o, a),
        bg.fromBufferAttribute(o, l),
        Tg.fromBufferAttribute(o, c),
        h.normal = Un.getInterpolation(Dc, Do, Uo, No, Sg, bg, Tg, new ee),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
        const u = {
            a,
            b: l,
            c,
            normal: new ee,
            materialIndex: 0
        };
        Un.getNormal(Do, Uo, No, u.normal),
        h.face = u
    }
    return h
}
let Cx = class extends qt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new vt,
        this.projectionMatrix = new vt,
        this.projectionMatrixInverse = new vt,
        this.coordinateSystem = Os
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
  , jf = class extends Cx {
    constructor(e=50, t=1, i=.1, n=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = n,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Tl * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(rl * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Tl * 2 * Math.atan(Math.tan(rl * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, n, r, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = n,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(rl * .5 * this.fov) / this.zoom
          , i = 2 * t
          , n = this.aspect * i
          , r = -.5 * n;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            r += o.offsetX * n / l,
            t -= o.offsetY * i / c,
            n *= o.width / l,
            i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (r += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
;
const Ju = new ee
  , Rb = new ee
  , Cb = new Rr;
let Fo = class {
    constructor(e=new ee(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, n) {
        return this.normal.set(e, t, i),
        this.constant = n,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const n = Ju.subVectors(i, t).cross(Rb.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(Ju)
          , n = this.normal.dot(i);
        if (n === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / n;
        return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || Cb.getNormalMatrix(e)
          , n = this.coplanarPoint(Ju).applyMatrix4(e)
          , r = this.normal.applyMatrix3(i).normalize();
        return this.constant = -n.dot(r),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
const bs = new Jn
  , Fc = new ee;
let Pb = class {
    constructor(e=new Fo, t=new Fo, i=new Fo, n=new Fo, r=new Fo, o=new Fo) {
        this.planes = [e, t, i, n, r, o]
    }
    set(e, t, i, n, r, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(n),
        a[4].copy(r),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t=Os) {
        const i = this.planes
          , n = e.elements
          , r = n[0]
          , o = n[1]
          , a = n[2]
          , l = n[3]
          , c = n[4]
          , h = n[5]
          , u = n[6]
          , d = n[7]
          , f = n[8]
          , m = n[9]
          , _ = n[10]
          , p = n[11]
          , g = n[12]
          , M = n[13]
          , y = n[14]
          , S = n[15];
        if (i[0].setComponents(l - r, d - c, p - f, S - g).normalize(),
        i[1].setComponents(l + r, d + c, p + f, S + g).normalize(),
        i[2].setComponents(l + o, d + h, p + m, S + M).normalize(),
        i[3].setComponents(l - o, d - h, p - m, S - M).normalize(),
        i[4].setComponents(l - a, d - u, p - _, S - y).normalize(),
        t === Os)
            i[5].setComponents(l + a, d + u, p + _, S + y).normalize();
        else if (t === cf)
            i[5].setComponents(a, u, _, y).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            bs.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            bs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(bs)
    }
    intersectsSprite(e) {
        return bs.center.set(0, 0, 0),
        bs.radius = .7071067811865476,
        bs.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(bs)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , n = -e.radius;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(i) < n)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const n = t[i];
            if (Fc.x = n.normal.x > 0 ? e.max.x : e.min.x,
            Fc.y = n.normal.y > 0 ? e.max.y : e.min.y,
            Fc.z = n.normal.z > 0 ? e.max.z : e.min.z,
            n.distanceToPoint(Fc) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
  , Px = class extends Cx {
    constructor(e=-1, t=1, i=1, n=-1, r=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = n,
        this.near = r,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, n, r, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = n,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , n = (this.top + this.bottom) / 2;
        let r = i - e
          , o = i + e
          , a = n + t
          , l = n - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += c * this.view.offsetX,
            o = r + c * this.view.width,
            a -= h * this.view.offsetY,
            l = a - h * this.view.height
        }
        this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
  , Lb = class extends bn {
    constructor(e, t, i, n, r, o, a, l, c, h) {
        if (h = h !== void 0 ? h : Iu,
        h !== Iu && h !== Qm)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && h === Iu && (i = DS),
        i === void 0 && h === Qm && (i = US),
        super(null, n, r, o, a, l, h, i, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Sl,
        this.minFilter = l !== void 0 ? l : Sl,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
;
const Ib = new Lb(1,1);
Ib.compareFunction = HS;
let Qu = class extends qt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
;
class Db {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = lf,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.version = 0,
        this.uuid = Bn()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.stride,
        i *= t.stride;
        for (let n = 0, r = this.stride; n < r; n++)
            this.array[e + n] = t.array[i + n];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Bn()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , i = new this.constructor(t,this.stride);
        return i.setUsage(this.usage),
        i
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Bn()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const Ei = new ee;
class Zf {
    constructor(e, t, i, n=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = n
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
            Ei.fromBufferAttribute(this, t),
            Ei.applyMatrix4(e),
            this.setXYZ(t, Ei.x, Ei.y, Ei.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Ei.fromBufferAttribute(this, t),
            Ei.applyNormalMatrix(e),
            this.setXYZ(t, Ei.x, Ei.y, Ei.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Ei.fromBufferAttribute(this, t),
            Ei.transformDirection(e),
            this.setXYZ(t, Ei.x, Ei.y, Ei.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = Et(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = Et(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = Et(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = Et(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Wn(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Wn(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Wn(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Wn(t, this.array)),
        t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Et(t, this.array),
        i = Et(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, n) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Et(t, this.array),
        i = Et(i, this.array),
        n = Et(n, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = n,
        this
    }
    setXYZW(e, t, i, n, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = Et(t, this.array),
        i = Et(i, this.array),
        n = Et(n, this.array),
        r = Et(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = n,
        this.data.array[e + 3] = r,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const n = i * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++)
                    t.push(this.data.array[n + r])
            }
            return new cn(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Zf(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const n = i * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++)
                    t.push(this.data.array[n + r])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
const Eg = new ee
  , wg = new Hn
  , Ag = new Hn
  , Ub = new ee
  , Rg = new vt
  , Oc = new ee
  , ed = new Jn
  , Cg = new vt
  , td = new Bh;
class Nb extends kh {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = Jm,
        this.bindMatrix = new vt,
        this.bindMatrixInverse = new vt,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Cr),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, Oc),
            this.boundingBox.expandByPoint(Oc)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new Jn),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, Oc),
            this.boundingSphere.expandByPoint(Oc)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const i = this.material
          , n = this.matrixWorld;
        i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        ed.copy(this.boundingSphere),
        ed.applyMatrix4(n),
        e.ray.intersectsSphere(ed) !== !1 && (Cg.copy(n).invert(),
        td.copy(e.ray).applyMatrix4(Cg),
        !(this.boundingBox !== null && td.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, td)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Hn
          , t = this.geometry.attributes.skinWeight;
        for (let i = 0, n = t.count; i < n; i++) {
            e.fromBufferAttribute(t, i);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
            t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === Jm ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === RS ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const i = this.skeleton
          , n = this.geometry;
        wg.fromBufferAttribute(n.attributes.skinIndex, e),
        Ag.fromBufferAttribute(n.attributes.skinWeight, e),
        Eg.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let r = 0; r < 4; r++) {
            const o = Ag.getComponent(r);
            if (o !== 0) {
                const a = wg.getComponent(r);
                Rg.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
                t.addScaledVector(Ub.copy(Eg).applyMatrix4(Rg), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
    boneTransform(e, t) {
        return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
        this.applyBoneTransform(e, t)
    }
}
class Lx extends qt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Ix extends bn {
    constructor(e=null, t=1, i=1, n, r, o, a, l, c=Sl, h=Sl, u, d) {
        super(null, o, a, l, c, h, n, r, u, d),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const Pg = new vt
  , Fb = new vt;
class Kf {
    constructor(e=[], t=[]) {
        this.uuid = Bn(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let i = 0, n = this.bones.length; i < n; i++)
                this.boneInverses.push(new vt)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new vt;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , i = this.boneMatrices
          , n = this.boneTexture;
        for (let r = 0, o = e.length; r < o; r++) {
            const a = e[r] ? e[r].matrixWorld : Fb;
            Pg.multiplyMatrices(a, t[r]),
            Pg.toArray(i, r * 16)
        }
        n !== null && (n.needsUpdate = !0)
    }
    clone() {
        return new Kf(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new Ix(t,e,e,qf,il);
        return i.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = i,
        this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const n = this.bones[t];
            if (n.name === e)
                return n
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, n = e.bones.length; i < n; i++) {
            const r = e.bones[i];
            let o = t[r];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r),
            o = new Lx),
            this.bones.push(o),
            this.boneInverses.push(new vt().fromArray(e.boneInverses[i]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , i = this.boneInverses;
        for (let n = 0, r = t.length; n < r; n++) {
            const o = t[n];
            e.bones.push(o.uuid);
            const a = i[n];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class uf extends cn {
    constructor(e, t, i, n=1) {
        super(e, t, i),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = n
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const Oo = new vt
  , Lg = new vt
  , Bc = []
  , Ig = new Cr
  , Ob = new vt
  , Na = new kh
  , Fa = new Jn;
class Bb extends kh {
    constructor(e, t, i) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new uf(new Float32Array(i * 16),16),
        this.instanceColor = null,
        this.count = i,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let n = 0; n < i; n++)
            this.setMatrixAt(n, Ob)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new Cr),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Oo),
            Ig.copy(e.boundingBox).applyMatrix4(Oo),
            this.boundingBox.union(Ig)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new Jn),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Oo),
            Fa.copy(e.boundingSphere).applyMatrix4(Oo),
            this.boundingSphere.union(Fa)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const i = this.matrixWorld
          , n = this.count;
        if (Na.geometry = this.geometry,
        Na.material = this.material,
        Na.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        Fa.copy(this.boundingSphere),
        Fa.applyMatrix4(i),
        e.ray.intersectsSphere(Fa) !== !1))
            for (let r = 0; r < n; r++) {
                this.getMatrixAt(r, Oo),
                Lg.multiplyMatrices(i, Oo),
                Na.matrixWorld = Lg,
                Na.raycast(e, Bc);
                for (let o = 0, a = Bc.length; o < a; o++) {
                    const l = Bc[o];
                    l.instanceId = r,
                    l.object = this,
                    t.push(l)
                }
                Bc.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new uf(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Dx extends Zs {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Jt(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Dg = new ee
  , Ug = new ee
  , Ng = new vt
  , id = new Bh
  , zc = new Jn;
class Jf extends qt {
    constructor(e=new so, t=new Dx) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [0];
            for (let n = 1, r = t.count; n < r; n++)
                Dg.fromBufferAttribute(t, n - 1),
                Ug.fromBufferAttribute(t, n),
                i[n] = i[n - 1],
                i[n] += Dg.distanceTo(Ug);
            e.setAttribute("lineDistance", new $f(i,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry
          , n = this.matrixWorld
          , r = e.params.Line.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        zc.copy(i.boundingSphere),
        zc.applyMatrix4(n),
        zc.radius += r,
        e.ray.intersectsSphere(zc) === !1)
            return;
        Ng.copy(n).invert(),
        id.copy(e.ray).applyMatrix4(Ng);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = new ee
          , h = new ee
          , u = new ee
          , d = new ee
          , f = this.isLineSegments ? 2 : 1
          , m = i.index
          , p = i.attributes.position;
        if (m !== null) {
            const g = Math.max(0, o.start)
              , M = Math.min(m.count, o.start + o.count);
            for (let y = g, S = M - 1; y < S; y += f) {
                const C = m.getX(y)
                  , w = m.getX(y + 1);
                if (c.fromBufferAttribute(p, C),
                h.fromBufferAttribute(p, w),
                id.distanceSqToSegment(c, h, d, u) > l)
                    continue;
                d.applyMatrix4(this.matrixWorld);
                const B = e.ray.origin.distanceTo(d);
                B < e.near || B > e.far || t.push({
                    distance: B,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: y,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const g = Math.max(0, o.start)
              , M = Math.min(p.count, o.start + o.count);
            for (let y = g, S = M - 1; y < S; y += f) {
                if (c.fromBufferAttribute(p, y),
                h.fromBufferAttribute(p, y + 1),
                id.distanceSqToSegment(c, h, d, u) > l)
                    continue;
                d.applyMatrix4(this.matrixWorld);
                const w = e.ray.origin.distanceTo(d);
                w < e.near || w > e.far || t.push({
                    distance: w,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: y,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, o = n.length; r < o; r++) {
                    const a = n[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}
const Fg = new ee
  , Og = new ee;
class zb extends Jf {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [];
            for (let n = 0, r = t.count; n < r; n += 2)
                Fg.fromBufferAttribute(t, n),
                Og.fromBufferAttribute(t, n + 1),
                i[n] = n === 0 ? 0 : i[n - 1],
                i[n + 1] = i[n] + Fg.distanceTo(Og);
            e.setAttribute("lineDistance", new $f(i,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class kb extends Jf {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class Ux extends Zs {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Jt(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const Bg = new vt
  , df = new Bh
  , kc = new Jn
  , Hc = new ee;
class Hb extends qt {
    constructor(e=new so, t=new Ux) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const i = this.geometry
          , n = this.matrixWorld
          , r = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        kc.copy(i.boundingSphere),
        kc.applyMatrix4(n),
        kc.radius += r,
        e.ray.intersectsSphere(kc) === !1)
            return;
        Bg.copy(n).invert(),
        df.copy(e.ray).applyMatrix4(Bg);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = i.index
          , u = i.attributes.position;
        if (c !== null) {
            const d = Math.max(0, o.start)
              , f = Math.min(c.count, o.start + o.count);
            for (let m = d, _ = f; m < _; m++) {
                const p = c.getX(m);
                Hc.fromBufferAttribute(u, p),
                zg(Hc, p, l, n, e, t, this)
            }
        } else {
            const d = Math.max(0, o.start)
              , f = Math.min(u.count, o.start + o.count);
            for (let m = d, _ = f; m < _; m++)
                Hc.fromBufferAttribute(u, m),
                zg(Hc, m, l, n, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, o = n.length; r < o; r++) {
                    const a = n[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}
function zg(s, e, t, i, n, r, o) {
    const a = df.distanceSqToPoint(s);
    if (a < t) {
        const l = new ee;
        df.closestPointToPoint(s, l),
        l.applyMatrix4(i);
        const c = n.ray.origin.distanceTo(l);
        if (c < n.near || c > n.far)
            return;
        r.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class Qf extends Zs {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Jt(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Jt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = zS,
        this.normalScale = new Xt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Pr extends Qf {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new Xt(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return di(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Jt(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Jt(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Jt(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
function Gc(s, e, t) {
    return !s || !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s)
}
function Gb(s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView)
}
function Vb(s) {
    function e(n, r) {
        return s[n] - s[r]
    }
    const t = s.length
      , i = new Array(t);
    for (let n = 0; n !== t; ++n)
        i[n] = n;
    return i.sort(e),
    i
}
function kg(s, e, t) {
    const i = s.length
      , n = new s.constructor(i);
    for (let r = 0, o = 0; o !== i; ++r) {
        const a = t[r] * e;
        for (let l = 0; l !== e; ++l)
            n[o++] = s[a + l]
    }
    return n
}
function Nx(s, e, t, i) {
    let n = 1
      , r = s[0];
    for (; r !== void 0 && r[i] === void 0; )
        r = s[n++];
    if (r === void 0)
        return;
    let o = r[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = r[i],
                o !== void 0 && (e.push(r.time),
                t.push.apply(t, o)),
                r = s[n++];
            while (r !== void 0);
        else if (o.toArray !== void 0)
            do
                o = r[i],
                o !== void 0 && (e.push(r.time),
                o.toArray(t, t.length)),
                r = s[n++];
            while (r !== void 0);
        else
            do
                o = r[i],
                o !== void 0 && (e.push(r.time),
                t.push(o)),
                r = s[n++];
            while (r !== void 0)
}
class Il {
    constructor(e, t, i, n) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = n !== void 0 ? n : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex
          , n = t[i]
          , r = t[i - 1];
        i: {
            e: {
                let o;
                t: {
                    n: if (!(e < n)) {
                        for (let a = i + 2; ; ) {
                            if (n === void 0) {
                                if (e < r)
                                    break n;
                                return i = t.length,
                                this._cachedIndex = i,
                                this.copySampleValue_(i - 1)
                            }
                            if (i === a)
                                break;
                            if (r = n,
                            n = t[++i],
                            e < n)
                                break e
                        }
                        o = t.length;
                        break t
                    }
                    if (!(e >= r)) {
                        const a = t[1];
                        e < a && (i = 2,
                        r = a);
                        for (let l = i - 2; ; ) {
                            if (r === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (i === l)
                                break;
                            if (n = r,
                            r = t[--i - 1],
                            e >= r)
                                break e
                        }
                        o = i,
                        i = 0;
                        break t
                    }
                    break i
                }
                for (; i < o; ) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (n = t[i],
                r = t[i - 1],
                r === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (n === void 0)
                    return i = t.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, r, n)
        }
        return this.interpolate_(i, r, e, n)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , n = this.valueSize
          , r = e * n;
        for (let o = 0; o !== n; ++o)
            t[o] = i[r + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class Wb extends Il {
    constructor(e, t, i, n) {
        super(e, t, i, n),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: eg,
            endingEnd: eg
        }
    }
    intervalChanged_(e, t, i) {
        const n = this.parameterPositions;
        let r = e - 2
          , o = e + 1
          , a = n[r]
          , l = n[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case tg:
                r = e,
                a = 2 * t - i;
                break;
            case ig:
                r = n.length - 2,
                a = t + n[r] - n[r + 1];
                break;
            default:
                r = e,
                a = i
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case tg:
                o = e,
                l = 2 * i - t;
                break;
            case ig:
                o = 1,
                l = i + n[1] - n[0];
                break;
            default:
                o = e - 1,
                l = t
            }
        const c = (i - t) * .5
          , h = this.valueSize;
        this._weightPrev = c / (t - a),
        this._weightNext = c / (l - i),
        this._offsetPrev = r * h,
        this._offsetNext = o * h
    }
    interpolate_(e, t, i, n) {
        const r = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , h = this._offsetPrev
          , u = this._offsetNext
          , d = this._weightPrev
          , f = this._weightNext
          , m = (i - t) / (n - t)
          , _ = m * m
          , p = _ * m
          , g = -d * p + 2 * d * _ - d * m
          , M = (1 + d) * p + (-1.5 - 2 * d) * _ + (-.5 + d) * m + 1
          , y = (-1 - f) * p + (1.5 + f) * _ + .5 * m
          , S = f * p - f * _;
        for (let C = 0; C !== a; ++C)
            r[C] = g * o[h + C] + M * o[c + C] + y * o[l + C] + S * o[u + C];
        return r
    }
}
class Xb extends Il {
    constructor(e, t, i, n) {
        super(e, t, i, n)
    }
    interpolate_(e, t, i, n) {
        const r = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , h = (i - t) / (n - t)
          , u = 1 - h;
        for (let d = 0; d !== a; ++d)
            r[d] = o[c + d] * u + o[l + d] * h;
        return r
    }
}
class qb extends Il {
    constructor(e, t, i, n) {
        super(e, t, i, n)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class Qn {
    constructor(e, t, i, n) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Gc(t, this.TimeBufferType),
        this.values = Gc(i, this.ValueBufferType),
        this.setInterpolation(n || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON)
            i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: Gc(e.times, Array),
                values: Gc(e.values, Array)
            };
            const n = e.getInterpolation();
            n !== e.DefaultInterpolation && (i.interpolation = n)
        }
        return i.type = e.ValueTypeName,
        i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new qb(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new Xb(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new Wb(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case bl:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case ga:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case Du:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return bl;
        case this.InterpolantFactoryMethodLinear:
            return ga;
        case this.InterpolantFactoryMethodSmooth:
            return Du
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, n = t.length; i !== n; ++i)
                t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, n = t.length; i !== n; ++i)
                t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times
          , n = i.length;
        let r = 0
          , o = n - 1;
        for (; r !== n && i[r] < e; )
            ++r;
        for (; o !== -1 && i[o] > t; )
            --o;
        if (++o,
        r !== 0 || o !== n) {
            r >= o && (o = Math.max(o, 1),
            r = o - 1);
            const a = this.getValueSize();
            this.times = i.slice(r, o),
            this.values = this.values.slice(r * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const i = this.times
          , n = this.values
          , r = i.length;
        r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== r; a++) {
            const l = i[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                e = !1;
                break
            }
            o = l
        }
        if (n !== void 0 && Gb(n))
            for (let a = 0, l = n.length; a !== l; ++a) {
                const c = n[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , i = this.getValueSize()
          , n = this.getInterpolation() === Du
          , r = e.length - 1;
        let o = 1;
        for (let a = 1; a < r; ++a) {
            let l = !1;
            const c = e[a]
              , h = e[a + 1];
            if (c !== h && (a !== 1 || c !== e[0]))
                if (n)
                    l = !0;
                else {
                    const u = a * i
                      , d = u - i
                      , f = u + i;
                    for (let m = 0; m !== i; ++m) {
                        const _ = t[u + m];
                        if (_ !== t[d + m] || _ !== t[f + m]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const u = a * i
                      , d = o * i;
                    for (let f = 0; f !== i; ++f)
                        t[d + f] = t[u + f]
                }
                ++o
            }
        }
        if (r > 0) {
            e[o] = e[r];
            for (let a = r * i, l = o * i, c = 0; c !== i; ++c)
                t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o),
        this.values = t.slice(0, o * i)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , i = this.constructor
          , n = new i(this.name,e,t);
        return n.createInterpolant = this.createInterpolant,
        n
    }
}
Qn.prototype.TimeBufferType = Float32Array;
Qn.prototype.ValueBufferType = Float32Array;
Qn.prototype.DefaultInterpolation = ga;
class va extends Qn {
}
va.prototype.ValueTypeName = "bool";
va.prototype.ValueBufferType = Array;
va.prototype.DefaultInterpolation = bl;
va.prototype.InterpolantFactoryMethodLinear = void 0;
va.prototype.InterpolantFactoryMethodSmooth = void 0;
class Fx extends Qn {
}
Fx.prototype.ValueTypeName = "color";
class _a extends Qn {
}
_a.prototype.ValueTypeName = "number";
class Yb extends Il {
    constructor(e, t, i, n) {
        super(e, t, i, n)
    }
    interpolate_(e, t, i, n) {
        const r = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = (i - t) / (n - t);
        let c = e * a;
        for (let h = c + a; c !== h; c += 4)
            fs.slerpFlat(r, 0, o, c - a, o, c, l);
        return r
    }
}
class io extends Qn {
    InterpolantFactoryMethodLinear(e) {
        return new Yb(this.times,this.values,this.getValueSize(),e)
    }
}
io.prototype.ValueTypeName = "quaternion";
io.prototype.DefaultInterpolation = ga;
io.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ma extends Qn {
}
Ma.prototype.ValueTypeName = "string";
Ma.prototype.ValueBufferType = Array;
Ma.prototype.DefaultInterpolation = bl;
Ma.prototype.InterpolantFactoryMethodLinear = void 0;
Ma.prototype.InterpolantFactoryMethodSmooth = void 0;
class xa extends Qn {
}
xa.prototype.ValueTypeName = "vector";
class $b {
    constructor(e, t=-1, i, n=FS) {
        this.name = e,
        this.tracks = i,
        this.duration = t,
        this.blendMode = n,
        this.uuid = Bn(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , i = e.tracks
          , n = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o)
            t.push(Zb(i[o]).scale(n));
        const r = new this(e.name,e.duration,t,e.blendMode);
        return r.uuid = e.uuid,
        r
    }
    static toJSON(e) {
        const t = []
          , i = e.tracks
          , n = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let r = 0, o = i.length; r !== o; ++r)
            t.push(Qn.toJSON(i[r]));
        return n
    }
    static CreateFromMorphTargetSequence(e, t, i, n) {
        const r = t.length
          , o = [];
        for (let a = 0; a < r; a++) {
            let l = []
              , c = [];
            l.push((a + r - 1) % r, a, (a + 1) % r),
            c.push(0, 1, 0);
            const h = Vb(l);
            l = kg(l, 1, h),
            c = kg(c, 1, h),
            !n && l[0] === 0 && (l.push(r),
            c.push(c[0])),
            o.push(new _a(".morphTargetInfluences[" + t[a].name + "]",l,c).scale(1 / i))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const n = e;
            i = n.geometry && n.geometry.animations || n.animations
        }
        for (let n = 0; n < i.length; n++)
            if (i[n].name === t)
                return i[n];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const n = {}
          , r = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , h = c.name.match(r);
            if (h && h.length > 1) {
                const u = h[1];
                let d = n[u];
                d || (n[u] = d = []),
                d.push(c)
            }
        }
        const o = [];
        for (const a in n)
            o.push(this.CreateFromMorphTargetSequence(a, n[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const i = function(u, d, f, m, _) {
            if (f.length !== 0) {
                const p = []
                  , g = [];
                Nx(f, p, g, m),
                p.length !== 0 && _.push(new u(d,p,g))
            }
        }
          , n = []
          , r = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let u = 0; u < c.length; u++) {
            const d = c[u].keys;
            if (!(!d || d.length === 0))
                if (d[0].morphTargets) {
                    const f = {};
                    let m;
                    for (m = 0; m < d.length; m++)
                        if (d[m].morphTargets)
                            for (let _ = 0; _ < d[m].morphTargets.length; _++)
                                f[d[m].morphTargets[_]] = -1;
                    for (const _ in f) {
                        const p = []
                          , g = [];
                        for (let M = 0; M !== d[m].morphTargets.length; ++M) {
                            const y = d[m];
                            p.push(y.time),
                            g.push(y.morphTarget === _ ? 1 : 0)
                        }
                        n.push(new _a(".morphTargetInfluence[" + _ + "]",p,g))
                    }
                    l = f.length * o
                } else {
                    const f = ".bones[" + t[u].name + "]";
                    i(xa, f + ".position", d, "pos", n),
                    i(io, f + ".quaternion", d, "rot", n),
                    i(xa, f + ".scale", d, "scl", n)
                }
        }
        return n.length === 0 ? null : new this(r,l,n,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, n = e.length; i !== n; ++i) {
            const r = this.tracks[i];
            t = Math.max(t, r.times[r.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function jb(s) {
    switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return _a;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return xa;
    case "color":
        return Fx;
    case "quaternion":
        return io;
    case "bool":
    case "boolean":
        return va;
    case "string":
        return Ma
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s)
}
function Zb(s) {
    if (s.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = jb(s.type);
    if (s.times === void 0) {
        const t = []
          , i = [];
        Nx(s.keys, t, i, "value"),
        s.times = t,
        s.values = i
    }
    return e.parse !== void 0 ? e.parse(s) : new e(s.name,s.times,s.values,s.interpolation)
}
const Qr = {
    enabled: !1,
    files: {},
    add: function(s, e) {
        this.enabled !== !1 && (this.files[s] = e)
    },
    get: function(s) {
        if (this.enabled !== !1)
            return this.files[s]
    },
    remove: function(s) {
        delete this.files[s]
    },
    clear: function() {
        this.files = {}
    }
};
class Kb {
    constructor(e, t, i) {
        const n = this;
        let r = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(h) {
            a++,
            r === !1 && n.onStart !== void 0 && n.onStart(h, o, a),
            r = !0
        }
        ,
        this.itemEnd = function(h) {
            o++,
            n.onProgress !== void 0 && n.onProgress(h, o, a),
            o === a && (r = !1,
            n.onLoad !== void 0 && n.onLoad())
        }
        ,
        this.itemError = function(h) {
            n.onError !== void 0 && n.onError(h)
        }
        ,
        this.resolveURL = function(h) {
            return l ? l(h) : h
        }
        ,
        this.setURLModifier = function(h) {
            return l = h,
            this
        }
        ,
        this.addHandler = function(h, u) {
            return c.push(h, u),
            this
        }
        ,
        this.removeHandler = function(h) {
            const u = c.indexOf(h);
            return u !== -1 && c.splice(u, 2),
            this
        }
        ,
        this.getHandler = function(h) {
            for (let u = 0, d = c.length; u < d; u += 2) {
                const f = c[u]
                  , m = c[u + 1];
                if (f.global && (f.lastIndex = 0),
                f.test(h))
                    return m
            }
            return null
        }
    }
}
const Jb = new Kb;
class ps {
    constructor(e) {
        this.manager = e !== void 0 ? e : Jb,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(n, r) {
            i.load(e, n, t, r)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
ps.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const ur = {};
class Qb extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class El extends ps {
    constructor(e) {
        super(e)
    }
    load(e, t, i, n) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = Qr.get(e);
        if (r !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(r),
                this.manager.itemEnd(e)
            }
            , 0),
            r;
        if (ur[e] !== void 0) {
            ur[e].push({
                onLoad: t,
                onProgress: i,
                onError: n
            });
            return
        }
        ur[e] = [],
        ur[e].push({
            onLoad: t,
            onProgress: i,
            onError: n
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                    return c;
                const h = ur[e]
                  , u = c.body.getReader()
                  , d = c.headers.get("Content-Length") || c.headers.get("X-File-Size")
                  , f = d ? parseInt(d) : 0
                  , m = f !== 0;
                let _ = 0;
                const p = new ReadableStream({
                    start(g) {
                        M();
                        function M() {
                            u.read().then( ({done: y, value: S}) => {
                                if (y)
                                    g.close();
                                else {
                                    _ += S.byteLength;
                                    const C = new ProgressEvent("progress",{
                                        lengthComputable: m,
                                        loaded: _,
                                        total: f
                                    });
                                    for (let w = 0, T = h.length; w < T; w++) {
                                        const B = h[w];
                                        B.onProgress && B.onProgress(C)
                                    }
                                    g.enqueue(S),
                                    M()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(p)
            } else
                throw new Qb(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)
        }
        ).then(c => {
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(h => new DOMParser().parseFromString(h, a));
            case "json":
                return c.json();
            default:
                if (a === void 0)
                    return c.text();
                {
                    const u = /charset="?([^;"\s]*)"?/i.exec(a)
                      , d = u && u[1] ? u[1].toLowerCase() : void 0
                      , f = new TextDecoder(d);
                    return c.arrayBuffer().then(m => f.decode(m))
                }
            }
        }
        ).then(c => {
            Qr.add(e, c);
            const h = ur[e];
            delete ur[e];
            for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onLoad && f.onLoad(c)
            }
        }
        ).catch(c => {
            const h = ur[e];
            if (h === void 0)
                throw this.manager.itemError(e),
                c;
            delete ur[e];
            for (let u = 0, d = h.length; u < d; u++) {
                const f = h[u];
                f.onError && f.onError(c)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class e1 extends ps {
    constructor(e) {
        super(e)
    }
    load(e, t, i, n) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , o = Qr.get(e);
        if (o !== void 0)
            return r.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                r.manager.itemEnd(e)
            }, 0),
            o;
        const a = hf("img");
        function l() {
            h(),
            Qr.add(e, this),
            t && t(this),
            r.manager.itemEnd(e)
        }
        function c(u) {
            h(),
            n && n(u),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
        function h() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        r.manager.itemStart(e),
        a.src = e,
        a
    }
}
class t1 extends ps {
    constructor(e) {
        super(e)
    }
    load(e, t, i, n) {
        const r = this
          , o = new Ix
          , a = new El(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(r.withCredentials),
        a.load(e, function(l) {
            let c;
            try {
                c = r.parse(l)
            } catch (h) {
                if (n !== void 0)
                    n(h);
                else {
                    console.error(h);
                    return
                }
            }
            c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width,
            o.image.height = c.height,
            o.image.data = c.data),
            o.wrapS = c.wrapS !== void 0 ? c.wrapS : Fs,
            o.wrapT = c.wrapT !== void 0 ? c.wrapT : Fs,
            o.magFilter = c.magFilter !== void 0 ? c.magFilter : as,
            o.minFilter = c.minFilter !== void 0 ? c.minFilter : as,
            o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1,
            c.colorSpace !== void 0 ? o.colorSpace = c.colorSpace : c.encoding !== void 0 && (o.encoding = c.encoding),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps,
            o.minFilter = Fh),
            c.mipmapCount === 1 && (o.minFilter = as),
            c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, c)
        }, i, n),
        o
    }
}
class i1 extends ps {
    constructor(e) {
        super(e)
    }
    load(e, t, i, n) {
        const r = new bn
          , o = new e1(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            r.image = a,
            r.needsUpdate = !0,
            t !== void 0 && t(r)
        }, i, n),
        r
    }
}
class ep extends qt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Jt(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
const nd = new vt
  , Hg = new ee
  , Gg = new ee;
class tp {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Xt(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new vt,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Pb,
        this._frameExtents = new Xt(1,1),
        this._viewportCount = 1,
        this._viewports = [new Hn(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , i = this.matrix;
        Hg.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(Hg),
        Gg.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(Gg),
        t.updateMatrixWorld(),
        nd.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(nd),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(nd)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class n1 extends tp {
    constructor() {
        super(new jf(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , i = Tl * 2 * e.angle * this.focus
          , n = this.mapSize.width / this.mapSize.height
          , r = e.distance || t.far;
        (i !== t.fov || n !== t.aspect || r !== t.far) && (t.fov = i,
        t.aspect = n,
        t.far = r,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class r1 extends ep {
    constructor(e, t, i=0, n=Math.PI / 3, r=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(qt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new qt,
        this.distance = i,
        this.angle = n,
        this.penumbra = r,
        this.decay = o,
        this.map = null,
        this.shadow = new n1
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const Vg = new vt
  , Oa = new ee
  , rd = new ee;
class s1 extends tp {
    constructor() {
        super(new jf(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new Xt(4,2),
        this._viewportCount = 6,
        this._viewports = [new Hn(2,1,1,1), new Hn(0,1,1,1), new Hn(3,1,1,1), new Hn(1,1,1,1), new Hn(3,0,1,1), new Hn(1,0,1,1)],
        this._cubeDirections = [new ee(1,0,0), new ee(-1,0,0), new ee(0,0,1), new ee(0,0,-1), new ee(0,1,0), new ee(0,-1,0)],
        this._cubeUps = [new ee(0,1,0), new ee(0,1,0), new ee(0,1,0), new ee(0,1,0), new ee(0,0,1), new ee(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const i = this.camera
          , n = this.matrix
          , r = e.distance || i.far;
        r !== i.far && (i.far = r,
        i.updateProjectionMatrix()),
        Oa.setFromMatrixPosition(e.matrixWorld),
        i.position.copy(Oa),
        rd.copy(i.position),
        rd.add(this._cubeDirections[t]),
        i.up.copy(this._cubeUps[t]),
        i.lookAt(rd),
        i.updateMatrixWorld(),
        n.makeTranslation(-Oa.x, -Oa.y, -Oa.z),
        Vg.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Vg)
    }
}
class o1 extends ep {
    constructor(e, t, i=0, n=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = i,
        this.decay = n,
        this.shadow = new s1
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class a1 extends tp {
    constructor() {
        super(new Px(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class l1 extends ep {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(qt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new qt,
        this.shadow = new a1
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class ol {
    static decodeText(e) {
        if (typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, n = e.length; i < n; i++)
            t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class c1 extends ps {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, i, n) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , o = Qr.get(e);
        if (o !== void 0) {
            if (r.manager.itemStart(e),
            o.then) {
                o.then(c => {
                    t && t(c),
                    r.manager.itemEnd(e)
                }
                ).catch(c => {
                    n && n(c)
                }
                );
                return
            }
            return setTimeout(function() {
                t && t(o),
                r.manager.itemEnd(e)
            }, 0),
            o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader;
        const l = fetch(e, a).then(function(c) {
            return c.blob()
        }).then(function(c) {
            return createImageBitmap(c, Object.assign(r.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(c) {
            return Qr.add(e, c),
            t && t(c),
            r.manager.itemEnd(e),
            c
        }).catch(function(c) {
            n && n(c),
            Qr.remove(e),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        });
        Qr.add(e, l),
        r.manager.itemStart(e)
    }
}
const ip = "\\[\\]\\.:\\/"
  , h1 = new RegExp("[" + ip + "]","g")
  , np = "[^" + ip + "]"
  , u1 = "[^" + ip.replace("\\.", "") + "]"
  , d1 = /((?:WC+[\/:])*)/.source.replace("WC", np)
  , f1 = /(WCOD+)?/.source.replace("WCOD", u1)
  , p1 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", np)
  , m1 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", np)
  , g1 = new RegExp("^" + d1 + f1 + p1 + m1 + "$")
  , _1 = ["material", "materials", "bones", "map"];
class x1 {
    constructor(e, t, i) {
        const n = i || Tt.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, n)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_
          , n = this._bindings[i];
        n !== void 0 && n.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
            i[n].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].unbind()
    }
}
class Tt {
    constructor(e, t, i) {
        this.path = t,
        this.parsedPath = i || Tt.parseTrackName(t),
        this.node = Tt.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new Tt.Composite(e,t,i) : new Tt(e,t,i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(h1, "")
    }
    static parseTrackName(e) {
        const t = g1.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , n = i.nodeName && i.nodeName.lastIndexOf(".");
        if (n !== void 0 && n !== -1) {
            const r = i.nodeName.substring(n + 1);
            _1.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, n),
            i.objectName = r)
        }
        if (i.propertyName === null || i.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0)
                return i
        }
        if (e.children) {
            const i = function(r) {
                for (let o = 0; o < r.length; o++) {
                    const a = r[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = i(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , n = i(e.children);
            if (n)
                return n
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n)
            e[t++] = i[n]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n)
            i[n] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n)
            i[n] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, r = i.length; n !== r; ++n)
            i[n] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , i = t.objectName
          , n = t.propertyName;
        let r = t.propertyIndex;
        if (e || (e = Tt.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (i) {
            let c = t.objectIndex;
            switch (i) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++)
                    if (e[h].name === c) {
                        c = h;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[i] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[i]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[n];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (r !== void 0) {
            if (n === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = r
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = n;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
Tt.Composite = x1;
Tt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Tt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Tt.prototype.GetterByBindingType = [Tt.prototype._getValue_direct, Tt.prototype._getValue_array, Tt.prototype._getValue_arrayElement, Tt.prototype._getValue_toArray];
Tt.prototype.SetterByBindingTypeAndVersioning = [[Tt.prototype._setValue_direct, Tt.prototype._setValue_direct_setNeedsUpdate, Tt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Tt.prototype._setValue_array, Tt.prototype._setValue_array_setNeedsUpdate, Tt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Tt.prototype._setValue_arrayElement, Tt.prototype._setValue_arrayElement_setNeedsUpdate, Tt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Tt.prototype._setValue_fromArray, Tt.prototype._setValue_fromArray_setNeedsUpdate, Tt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: bx
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = bx);
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var Wg = function(s) {
    return URL.createObjectURL(new Blob([s],{
        type: "text/javascript"
    }))
};
try {
    URL.revokeObjectURL(Wg(""))
} catch {
    Wg = function(e) {
        return "data:application/javascript;charset=UTF-8," + encodeURI(e)
    }
}
var yn = Uint8Array
  , es = Uint16Array
  , ff = Uint32Array
  , Ox = new yn([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , Bx = new yn([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , y1 = new yn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , zx = function(s, e) {
    for (var t = new es(31), i = 0; i < 31; ++i)
        t[i] = e += 1 << s[i - 1];
    for (var n = new ff(t[30]), i = 1; i < 30; ++i)
        for (var r = t[i]; r < t[i + 1]; ++r)
            n[r] = r - t[i] << 5 | i;
    return [t, n]
}
  , kx = zx(Ox, 2)
  , Hx = kx[0]
  , v1 = kx[1];
Hx[28] = 258,
v1[258] = 28;
var M1 = zx(Bx, 0)
  , S1 = M1[0]
  , pf = new es(32768);
for (var Ut = 0; Ut < 32768; ++Ut) {
    var Gr = (Ut & 43690) >>> 1 | (Ut & 21845) << 1;
    Gr = (Gr & 52428) >>> 2 | (Gr & 13107) << 2,
    Gr = (Gr & 61680) >>> 4 | (Gr & 3855) << 4,
    pf[Ut] = ((Gr & 65280) >>> 8 | (Gr & 255) << 8) >>> 1
}
var al = function(s, e, t) {
    for (var i = s.length, n = 0, r = new es(e); n < i; ++n)
        ++r[s[n] - 1];
    var o = new es(e);
    for (n = 0; n < e; ++n)
        o[n] = o[n - 1] + r[n - 1] << 1;
    var a;
    if (t) {
        a = new es(1 << e);
        var l = 15 - e;
        for (n = 0; n < i; ++n)
            if (s[n])
                for (var c = n << 4 | s[n], h = e - s[n], u = o[s[n] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u)
                    a[pf[u] >>> l] = c
    } else
        for (a = new es(i),
        n = 0; n < i; ++n)
            s[n] && (a[n] = pf[o[s[n] - 1]++] >>> 15 - s[n]);
    return a
}
  , Dl = new yn(288);
for (var Ut = 0; Ut < 144; ++Ut)
    Dl[Ut] = 8;
for (var Ut = 144; Ut < 256; ++Ut)
    Dl[Ut] = 9;
for (var Ut = 256; Ut < 280; ++Ut)
    Dl[Ut] = 7;
for (var Ut = 280; Ut < 288; ++Ut)
    Dl[Ut] = 8;
var Gx = new yn(32);
for (var Ut = 0; Ut < 32; ++Ut)
    Gx[Ut] = 5;
var b1 = al(Dl, 9, 1)
  , T1 = al(Gx, 5, 1)
  , sd = function(s) {
    for (var e = s[0], t = 1; t < s.length; ++t)
        s[t] > e && (e = s[t]);
    return e
}
  , Ln = function(s, e, t) {
    var i = e / 8 | 0;
    return (s[i] | s[i + 1] << 8) >> (e & 7) & t
}
  , od = function(s, e) {
    var t = e / 8 | 0;
    return (s[t] | s[t + 1] << 8 | s[t + 2] << 16) >> (e & 7)
}
  , E1 = function(s) {
    return (s / 8 | 0) + (s & 7 && 1)
}
  , w1 = function(s, e, t) {
    (e == null || e < 0) && (e = 0),
    (t == null || t > s.length) && (t = s.length);
    var i = new (s instanceof es ? es : s instanceof ff ? ff : yn)(t - e);
    return i.set(s.subarray(e, t)),
    i
}
  , A1 = function(s, e, t) {
    var i = s.length;
    if (!i || t && !t.l && i < 5)
        return e || new yn(0);
    var n = !e || t
      , r = !t || t.i;
    t || (t = {}),
    e || (e = new yn(i * 3));
    var o = function(fe) {
        var ve = e.length;
        if (fe > ve) {
            var Ue = new yn(Math.max(ve * 2, fe));
            Ue.set(e),
            e = Ue
        }
    }
      , a = t.f || 0
      , l = t.p || 0
      , c = t.b || 0
      , h = t.l
      , u = t.d
      , d = t.m
      , f = t.n
      , m = i * 8;
    do {
        if (!h) {
            t.f = a = Ln(s, l, 1);
            var _ = Ln(s, l + 1, 3);
            if (l += 3,
            _)
                if (_ == 1)
                    h = b1,
                    u = T1,
                    d = 9,
                    f = 5;
                else if (_ == 2) {
                    var y = Ln(s, l, 31) + 257
                      , S = Ln(s, l + 10, 15) + 4
                      , C = y + Ln(s, l + 5, 31) + 1;
                    l += 14;
                    for (var w = new yn(C), T = new yn(19), B = 0; B < S; ++B)
                        T[y1[B]] = Ln(s, l + B * 3, 7);
                    l += S * 3;
                    for (var b = sd(T), E = (1 << b) - 1, G = al(T, b, 1), B = 0; B < C; ) {
                        var k = G[Ln(s, l, E)];
                        l += k & 15;
                        var p = k >>> 4;
                        if (p < 16)
                            w[B++] = p;
                        else {
                            var te = 0
                              , O = 0;
                            for (p == 16 ? (O = 3 + Ln(s, l, 3),
                            l += 2,
                            te = w[B - 1]) : p == 17 ? (O = 3 + Ln(s, l, 7),
                            l += 3) : p == 18 && (O = 11 + Ln(s, l, 127),
                            l += 7); O--; )
                                w[B++] = te
                        }
                    }
                    var H = w.subarray(0, y)
                      , V = w.subarray(y);
                    d = sd(H),
                    f = sd(V),
                    h = al(H, d, 1),
                    u = al(V, f, 1)
                } else
                    throw "invalid block type";
            else {
                var p = E1(l) + 4
                  , g = s[p - 4] | s[p - 3] << 8
                  , M = p + g;
                if (M > i) {
                    if (r)
                        throw "unexpected EOF";
                    break
                }
                n && o(c + g),
                e.set(s.subarray(p, M), c),
                t.b = c += g,
                t.p = l = M * 8;
                continue
            }
            if (l > m) {
                if (r)
                    throw "unexpected EOF";
                break
            }
        }
        n && o(c + 131072);
        for (var Y = (1 << d) - 1, K = (1 << f) - 1, J = l; ; J = l) {
            var te = h[od(s, l) & Y]
              , D = te >>> 4;
            if (l += te & 15,
            l > m) {
                if (r)
                    throw "unexpected EOF";
                break
            }
            if (!te)
                throw "invalid length/literal";
            if (D < 256)
                e[c++] = D;
            else if (D == 256) {
                J = l,
                h = null;
                break
            } else {
                var se = D - 254;
                if (D > 264) {
                    var B = D - 257
                      , de = Ox[B];
                    se = Ln(s, l, (1 << de) - 1) + Hx[B],
                    l += de
                }
                var Q = u[od(s, l) & K]
                  , re = Q >>> 4;
                if (!Q)
                    throw "invalid distance";
                l += Q & 15;
                var V = S1[re];
                if (re > 3) {
                    var de = Bx[re];
                    V += od(s, l) & (1 << de) - 1,
                    l += de
                }
                if (l > m) {
                    if (r)
                        throw "unexpected EOF";
                    break
                }
                n && o(c + 131072);
                for (var ge = c + se; c < ge; c += 4)
                    e[c] = e[c - V],
                    e[c + 1] = e[c + 1 - V],
                    e[c + 2] = e[c + 2 - V],
                    e[c + 3] = e[c + 3 - V];
                c = ge
            }
        }
        t.l = h,
        t.p = J,
        t.b = c,
        h && (a = 1,
        t.m = d,
        t.d = u,
        t.n = f)
    } while (!a);
    return c == e.length ? e : w1(e, 0, c)
}
  , R1 = new yn(0)
  , C1 = function(s) {
    if ((s[0] & 15) != 8 || s[0] >>> 4 > 7 || (s[0] << 8 | s[1]) % 31)
        throw "invalid zlib data";
    if (s[1] & 32)
        throw "invalid zlib data: preset dictionaries not supported"
};
function Vc(s, e) {
    return A1((C1(s),
    s.subarray(2, -4)), e)
}
var P1 = typeof TextDecoder < "u" && new TextDecoder
  , L1 = 0;
try {
    P1.decode(R1, {
        stream: !0
    }),
    L1 = 1
} catch {}
class I1 extends t1 {
    constructor(e) {
        super(e),
        this.type = gc
    }
    parse(e) {
        const b = Math.pow(2.7182818, 2.2);
        function E(v, A) {
            let F = 0;
            for (let P = 0; P < 65536; ++P)
                (P == 0 || v[P >> 3] & 1 << (P & 7)) && (A[F++] = P);
            const x = F - 1;
            for (; F < 65536; )
                A[F++] = 0;
            return x
        }
        function G(v) {
            for (let A = 0; A < 16384; A++)
                v[A] = {},
                v[A].len = 0,
                v[A].lit = 0,
                v[A].p = null
        }
        const k = {
            l: 0,
            c: 0,
            lc: 0
        };
        function te(v, A, F, x, P) {
            for (; F < v; )
                A = A << 8 | Le(x, P),
                F += 8;
            F -= v,
            k.l = A >> F & (1 << v) - 1,
            k.c = A,
            k.lc = F
        }
        const O = new Array(59);
        function H(v) {
            for (let F = 0; F <= 58; ++F)
                O[F] = 0;
            for (let F = 0; F < 65537; ++F)
                O[v[F]] += 1;
            let A = 0;
            for (let F = 58; F > 0; --F) {
                const x = A + O[F] >> 1;
                O[F] = A,
                A = x
            }
            for (let F = 0; F < 65537; ++F) {
                const x = v[F];
                x > 0 && (v[F] = x | O[x]++ << 6)
            }
        }
        function V(v, A, F, x, P, I) {
            const U = A;
            let N = 0
              , W = 0;
            for (; x <= P; x++) {
                if (U.value - A.value > F)
                    return !1;
                te(6, N, W, v, U);
                const q = k.l;
                if (N = k.c,
                W = k.lc,
                I[x] = q,
                q == 63) {
                    if (U.value - A.value > F)
                        throw new Error("Something wrong with hufUnpackEncTable");
                    te(8, N, W, v, U);
                    let ie = k.l + 6;
                    if (N = k.c,
                    W = k.lc,
                    x + ie > P + 1)
                        throw new Error("Something wrong with hufUnpackEncTable");
                    for (; ie--; )
                        I[x++] = 0;
                    x--
                } else if (q >= 59) {
                    let ie = q - 59 + 2;
                    if (x + ie > P + 1)
                        throw new Error("Something wrong with hufUnpackEncTable");
                    for (; ie--; )
                        I[x++] = 0;
                    x--
                }
            }
            H(I)
        }
        function Y(v) {
            return v & 63
        }
        function K(v) {
            return v >> 6
        }
        function J(v, A, F, x) {
            for (; A <= F; A++) {
                const P = K(v[A])
                  , I = Y(v[A]);
                if (P >> I)
                    throw new Error("Invalid table entry");
                if (I > 14) {
                    const U = x[P >> I - 14];
                    if (U.len)
                        throw new Error("Invalid table entry");
                    if (U.lit++,
                    U.p) {
                        const N = U.p;
                        U.p = new Array(U.lit);
                        for (let W = 0; W < U.lit - 1; ++W)
                            U.p[W] = N[W]
                    } else
                        U.p = new Array(1);
                    U.p[U.lit - 1] = A
                } else if (I) {
                    let U = 0;
                    for (let N = 1 << 14 - I; N > 0; N--) {
                        const W = x[(P << 14 - I) + U];
                        if (W.len || W.p)
                            throw new Error("Invalid table entry");
                        W.len = I,
                        W.lit = A,
                        U++
                    }
                }
            }
            return !0
        }
        const D = {
            c: 0,
            lc: 0
        };
        function se(v, A, F, x) {
            v = v << 8 | Le(F, x),
            A += 8,
            D.c = v,
            D.lc = A
        }
        const de = {
            c: 0,
            lc: 0
        };
        function Q(v, A, F, x, P, I, U, N, W) {
            if (v == A) {
                x < 8 && (se(F, x, P, I),
                F = D.c,
                x = D.lc),
                x -= 8;
                let q = F >> x;
                if (q = new Uint8Array([q])[0],
                N.value + q > W)
                    return !1;
                const ie = U[N.value - 1];
                for (; q-- > 0; )
                    U[N.value++] = ie
            } else if (N.value < W)
                U[N.value++] = v;
            else
                return !1;
            de.c = F,
            de.lc = x
        }
        function re(v) {
            return v & 65535
        }
        function ge(v) {
            const A = re(v);
            return A > 32767 ? A - 65536 : A
        }
        const fe = {
            a: 0,
            b: 0
        };
        function ve(v, A) {
            const F = ge(v)
              , P = ge(A)
              , I = F + (P & 1) + (P >> 1)
              , U = I
              , N = I - P;
            fe.a = U,
            fe.b = N
        }
        function Ue(v, A) {
            const F = re(v)
              , x = re(A)
              , P = F - (x >> 1) & 65535
              , I = x + P - 32768 & 65535;
            fe.a = I,
            fe.b = P
        }
        function ke(v, A, F, x, P, I, U) {
            const N = U < 16384
              , W = F > P ? P : F;
            let q = 1, ie, oe;
            for (; q <= W; )
                q <<= 1;
            for (q >>= 1,
            ie = q,
            q >>= 1; q >= 1; ) {
                oe = 0;
                const ae = oe + I * (P - ie)
                  , he = I * q
                  , ye = I * ie
                  , Se = x * q
                  , Ae = x * ie;
                let Ne, dt, it, Ge;
                for (; oe <= ae; oe += ye) {
                    let bt = oe;
                    const qe = oe + x * (F - ie);
                    for (; bt <= qe; bt += Ae) {
                        const Ct = bt + Se
                          , bi = bt + he
                          , Nt = bi + Se;
                        N ? (ve(v[bt + A], v[bi + A]),
                        Ne = fe.a,
                        it = fe.b,
                        ve(v[Ct + A], v[Nt + A]),
                        dt = fe.a,
                        Ge = fe.b,
                        ve(Ne, dt),
                        v[bt + A] = fe.a,
                        v[Ct + A] = fe.b,
                        ve(it, Ge),
                        v[bi + A] = fe.a,
                        v[Nt + A] = fe.b) : (Ue(v[bt + A], v[bi + A]),
                        Ne = fe.a,
                        it = fe.b,
                        Ue(v[Ct + A], v[Nt + A]),
                        dt = fe.a,
                        Ge = fe.b,
                        Ue(Ne, dt),
                        v[bt + A] = fe.a,
                        v[Ct + A] = fe.b,
                        Ue(it, Ge),
                        v[bi + A] = fe.a,
                        v[Nt + A] = fe.b)
                    }
                    if (F & q) {
                        const Ct = bt + he;
                        N ? ve(v[bt + A], v[Ct + A]) : Ue(v[bt + A], v[Ct + A]),
                        Ne = fe.a,
                        v[Ct + A] = fe.b,
                        v[bt + A] = Ne
                    }
                }
                if (P & q) {
                    let bt = oe;
                    const qe = oe + x * (F - ie);
                    for (; bt <= qe; bt += Ae) {
                        const Ct = bt + Se;
                        N ? ve(v[bt + A], v[Ct + A]) : Ue(v[bt + A], v[Ct + A]),
                        Ne = fe.a,
                        v[Ct + A] = fe.b,
                        v[bt + A] = Ne
                    }
                }
                ie = q,
                q >>= 1
            }
            return oe
        }
        function Ve(v, A, F, x, P, I, U, N, W) {
            let q = 0
              , ie = 0;
            const oe = U
              , ae = Math.trunc(x.value + (P + 7) / 8);
            for (; x.value < ae; )
                for (se(q, ie, F, x),
                q = D.c,
                ie = D.lc; ie >= 14; ) {
                    const ye = q >> ie - 14 & 16383
                      , Se = A[ye];
                    if (Se.len)
                        ie -= Se.len,
                        Q(Se.lit, I, q, ie, F, x, N, W, oe),
                        q = de.c,
                        ie = de.lc;
                    else {
                        if (!Se.p)
                            throw new Error("hufDecode issues");
                        let Ae;
                        for (Ae = 0; Ae < Se.lit; Ae++) {
                            const Ne = Y(v[Se.p[Ae]]);
                            for (; ie < Ne && x.value < ae; )
                                se(q, ie, F, x),
                                q = D.c,
                                ie = D.lc;
                            if (ie >= Ne && K(v[Se.p[Ae]]) == (q >> ie - Ne & (1 << Ne) - 1)) {
                                ie -= Ne,
                                Q(Se.p[Ae], I, q, ie, F, x, N, W, oe),
                                q = de.c,
                                ie = de.lc;
                                break
                            }
                        }
                        if (Ae == Se.lit)
                            throw new Error("hufDecode issues")
                    }
                }
            const he = 8 - P & 7;
            for (q >>= he,
            ie -= he; ie > 0; ) {
                const ye = A[q << 14 - ie & 16383];
                if (ye.len)
                    ie -= ye.len,
                    Q(ye.lit, I, q, ie, F, x, N, W, oe),
                    q = de.c,
                    ie = de.lc;
                else
                    throw new Error("hufDecode issues")
            }
            return !0
        }
        function Ke(v, A, F, x, P, I) {
            const U = {
                value: 0
            }
              , N = F.value
              , W = Ce(A, F)
              , q = Ce(A, F);
            F.value += 4;
            const ie = Ce(A, F);
            if (F.value += 4,
            W < 0 || W >= 65537 || q < 0 || q >= 65537)
                throw new Error("Something wrong with HUF_ENCSIZE");
            const oe = new Array(65537)
              , ae = new Array(16384);
            G(ae);
            const he = x - (F.value - N);
            if (V(v, F, he, W, q, oe),
            ie > 8 * (x - (F.value - N)))
                throw new Error("Something wrong with hufUncompress");
            J(oe, W, q, ae),
            Ve(oe, ae, v, F, ie, q, I, P, U)
        }
        function $(v, A, F) {
            for (let x = 0; x < F; ++x)
                A[x] = v[A[x]]
        }
        function Qe(v) {
            for (let A = 1; A < v.length; A++) {
                const F = v[A - 1] + v[A] - 128;
                v[A] = F
            }
        }
        function Re(v, A) {
            let F = 0
              , x = Math.floor((v.length + 1) / 2)
              , P = 0;
            const I = v.length - 1;
            for (; !(P > I || (A[P++] = v[F++],
            P > I)); )
                A[P++] = v[x++]
        }
        function ze(v) {
            let A = v.byteLength;
            const F = new Array;
            let x = 0;
            const P = new DataView(v);
            for (; A > 0; ) {
                const I = P.getInt8(x++);
                if (I < 0) {
                    const U = -I;
                    A -= U + 1;
                    for (let N = 0; N < U; N++)
                        F.push(P.getUint8(x++))
                } else {
                    const U = I;
                    A -= 2;
                    const N = P.getUint8(x++);
                    for (let W = 0; W < U + 1; W++)
                        F.push(N)
                }
            }
            return F
        }
        function Pe(v, A, F, x, P, I) {
            let U = new DataView(I.buffer);
            const N = F[v.idx[0]].width
              , W = F[v.idx[0]].height
              , q = 3
              , ie = Math.floor(N / 8)
              , oe = Math.ceil(N / 8)
              , ae = Math.ceil(W / 8)
              , he = N - (oe - 1) * 8
              , ye = W - (ae - 1) * 8
              , Se = {
                value: 0
            }
              , Ae = new Array(q)
              , Ne = new Array(q)
              , dt = new Array(q)
              , it = new Array(q)
              , Ge = new Array(q);
            for (let qe = 0; qe < q; ++qe)
                Ge[qe] = A[v.idx[qe]],
                Ae[qe] = qe < 1 ? 0 : Ae[qe - 1] + oe * ae,
                Ne[qe] = new Float32Array(64),
                dt[qe] = new Uint16Array(64),
                it[qe] = new Uint16Array(oe * 64);
            for (let qe = 0; qe < ae; ++qe) {
                let Ct = 8;
                qe == ae - 1 && (Ct = ye);
                let bi = 8;
                for (let Mt = 0; Mt < oe; ++Mt) {
                    Mt == oe - 1 && (bi = he);
                    for (let ot = 0; ot < q; ++ot)
                        dt[ot].fill(0),
                        dt[ot][0] = P[Ae[ot]++],
                        Z(Se, x, dt[ot]),
                        Ye(dt[ot], Ne[ot]),
                        L(Ne[ot]);
                    R(Ne);
                    for (let ot = 0; ot < q; ++ot)
                        X(Ne[ot], it[ot], Mt * 64)
                }
                let Nt = 0;
                for (let Mt = 0; Mt < q; ++Mt) {
                    const ot = F[v.idx[Mt]].type;
                    for (let hi = 8 * qe; hi < 8 * qe + Ct; ++hi) {
                        Nt = Ge[Mt][hi];
                        for (let er = 0; er < ie; ++er) {
                            const Ot = er * 64 + (hi & 7) * 8;
                            U.setUint16(Nt + 0 * 2 * ot, it[Mt][Ot + 0], !0),
                            U.setUint16(Nt + 1 * 2 * ot, it[Mt][Ot + 1], !0),
                            U.setUint16(Nt + 2 * 2 * ot, it[Mt][Ot + 2], !0),
                            U.setUint16(Nt + 3 * 2 * ot, it[Mt][Ot + 3], !0),
                            U.setUint16(Nt + 4 * 2 * ot, it[Mt][Ot + 4], !0),
                            U.setUint16(Nt + 5 * 2 * ot, it[Mt][Ot + 5], !0),
                            U.setUint16(Nt + 6 * 2 * ot, it[Mt][Ot + 6], !0),
                            U.setUint16(Nt + 7 * 2 * ot, it[Mt][Ot + 7], !0),
                            Nt += 8 * 2 * ot
                        }
                    }
                    if (ie != oe)
                        for (let hi = 8 * qe; hi < 8 * qe + Ct; ++hi) {
                            const er = Ge[Mt][hi] + 8 * ie * 2 * ot
                              , Ot = ie * 64 + (hi & 7) * 8;
                            for (let Lr = 0; Lr < bi; ++Lr)
                                U.setUint16(er + Lr * 2 * ot, it[Mt][Ot + Lr], !0)
                        }
                }
            }
            const bt = new Uint16Array(N);
            U = new DataView(I.buffer);
            for (let qe = 0; qe < q; ++qe) {
                F[v.idx[qe]].decoded = !0;
                const Ct = F[v.idx[qe]].type;
                if (F[qe].type == 2)
                    for (let bi = 0; bi < W; ++bi) {
                        const Nt = Ge[qe][bi];
                        for (let Mt = 0; Mt < N; ++Mt)
                            bt[Mt] = U.getUint16(Nt + Mt * 2 * Ct, !0);
                        for (let Mt = 0; Mt < N; ++Mt)
                            U.setFloat32(Nt + Mt * 2 * Ct, j(bt[Mt]), !0)
                    }
            }
        }
        function Z(v, A, F) {
            let x, P = 1;
            for (; P < 64; )
                x = A[v.value],
                x == 65280 ? P = 64 : x >> 8 == 255 ? P += x & 255 : (F[P] = x,
                P++),
                v.value++
        }
        function Ye(v, A) {
            A[0] = j(v[0]),
            A[1] = j(v[1]),
            A[2] = j(v[5]),
            A[3] = j(v[6]),
            A[4] = j(v[14]),
            A[5] = j(v[15]),
            A[6] = j(v[27]),
            A[7] = j(v[28]),
            A[8] = j(v[2]),
            A[9] = j(v[4]),
            A[10] = j(v[7]),
            A[11] = j(v[13]),
            A[12] = j(v[16]),
            A[13] = j(v[26]),
            A[14] = j(v[29]),
            A[15] = j(v[42]),
            A[16] = j(v[3]),
            A[17] = j(v[8]),
            A[18] = j(v[12]),
            A[19] = j(v[17]),
            A[20] = j(v[25]),
            A[21] = j(v[30]),
            A[22] = j(v[41]),
            A[23] = j(v[43]),
            A[24] = j(v[9]),
            A[25] = j(v[11]),
            A[26] = j(v[18]),
            A[27] = j(v[24]),
            A[28] = j(v[31]),
            A[29] = j(v[40]),
            A[30] = j(v[44]),
            A[31] = j(v[53]),
            A[32] = j(v[10]),
            A[33] = j(v[19]),
            A[34] = j(v[23]),
            A[35] = j(v[32]),
            A[36] = j(v[39]),
            A[37] = j(v[45]),
            A[38] = j(v[52]),
            A[39] = j(v[54]),
            A[40] = j(v[20]),
            A[41] = j(v[22]),
            A[42] = j(v[33]),
            A[43] = j(v[38]),
            A[44] = j(v[46]),
            A[45] = j(v[51]),
            A[46] = j(v[55]),
            A[47] = j(v[60]),
            A[48] = j(v[21]),
            A[49] = j(v[34]),
            A[50] = j(v[37]),
            A[51] = j(v[47]),
            A[52] = j(v[50]),
            A[53] = j(v[56]),
            A[54] = j(v[59]),
            A[55] = j(v[61]),
            A[56] = j(v[35]),
            A[57] = j(v[36]),
            A[58] = j(v[48]),
            A[59] = j(v[49]),
            A[60] = j(v[57]),
            A[61] = j(v[58]),
            A[62] = j(v[62]),
            A[63] = j(v[63])
        }
        function L(v) {
            const A = .5 * Math.cos(.7853975)
              , F = .5 * Math.cos(3.14159 / 16)
              , x = .5 * Math.cos(3.14159 / 8)
              , P = .5 * Math.cos(3 * 3.14159 / 16)
              , I = .5 * Math.cos(5 * 3.14159 / 16)
              , U = .5 * Math.cos(3 * 3.14159 / 8)
              , N = .5 * Math.cos(7 * 3.14159 / 16)
              , W = new Array(4)
              , q = new Array(4)
              , ie = new Array(4)
              , oe = new Array(4);
            for (let ae = 0; ae < 8; ++ae) {
                const he = ae * 8;
                W[0] = x * v[he + 2],
                W[1] = U * v[he + 2],
                W[2] = x * v[he + 6],
                W[3] = U * v[he + 6],
                q[0] = F * v[he + 1] + P * v[he + 3] + I * v[he + 5] + N * v[he + 7],
                q[1] = P * v[he + 1] - N * v[he + 3] - F * v[he + 5] - I * v[he + 7],
                q[2] = I * v[he + 1] - F * v[he + 3] + N * v[he + 5] + P * v[he + 7],
                q[3] = N * v[he + 1] - I * v[he + 3] + P * v[he + 5] - F * v[he + 7],
                ie[0] = A * (v[he + 0] + v[he + 4]),
                ie[3] = A * (v[he + 0] - v[he + 4]),
                ie[1] = W[0] + W[3],
                ie[2] = W[1] - W[2],
                oe[0] = ie[0] + ie[1],
                oe[1] = ie[3] + ie[2],
                oe[2] = ie[3] - ie[2],
                oe[3] = ie[0] - ie[1],
                v[he + 0] = oe[0] + q[0],
                v[he + 1] = oe[1] + q[1],
                v[he + 2] = oe[2] + q[2],
                v[he + 3] = oe[3] + q[3],
                v[he + 4] = oe[3] - q[3],
                v[he + 5] = oe[2] - q[2],
                v[he + 6] = oe[1] - q[1],
                v[he + 7] = oe[0] - q[0]
            }
            for (let ae = 0; ae < 8; ++ae)
                W[0] = x * v[16 + ae],
                W[1] = U * v[16 + ae],
                W[2] = x * v[48 + ae],
                W[3] = U * v[48 + ae],
                q[0] = F * v[8 + ae] + P * v[24 + ae] + I * v[40 + ae] + N * v[56 + ae],
                q[1] = P * v[8 + ae] - N * v[24 + ae] - F * v[40 + ae] - I * v[56 + ae],
                q[2] = I * v[8 + ae] - F * v[24 + ae] + N * v[40 + ae] + P * v[56 + ae],
                q[3] = N * v[8 + ae] - I * v[24 + ae] + P * v[40 + ae] - F * v[56 + ae],
                ie[0] = A * (v[ae] + v[32 + ae]),
                ie[3] = A * (v[ae] - v[32 + ae]),
                ie[1] = W[0] + W[3],
                ie[2] = W[1] - W[2],
                oe[0] = ie[0] + ie[1],
                oe[1] = ie[3] + ie[2],
                oe[2] = ie[3] - ie[2],
                oe[3] = ie[0] - ie[1],
                v[0 + ae] = oe[0] + q[0],
                v[8 + ae] = oe[1] + q[1],
                v[16 + ae] = oe[2] + q[2],
                v[24 + ae] = oe[3] + q[3],
                v[32 + ae] = oe[3] - q[3],
                v[40 + ae] = oe[2] - q[2],
                v[48 + ae] = oe[1] - q[1],
                v[56 + ae] = oe[0] - q[0]
        }
        function R(v) {
            for (let A = 0; A < 64; ++A) {
                const F = v[0][A]
                  , x = v[1][A]
                  , P = v[2][A];
                v[0][A] = F + 1.5747 * P,
                v[1][A] = F - .1873 * x - .4682 * P,
                v[2][A] = F + 1.8556 * x
            }
        }
        function X(v, A, F) {
            for (let x = 0; x < 64; ++x)
                A[F + x] = yg.toHalfFloat(ue(v[x]))
        }
        function ue(v) {
            return v <= 1 ? Math.sign(v) * Math.pow(Math.abs(v), 2.2) : Math.sign(v) * Math.pow(b, Math.abs(v) - 1)
        }
        function ce(v) {
            return new DataView(v.array.buffer,v.offset.value,v.size)
        }
        function pe(v) {
            const A = v.viewer.buffer.slice(v.offset.value, v.offset.value + v.size)
              , F = new Uint8Array(ze(A))
              , x = new Uint8Array(F.length);
            return Qe(F),
            Re(F, x),
            new DataView(x.buffer)
        }
        function be(v) {
            const A = v.array.slice(v.offset.value, v.offset.value + v.size)
              , F = Vc(A)
              , x = new Uint8Array(F.length);
            return Qe(F),
            Re(F, x),
            new DataView(x.buffer)
        }
        function me(v) {
            const A = v.viewer
              , F = {
                value: v.offset.value
            }
              , x = new Uint16Array(v.width * v.scanlineBlockSize * (v.channels * v.type))
              , P = new Uint8Array(8192);
            let I = 0;
            const U = new Array(v.channels);
            for (let ye = 0; ye < v.channels; ye++)
                U[ye] = {},
                U[ye].start = I,
                U[ye].end = U[ye].start,
                U[ye].nx = v.width,
                U[ye].ny = v.lines,
                U[ye].size = v.type,
                I += U[ye].nx * U[ye].ny * U[ye].size;
            const N = z(A, F)
              , W = z(A, F);
            if (W >= 8192)
                throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
            if (N <= W)
                for (let ye = 0; ye < W - N + 1; ye++)
                    P[ye + N] = $e(A, F);
            const q = new Uint16Array(65536)
              , ie = E(P, q)
              , oe = Ce(A, F);
            Ke(v.array, A, F, oe, x, I);
            for (let ye = 0; ye < v.channels; ++ye) {
                const Se = U[ye];
                for (let Ae = 0; Ae < U[ye].size; ++Ae)
                    ke(x, Se.start + Ae, Se.nx, Se.size, Se.ny, Se.nx * Se.size, ie)
            }
            $(q, x, I);
            let ae = 0;
            const he = new Uint8Array(x.buffer.byteLength);
            for (let ye = 0; ye < v.lines; ye++)
                for (let Se = 0; Se < v.channels; Se++) {
                    const Ae = U[Se]
                      , Ne = Ae.nx * Ae.size
                      , dt = new Uint8Array(x.buffer,Ae.end * 2,Ne * 2);
                    he.set(dt, ae),
                    ae += Ne * 2,
                    Ae.end += Ne
                }
            return new DataView(he.buffer)
        }
        function Ee(v) {
            const A = v.array.slice(v.offset.value, v.offset.value + v.size)
              , F = Vc(A)
              , x = v.lines * v.channels * v.width
              , P = v.type == 1 ? new Uint16Array(x) : new Uint32Array(x);
            let I = 0
              , U = 0;
            const N = new Array(4);
            for (let W = 0; W < v.lines; W++)
                for (let q = 0; q < v.channels; q++) {
                    let ie = 0;
                    switch (v.type) {
                    case 1:
                        N[0] = I,
                        N[1] = N[0] + v.width,
                        I = N[1] + v.width;
                        for (let oe = 0; oe < v.width; ++oe) {
                            const ae = F[N[0]++] << 8 | F[N[1]++];
                            ie += ae,
                            P[U] = ie,
                            U++
                        }
                        break;
                    case 2:
                        N[0] = I,
                        N[1] = N[0] + v.width,
                        N[2] = N[1] + v.width,
                        I = N[2] + v.width;
                        for (let oe = 0; oe < v.width; ++oe) {
                            const ae = F[N[0]++] << 24 | F[N[1]++] << 16 | F[N[2]++] << 8;
                            ie += ae,
                            P[U] = ie,
                            U++
                        }
                        break
                    }
                }
            return new DataView(P.buffer)
        }
        function Oe(v) {
            const A = v.viewer
              , F = {
                value: v.offset.value
            }
              , x = new Uint8Array(v.width * v.lines * (v.channels * v.type * 2))
              , P = {
                version: et(A, F),
                unknownUncompressedSize: et(A, F),
                unknownCompressedSize: et(A, F),
                acCompressedSize: et(A, F),
                dcCompressedSize: et(A, F),
                rleCompressedSize: et(A, F),
                rleUncompressedSize: et(A, F),
                rleRawSize: et(A, F),
                totalAcUncompressedCount: et(A, F),
                totalDcUncompressedCount: et(A, F),
                acCompression: et(A, F)
            };
            if (P.version < 2)
                throw new Error("EXRLoader.parse: " + at.compression + " version " + P.version + " is unsupported");
            const I = new Array;
            let U = z(A, F) - 2;
            for (; U > 0; ) {
                const Se = Je(A.buffer, F)
                  , Ae = $e(A, F)
                  , Ne = Ae >> 2 & 3
                  , dt = (Ae >> 4) - 1
                  , it = new Int8Array([dt])[0]
                  , Ge = $e(A, F);
                I.push({
                    name: Se,
                    index: it,
                    type: Ge,
                    compression: Ne
                }),
                U -= Se.length + 3
            }
            const N = at.channels
              , W = new Array(v.channels);
            for (let Se = 0; Se < v.channels; ++Se) {
                const Ae = W[Se] = {}
                  , Ne = N[Se];
                Ae.name = Ne.name,
                Ae.compression = 0,
                Ae.decoded = !1,
                Ae.type = Ne.pixelType,
                Ae.pLinear = Ne.pLinear,
                Ae.width = v.width,
                Ae.height = v.lines
            }
            const q = {
                idx: new Array(3)
            };
            for (let Se = 0; Se < v.channels; ++Se) {
                const Ae = W[Se];
                for (let Ne = 0; Ne < I.length; ++Ne) {
                    const dt = I[Ne];
                    Ae.name == dt.name && (Ae.compression = dt.compression,
                    dt.index >= 0 && (q.idx[dt.index] = Se),
                    Ae.offset = Se)
                }
            }
            let ie, oe, ae;
            if (P.acCompressedSize > 0)
                switch (P.acCompression) {
                case 0:
                    ie = new Uint16Array(P.totalAcUncompressedCount),
                    Ke(v.array, A, F, P.acCompressedSize, ie, P.totalAcUncompressedCount);
                    break;
                case 1:
                    const Se = v.array.slice(F.value, F.value + P.totalAcUncompressedCount)
                      , Ae = Vc(Se);
                    ie = new Uint16Array(Ae.buffer),
                    F.value += P.totalAcUncompressedCount;
                    break
                }
            if (P.dcCompressedSize > 0) {
                const Se = {
                    array: v.array,
                    offset: F,
                    size: P.dcCompressedSize
                };
                oe = new Uint16Array(be(Se).buffer),
                F.value += P.dcCompressedSize
            }
            if (P.rleRawSize > 0) {
                const Se = v.array.slice(F.value, F.value + P.rleCompressedSize)
                  , Ae = Vc(Se);
                ae = ze(Ae.buffer),
                F.value += P.rleCompressedSize
            }
            let he = 0;
            const ye = new Array(W.length);
            for (let Se = 0; Se < ye.length; ++Se)
                ye[Se] = new Array;
            for (let Se = 0; Se < v.lines; ++Se)
                for (let Ae = 0; Ae < W.length; ++Ae)
                    ye[Ae].push(he),
                    he += W[Ae].width * v.type * 2;
            Pe(q, ye, W, ie, oe, x);
            for (let Se = 0; Se < W.length; ++Se) {
                const Ae = W[Se];
                if (!Ae.decoded)
                    switch (Ae.compression) {
                    case 2:
                        let Ne = 0
                          , dt = 0;
                        for (let it = 0; it < v.lines; ++it) {
                            let Ge = ye[Se][Ne];
                            for (let bt = 0; bt < Ae.width; ++bt) {
                                for (let qe = 0; qe < 2 * Ae.type; ++qe)
                                    x[Ge++] = ae[dt + qe * Ae.width * Ae.height];
                                dt++
                            }
                            Ne++
                        }
                        break;
                    case 1:
                    default:
                        throw new Error("EXRLoader.parse: unsupported channel compression")
                    }
            }
            return new DataView(x.buffer)
        }
        function Je(v, A) {
            const F = new Uint8Array(v);
            let x = 0;
            for (; F[A.value + x] != 0; )
                x += 1;
            const P = new TextDecoder().decode(F.slice(A.value, A.value + x));
            return A.value = A.value + x + 1,
            P
        }
        function le(v, A, F) {
            const x = new TextDecoder().decode(new Uint8Array(v).slice(A.value, A.value + F));
            return A.value = A.value + F,
            x
        }
        function lt(v, A) {
            const F = We(v, A)
              , x = Ce(v, A);
            return [F, x]
        }
        function Ze(v, A) {
            const F = Ce(v, A)
              , x = Ce(v, A);
            return [F, x]
        }
        function We(v, A) {
            const F = v.getInt32(A.value, !0);
            return A.value = A.value + 4,
            F
        }
        function Ce(v, A) {
            const F = v.getUint32(A.value, !0);
            return A.value = A.value + 4,
            F
        }
        function Le(v, A) {
            const F = v[A.value];
            return A.value = A.value + 1,
            F
        }
        function $e(v, A) {
            const F = v.getUint8(A.value);
            return A.value = A.value + 1,
            F
        }
        const et = function(v, A) {
            let F;
            return "getBigInt64"in DataView.prototype ? F = Number(v.getBigInt64(A.value, !0)) : F = v.getUint32(A.value + 4, !0) + Number(v.getUint32(A.value, !0) << 32),
            A.value += 8,
            F
        };
        function st(v, A) {
            const F = v.getFloat32(A.value, !0);
            return A.value += 4,
            F
        }
        function we(v, A) {
            return yg.toHalfFloat(st(v, A))
        }
        function j(v) {
            const A = (v & 31744) >> 10
              , F = v & 1023;
            return (v >> 15 ? -1 : 1) * (A ? A === 31 ? F ? NaN : 1 / 0 : Math.pow(2, A - 15) * (1 + F / 1024) : 6103515625e-14 * (F / 1024))
        }
        function z(v, A) {
            const F = v.getUint16(A.value, !0);
            return A.value += 2,
            F
        }
        function _e(v, A) {
            return j(z(v, A))
        }
        function xe(v, A, F, x) {
            const P = F.value
              , I = [];
            for (; F.value < P + x - 1; ) {
                const U = Je(A, F)
                  , N = We(v, F)
                  , W = $e(v, F);
                F.value += 3;
                const q = We(v, F)
                  , ie = We(v, F);
                I.push({
                    name: U,
                    pixelType: N,
                    pLinear: W,
                    xSampling: q,
                    ySampling: ie
                })
            }
            return F.value += 1,
            I
        }
        function Xe(v, A) {
            const F = st(v, A)
              , x = st(v, A)
              , P = st(v, A)
              , I = st(v, A)
              , U = st(v, A)
              , N = st(v, A)
              , W = st(v, A)
              , q = st(v, A);
            return {
                redX: F,
                redY: x,
                greenX: P,
                greenY: I,
                blueX: U,
                blueY: N,
                whiteX: W,
                whiteY: q
            }
        }
        function He(v, A) {
            const F = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"]
              , x = $e(v, A);
            return F[x]
        }
        function ut(v, A) {
            const F = Ce(v, A)
              , x = Ce(v, A)
              , P = Ce(v, A)
              , I = Ce(v, A);
            return {
                xMin: F,
                yMin: x,
                xMax: P,
                yMax: I
            }
        }
        function Ie(v, A) {
            const F = ["INCREASING_Y"]
              , x = $e(v, A);
            return F[x]
        }
        function De(v, A) {
            const F = st(v, A)
              , x = st(v, A);
            return [F, x]
        }
        function nt(v, A) {
            const F = st(v, A)
              , x = st(v, A)
              , P = st(v, A);
            return [F, x, P]
        }
        function rt(v, A, F, x, P) {
            if (x === "string" || x === "stringvector" || x === "iccProfile")
                return le(A, F, P);
            if (x === "chlist")
                return xe(v, A, F, P);
            if (x === "chromaticities")
                return Xe(v, F);
            if (x === "compression")
                return He(v, F);
            if (x === "box2i")
                return ut(v, F);
            if (x === "lineOrder")
                return Ie(v, F);
            if (x === "float")
                return st(v, F);
            if (x === "v2f")
                return De(v, F);
            if (x === "v3f")
                return nt(v, F);
            if (x === "int")
                return We(v, F);
            if (x === "rational")
                return lt(v, F);
            if (x === "timecode")
                return Ze(v, F);
            if (x === "preview")
                return F.value += P,
                "skipped";
            F.value += P
        }
        function Me(v, A, F) {
            const x = {};
            if (v.getUint32(0, !0) != 20000630)
                throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
            x.version = v.getUint8(4);
            const P = v.getUint8(5);
            x.spec = {
                singleTile: !!(P & 2),
                longName: !!(P & 4),
                deepFormat: !!(P & 8),
                multiPart: !!(P & 16)
            },
            F.value = 8;
            let I = !0;
            for (; I; ) {
                const U = Je(A, F);
                if (U == 0)
                    I = !1;
                else {
                    const N = Je(A, F)
                      , W = Ce(v, F)
                      , q = rt(v, A, F, N, W);
                    q === void 0 ? console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${N}'.`) : x[U] = q
                }
            }
            if (P & -5)
                throw console.error("THREE.EXRHeader:", x),
                new Error("THREE.EXRLoader: Provided file is currently unsupported.");
            return x
        }
        function tt(v, A, F, x, P) {
            const I = {
                size: 0,
                viewer: A,
                array: F,
                offset: x,
                width: v.dataWindow.xMax - v.dataWindow.xMin + 1,
                height: v.dataWindow.yMax - v.dataWindow.yMin + 1,
                channels: v.channels.length,
                bytesPerLine: null,
                lines: null,
                inputSize: null,
                type: v.channels[0].pixelType,
                uncompress: null,
                getter: null,
                format: null,
                colorSpace: Oi
            };
            switch (v.compression) {
            case "NO_COMPRESSION":
                I.lines = 1,
                I.uncompress = ce;
                break;
            case "RLE_COMPRESSION":
                I.lines = 1,
                I.uncompress = pe;
                break;
            case "ZIPS_COMPRESSION":
                I.lines = 1,
                I.uncompress = be;
                break;
            case "ZIP_COMPRESSION":
                I.lines = 16,
                I.uncompress = be;
                break;
            case "PIZ_COMPRESSION":
                I.lines = 32,
                I.uncompress = me;
                break;
            case "PXR24_COMPRESSION":
                I.lines = 16,
                I.uncompress = Ee;
                break;
            case "DWAA_COMPRESSION":
                I.lines = 32,
                I.uncompress = Oe;
                break;
            case "DWAB_COMPRESSION":
                I.lines = 256,
                I.uncompress = Oe;
                break;
            default:
                throw new Error("EXRLoader.parse: " + v.compression + " is unsupported")
            }
            if (I.scanlineBlockSize = I.lines,
            I.type == 1)
                switch (P) {
                case il:
                    I.getter = _e,
                    I.inputSize = 2;
                    break;
                case gc:
                    I.getter = z,
                    I.inputSize = 2;
                    break
                }
            else if (I.type == 2)
                switch (P) {
                case il:
                    I.getter = st,
                    I.inputSize = 4;
                    break;
                case gc:
                    I.getter = we,
                    I.inputSize = 4
                }
            else
                throw new Error("EXRLoader.parse: unsupported pixelType " + I.type + " for " + v.compression + ".");
            I.blockCount = (v.dataWindow.yMax + 1) / I.scanlineBlockSize;
            for (let N = 0; N < I.blockCount; N++)
                et(A, x);
            I.outputChannels = I.channels == 3 ? 4 : I.channels;
            const U = I.width * I.height * I.outputChannels;
            switch (P) {
            case il:
                I.byteArray = new Float32Array(U),
                I.channels < I.outputChannels && I.byteArray.fill(1, 0, U);
                break;
            case gc:
                I.byteArray = new Uint16Array(U),
                I.channels < I.outputChannels && I.byteArray.fill(15360, 0, U);
                break;
            default:
                console.error("THREE.EXRLoader: unsupported type: ", P);
                break
            }
            return I.bytesPerLine = I.width * I.inputSize * I.channels,
            I.outputChannels == 4 ? (I.format = qf,
            I.colorSpace = Oi) : (I.format = NS,
            I.colorSpace = nl),
            I
        }
        const je = new DataView(e)
          , ct = new Uint8Array(e)
          , St = {
            value: 0
        }
          , at = Me(je, e, St)
          , Be = tt(at, je, ct, St, this.type)
          , Vt = {
            value: 0
        }
          , Ft = {
            R: 0,
            G: 1,
            B: 2,
            A: 3,
            Y: 0
        };
        for (let v = 0; v < Be.height / Be.scanlineBlockSize; v++) {
            const A = Ce(je, St);
            Be.size = Ce(je, St),
            Be.lines = A + Be.scanlineBlockSize > Be.height ? Be.height - A : Be.scanlineBlockSize;
            const x = Be.size < Be.lines * Be.bytesPerLine ? Be.uncompress(Be) : ce(Be);
            St.value += Be.size;
            for (let P = 0; P < Be.scanlineBlockSize; P++) {
                const I = P + v * Be.scanlineBlockSize;
                if (I >= Be.height)
                    break;
                for (let U = 0; U < Be.channels; U++) {
                    const N = Ft[at.channels[U].name];
                    for (let W = 0; W < Be.width; W++) {
                        Vt.value = (P * (Be.channels * Be.width) + U * Be.width + W) * Be.inputSize;
                        const q = (Be.height - 1 - I) * (Be.width * Be.outputChannels) + W * Be.outputChannels + N;
                        Be.byteArray[q] = Be.getter(x, Vt)
                    }
                }
            }
        }
        return {
            header: at,
            width: Be.width,
            height: Be.height,
            data: Be.byteArray,
            format: Be.format,
            colorSpace: Be.colorSpace,
            type: this.type
        }
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, i, n) {
        function r(o, a) {
            o.colorSpace = a.colorSpace,
            o.minFilter = as,
            o.magFilter = as,
            o.generateMipmaps = !1,
            o.flipY = !1,
            t && t(o, a)
        }
        return super.load(e, r, i, n)
    }
}
function Xg(s, e) {
    if (e === OS)
        return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
        s;
    if (e === of || e === Ex) {
        let t = s.getIndex();
        if (t === null) {
            const o = []
              , a = s.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++)
                    o.push(l);
                s.setIndex(o),
                t = s.getIndex()
            } else
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                s
        }
        const i = t.count - 2
          , n = [];
        if (e === of)
            for (let o = 1; o <= i; o++)
                n.push(t.getX(0)),
                n.push(t.getX(o)),
                n.push(t.getX(o + 1));
        else
            for (let o = 0; o < i; o++)
                o % 2 === 0 ? (n.push(t.getX(o)),
                n.push(t.getX(o + 1)),
                n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)),
                n.push(t.getX(o + 1)),
                n.push(t.getX(o)));
        n.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const r = s.clone();
        return r.setIndex(n),
        r.clearGroups(),
        r
    } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e),
        s
}
class D1 extends ps {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new B1(t)
        }),
        this.register(function(t) {
            return new Y1(t)
        }),
        this.register(function(t) {
            return new $1(t)
        }),
        this.register(function(t) {
            return new j1(t)
        }),
        this.register(function(t) {
            return new k1(t)
        }),
        this.register(function(t) {
            return new H1(t)
        }),
        this.register(function(t) {
            return new G1(t)
        }),
        this.register(function(t) {
            return new V1(t)
        }),
        this.register(function(t) {
            return new O1(t)
        }),
        this.register(function(t) {
            return new W1(t)
        }),
        this.register(function(t) {
            return new z1(t)
        }),
        this.register(function(t) {
            return new q1(t)
        }),
        this.register(function(t) {
            return new X1(t)
        }),
        this.register(function(t) {
            return new N1(t)
        }),
        this.register(function(t) {
            return new Z1(t)
        }),
        this.register(function(t) {
            return new K1(t)
        })
    }
    load(e, t, i, n) {
        const r = this;
        let o;
        if (this.resourcePath !== "")
            o = this.resourcePath;
        else if (this.path !== "") {
            const c = ol.extractUrlBase(e);
            o = ol.resolveURL(c, this.path)
        } else
            o = ol.extractUrlBase(e);
        this.manager.itemStart(e);
        const a = function(c) {
            n ? n(c) : console.error(c),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
          , l = new El(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(c) {
            try {
                r.parse(c, o, function(h) {
                    t(h),
                    r.manager.itemEnd(e)
                }, a)
            } catch (h) {
                a(h)
            }
        }, i, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, i, n) {
        let r;
        const o = {}
          , a = {}
          , l = new TextDecoder;
        if (typeof e == "string")
            r = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (l.decode(new Uint8Array(e,0,4)) === Vx) {
                try {
                    o[gt.KHR_BINARY_GLTF] = new J1(e)
                } catch (u) {
                    n && n(u);
                    return
                }
                r = JSON.parse(o[gt.KHR_BINARY_GLTF].content)
            } else
                r = JSON.parse(l.decode(e));
        else
            r = e;
        if (r.asset === void 0 || r.asset.version[0] < 2) {
            n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new uT(r,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const u = this.pluginCallbacks[h](c);
            u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
            a[u.name] = u,
            o[u.name] = !0
        }
        if (r.extensionsUsed)
            for (let h = 0; h < r.extensionsUsed.length; ++h) {
                const u = r.extensionsUsed[h]
                  , d = r.extensionsRequired || [];
                switch (u) {
                case gt.KHR_MATERIALS_UNLIT:
                    o[u] = new F1;
                    break;
                case gt.KHR_DRACO_MESH_COMPRESSION:
                    o[u] = new Q1(r,this.dracoLoader);
                    break;
                case gt.KHR_TEXTURE_TRANSFORM:
                    o[u] = new eT;
                    break;
                case gt.KHR_MESH_QUANTIZATION:
                    o[u] = new tT;
                    break;
                default:
                    d.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".')
                }
            }
        c.setExtensions(o),
        c.setPlugins(a),
        c.parse(i, n)
    }
    parseAsync(e, t) {
        const i = this;
        return new Promise(function(n, r) {
            i.parse(e, t, n, r)
        }
        )
    }
}
function U1() {
    let s = {};
    return {
        get: function(e) {
            return s[e]
        },
        add: function(e, t) {
            s[e] = t
        },
        remove: function(e) {
            delete s[e]
        },
        removeAll: function() {
            s = {}
        }
    }
}
const gt = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class N1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let i = 0, n = t.length; i < n; i++) {
            const r = t[i];
            r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , i = "light:" + e;
        let n = t.cache.get(i);
        if (n)
            return n;
        const r = t.json
          , l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
        let c;
        const h = new Jt(16777215);
        l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], Oi);
        const u = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            c = new l1(h),
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        case "point":
            c = new o1(h),
            c.distance = u;
            break;
        case "spot":
            c = new r1(h),
            c.distance = u,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            c.angle = l.spot.outerConeAngle,
            c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0),
        c.decay = 2,
        Xr(c, l),
        l.intensity !== void 0 && (c.intensity = l.intensity),
        c.name = t.createUniqueName(l.name || "light_" + e),
        n = Promise.resolve(c),
        t.cache.add(i, n),
        n
    }
    getDependency(e, t) {
        if (e === "light")
            return this._loadLight(t)
    }
    createNodeAttachment(e) {
        const t = this
          , i = this.parser
          , r = i.json.nodes[e]
          , a = (r.extensions && r.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return i._getNodeRef(t.cache, a, l)
        })
    }
}
class F1 {
    constructor() {
        this.name = gt.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Yo
    }
    extendParams(e, t, i) {
        const n = [];
        e.color = new Jt(1,1,1),
        e.opacity = 1;
        const r = t.pbrMetallicRoughness;
        if (r) {
            if (Array.isArray(r.baseColorFactor)) {
                const o = r.baseColorFactor;
                e.color.setRGB(o[0], o[1], o[2], Oi),
                e.opacity = o[3]
            }
            r.baseColorTexture !== void 0 && n.push(i.assignTexture(e, "map", r.baseColorTexture, ai))
        }
        return Promise.all(n)
    }
}
class O1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const n = this.parser.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = n.extensions[this.name].emissiveStrength;
        return r !== void 0 && (t.emissiveIntensity = r),
        Promise.resolve()
    }
}
class B1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = n.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (r.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Xt(a,a)
        }
        return Promise.all(r)
    }
}
class z1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = n.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(r)
    }
}
class k1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = [];
        t.sheenColor = new Jt(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = n.extensions[this.name];
        if (o.sheenColorFactor !== void 0) {
            const a = o.sheenColorFactor;
            t.sheenColor.setRGB(a[0], a[1], a[2], Oi)
        }
        return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && r.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, ai)),
        o.sheenRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(r)
    }
}
class H1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = n.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && r.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(r)
    }
}
class G1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = n.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && r.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Jt().setRGB(a[0], a[1], a[2], Oi),
        Promise.all(r)
    }
}
class V1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const n = this.parser.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = n.extensions[this.name];
        return t.ior = r.ior !== void 0 ? r.ior : 1.5,
        Promise.resolve()
    }
}
class W1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = n.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && r.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Jt().setRGB(a[0], a[1], a[2], Oi),
        o.specularColorTexture !== void 0 && r.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, ai)),
        Promise.all(r)
    }
}
class X1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.EXT_MATERIALS_BUMP
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = n.extensions[this.name];
        return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1,
        o.bumpTexture !== void 0 && r.push(i.assignTexture(t, "bumpMap", o.bumpTexture)),
        Promise.all(r)
    }
}
class q1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Pr
    }
    extendMaterialParams(e, t) {
        const i = this.parser
          , n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = n.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
        o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation),
        o.anisotropyTexture !== void 0 && r.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
        Promise.all(r)
    }
}
class Y1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , i = t.json
          , n = i.textures[e];
        if (!n.extensions || !n.extensions[this.name])
            return null;
        const r = n.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, r.source, o)
    }
}
class $1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , i = this.parser
          , n = i.json
          , r = n.textures[e];
        if (!r.extensions || !r.extensions[t])
            return null;
        const o = r.extensions[t]
          , a = n.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return i.loadTextureImage(e, o.source, l);
            if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class j1 {
    constructor(e) {
        this.parser = e,
        this.name = gt.EXT_TEXTURE_AVIF,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , i = this.parser
          , n = i.json
          , r = n.textures[e];
        if (!r.extensions || !r.extensions[t])
            return null;
        const o = r.extensions[t]
          , a = n.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return i.loadTextureImage(e, o.source, l);
            if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class Z1 {
    constructor(e) {
        this.name = gt.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
            const n = i.extensions[this.name]
              , r = this.parser.getDependency("buffer", n.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return r.then(function(a) {
                const l = n.byteOffset || 0
                  , c = n.byteLength || 0
                  , h = n.count
                  , u = n.byteStride
                  , d = new Uint8Array(a,l,c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, u, d, n.mode, n.filter).then(function(f) {
                    return f.buffer
                }) : o.ready.then(function() {
                    const f = new ArrayBuffer(h * u);
                    return o.decodeGltfBuffer(new Uint8Array(f), h, u, d, n.mode, n.filter),
                    f
                })
            })
        } else
            return null
    }
}
class K1 {
    constructor(e) {
        this.name = gt.EXT_MESH_GPU_INSTANCING,
        this.parser = e
    }
    createNodeMesh(e) {
        const t = this.parser.json
          , i = t.nodes[e];
        if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
            return null;
        const n = t.meshes[i.mesh];
        for (const c of n.primitives)
            if (c.mode !== mn.TRIANGLES && c.mode !== mn.TRIANGLE_STRIP && c.mode !== mn.TRIANGLE_FAN && c.mode !== void 0)
                return null;
        const o = i.extensions[this.name].attributes
          , a = []
          , l = {};
        for (const c in o)
            a.push(this.parser.getDependency("accessor", o[c]).then(h => (l[c] = h,
            l[c])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then(c => {
            const h = c.pop()
              , u = h.isGroup ? h.children : [h]
              , d = c[0].count
              , f = [];
            for (const m of u) {
                const _ = new vt
                  , p = new ee
                  , g = new fs
                  , M = new ee(1,1,1)
                  , y = new Bb(m.geometry,m.material,d);
                for (let S = 0; S < d; S++)
                    l.TRANSLATION && p.fromBufferAttribute(l.TRANSLATION, S),
                    l.ROTATION && g.fromBufferAttribute(l.ROTATION, S),
                    l.SCALE && M.fromBufferAttribute(l.SCALE, S),
                    y.setMatrixAt(S, _.compose(p, g, M));
                for (const S in l)
                    if (S === "_COLOR_0") {
                        const C = l[S];
                        y.instanceColor = new uf(C.array,C.itemSize,C.normalized)
                    } else
                        S !== "TRANSLATION" && S !== "ROTATION" && S !== "SCALE" && m.geometry.setAttribute(S, l[S]);
                qt.prototype.copy.call(y, m),
                this.parser.assignFinalMaterial(y),
                f.push(y)
            }
            return h.isGroup ? (h.clear(),
            h.add(...f),
            h) : f[0]
        }
        ))
    }
}
const Vx = "glTF"
  , Ba = 12
  , qg = {
    JSON: 1313821514,
    BIN: 5130562
};
class J1 {
    constructor(e) {
        this.name = gt.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,Ba)
          , i = new TextDecoder;
        if (this.header = {
            magic: i.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== Vx)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - Ba
          , r = new DataView(e,Ba);
        let o = 0;
        for (; o < n; ) {
            const a = r.getUint32(o, !0);
            o += 4;
            const l = r.getUint32(o, !0);
            if (o += 4,
            l === qg.JSON) {
                const c = new Uint8Array(e,Ba + o,a);
                this.content = i.decode(c)
            } else if (l === qg.BIN) {
                const c = Ba + o;
                this.body = e.slice(c, c + a)
            }
            o += a
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class Q1 {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = gt.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const i = this.json
          , n = this.dracoLoader
          , r = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , l = {}
          , c = {};
        for (const h in o) {
            const u = mf[h] || h.toLowerCase();
            a[u] = o[h]
        }
        for (const h in e.attributes) {
            const u = mf[h] || h.toLowerCase();
            if (o[h] !== void 0) {
                const d = i.accessors[e.attributes[h]]
                  , f = sa[d.componentType];
                c[u] = f.name,
                l[u] = d.normalized === !0
            }
        }
        return t.getDependency("bufferView", r).then(function(h) {
            return new Promise(function(u, d) {
                n.decodeDracoFile(h, function(f) {
                    for (const m in f.attributes) {
                        const _ = f.attributes[m]
                          , p = l[m];
                        p !== void 0 && (_.normalized = p)
                    }
                    u(f)
                }, a, c, Oi, d)
            }
            )
        })
    }
}
class eT {
    constructor() {
        this.name = gt.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class tT {
    constructor() {
        this.name = gt.KHR_MESH_QUANTIZATION
    }
}
class Wx extends Il {
    constructor(e, t, i, n) {
        super(e, t, i, n)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , n = this.valueSize
          , r = e * n * 3 + n;
        for (let o = 0; o !== n; o++)
            t[o] = i[r + o];
        return t
    }
    interpolate_(e, t, i, n) {
        const r = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = a * 2
          , c = a * 3
          , h = n - t
          , u = (i - t) / h
          , d = u * u
          , f = d * u
          , m = e * c
          , _ = m - c
          , p = -2 * f + 3 * d
          , g = f - d
          , M = 1 - p
          , y = g - d + u;
        for (let S = 0; S !== a; S++) {
            const C = o[_ + S + a]
              , w = o[_ + S + l] * h
              , T = o[m + S + a]
              , B = o[m + S] * h;
            r[S] = M * C + y * w + p * T + g * B
        }
        return r
    }
}
const iT = new fs;
class nT extends Wx {
    interpolate_(e, t, i, n) {
        const r = super.interpolate_(e, t, i, n);
        return iT.fromArray(r).normalize().toArray(r),
        r
    }
}
const mn = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , sa = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , Yg = {
    9728: Sl,
    9729: as,
    9984: CS,
    9985: LS,
    9986: PS,
    9987: Fh
}
  , $g = {
    33071: Fs,
    33648: sf,
    10497: Ml
}
  , ad = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , mf = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , Vr = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , rT = {
    CUBICSPLINE: void 0,
    LINEAR: ga,
    STEP: bl
}
  , ld = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function sT(s) {
    return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new Qf({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Ah
    })),
    s.DefaultMaterial
}
function Ts(s, e, t) {
    for (const i in t.extensions)
        s[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[i] = t.extensions[i])
}
function Xr(s, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function oT(s, e, t) {
    let i = !1
      , n = !1
      , r = !1;
    for (let c = 0, h = e.length; c < h; c++) {
        const u = e[c];
        if (u.POSITION !== void 0 && (i = !0),
        u.NORMAL !== void 0 && (n = !0),
        u.COLOR_0 !== void 0 && (r = !0),
        i && n && r)
            break
    }
    if (!i && !n && !r)
        return Promise.resolve(s);
    const o = []
      , a = []
      , l = [];
    for (let c = 0, h = e.length; c < h; c++) {
        const u = e[c];
        if (i) {
            const d = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : s.attributes.position;
            o.push(d)
        }
        if (n) {
            const d = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : s.attributes.normal;
            a.push(d)
        }
        if (r) {
            const d = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : s.attributes.color;
            l.push(d)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
        const h = c[0]
          , u = c[1]
          , d = c[2];
        return i && (s.morphAttributes.position = h),
        n && (s.morphAttributes.normal = u),
        r && (s.morphAttributes.color = d),
        s.morphTargetsRelative = !0,
        s
    })
}
function aT(s, e) {
    if (s.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, i = e.weights.length; t < i; t++)
            s.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (s.morphTargetInfluences.length === t.length) {
            s.morphTargetDictionary = {};
            for (let i = 0, n = t.length; i < n; i++)
                s.morphTargetDictionary[t[i]] = i
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function lT(s) {
    let e;
    const t = s.extensions && s.extensions[gt.KHR_DRACO_MESH_COMPRESSION];
    if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + cd(t.attributes) : e = s.indices + ":" + cd(s.attributes) + ":" + s.mode,
    s.targets !== void 0)
        for (let i = 0, n = s.targets.length; i < n; i++)
            e += ":" + cd(s.targets[i]);
    return e
}
function cd(s) {
    let e = "";
    const t = Object.keys(s).sort();
    for (let i = 0, n = t.length; i < n; i++)
        e += t[i] + ":" + s[t[i]] + ";";
    return e
}
function gf(s) {
    switch (s) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function cT(s) {
    return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const hT = new vt;
class uT {
    constructor(e={}, t={}) {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new U1,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let i = !1
          , n = !1
          , r = -1;
        typeof navigator < "u" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
        n = navigator.userAgent.indexOf("Firefox") > -1,
        r = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1),
        typeof createImageBitmap > "u" || i || n && r < 98 ? this.textureLoader = new i1(this.options.manager) : this.textureLoader = new c1(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new El(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const i = this
          , n = this.json
          , r = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][n.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: n.asset,
                parser: i,
                userData: {}
            };
            return Ts(r, a, n),
            Xr(a, n),
            Promise.all(i._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , i = this.json.meshes || [];
        for (let n = 0, r = t.length; n < r; n++) {
            const o = t[n].joints;
            for (let a = 0, l = o.length; a < l; a++)
                e[o[a]].isBone = !0
        }
        for (let n = 0, r = e.length; n < r; n++) {
            const o = e[n];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1)
            return i;
        const n = i.clone()
          , r = (o, a) => {
            const l = this.associations.get(o);
            l != null && this.associations.set(a, l);
            for (const [c,h] of o.children.entries())
                r(h, a.children[c])
        }
        ;
        return r(i, n),
        n.name += "_instance_" + e.uses[t]++,
        n
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
            const n = e(t[i]);
            if (n)
                return n
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const i = [];
        for (let n = 0; n < t.length; n++) {
            const r = e(t[n]);
            r && i.push(r)
        }
        return i
    }
    getDependency(e, t) {
        const i = e + ":" + t;
        let n = this.cache.get(i);
        if (!n) {
            switch (e) {
            case "scene":
                n = this.loadScene(t);
                break;
            case "node":
                n = this._invokeOne(function(r) {
                    return r.loadNode && r.loadNode(t)
                });
                break;
            case "mesh":
                n = this._invokeOne(function(r) {
                    return r.loadMesh && r.loadMesh(t)
                });
                break;
            case "accessor":
                n = this.loadAccessor(t);
                break;
            case "bufferView":
                n = this._invokeOne(function(r) {
                    return r.loadBufferView && r.loadBufferView(t)
                });
                break;
            case "buffer":
                n = this.loadBuffer(t);
                break;
            case "material":
                n = this._invokeOne(function(r) {
                    return r.loadMaterial && r.loadMaterial(t)
                });
                break;
            case "texture":
                n = this._invokeOne(function(r) {
                    return r.loadTexture && r.loadTexture(t)
                });
                break;
            case "skin":
                n = this.loadSkin(t);
                break;
            case "animation":
                n = this._invokeOne(function(r) {
                    return r.loadAnimation && r.loadAnimation(t)
                });
                break;
            case "camera":
                n = this.loadCamera(t);
                break;
            default:
                if (n = this._invokeOne(function(r) {
                    return r != this && r.getDependency && r.getDependency(e, t)
                }),
                !n)
                    throw new Error("Unknown type: " + e);
                break
            }
            this.cache.add(i, n)
        }
        return n
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const i = this
              , n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(n.map(function(r, o) {
                return i.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , i = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[gt.KHR_BINARY_GLTF].body);
        const n = this.options;
        return new Promise(function(r, o) {
            i.load(ol.resolveURL(t.uri, n.path), r, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(i) {
            const n = t.byteLength || 0
              , r = t.byteOffset || 0;
            return i.slice(r, r + n)
        })
    }
    loadAccessor(e) {
        const t = this
          , i = this.json
          , n = this.json.accessors[e];
        if (n.bufferView === void 0 && n.sparse === void 0) {
            const o = ad[n.type]
              , a = sa[n.componentType]
              , l = n.normalized === !0
              , c = new a(n.count * o);
            return Promise.resolve(new cn(c,o,l))
        }
        const r = [];
        return n.bufferView !== void 0 ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null),
        n.sparse !== void 0 && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
        Promise.all(r).then(function(o) {
            const a = o[0]
              , l = ad[n.type]
              , c = sa[n.componentType]
              , h = c.BYTES_PER_ELEMENT
              , u = h * l
              , d = n.byteOffset || 0
              , f = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0
              , m = n.normalized === !0;
            let _, p;
            if (f && f !== u) {
                const g = Math.floor(d / f)
                  , M = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + g + ":" + n.count;
                let y = t.cache.get(M);
                y || (_ = new c(a,g * f,n.count * f / h),
                y = new Db(_,f / h),
                t.cache.add(M, y)),
                p = new Zf(y,l,d % f / h,m)
            } else
                a === null ? _ = new c(n.count * l) : _ = new c(a,d,n.count * l),
                p = new cn(_,l,m);
            if (n.sparse !== void 0) {
                const g = ad.SCALAR
                  , M = sa[n.sparse.indices.componentType]
                  , y = n.sparse.indices.byteOffset || 0
                  , S = n.sparse.values.byteOffset || 0
                  , C = new M(o[1],y,n.sparse.count * g)
                  , w = new c(o[2],S,n.sparse.count * l);
                a !== null && (p = new cn(p.array.slice(),p.itemSize,p.normalized));
                for (let T = 0, B = C.length; T < B; T++) {
                    const b = C[T];
                    if (p.setX(b, w[T * l]),
                    l >= 2 && p.setY(b, w[T * l + 1]),
                    l >= 3 && p.setZ(b, w[T * l + 2]),
                    l >= 4 && p.setW(b, w[T * l + 3]),
                    l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return p
        })
    }
    loadTexture(e) {
        const t = this.json
          , i = this.options
          , r = t.textures[e].source
          , o = t.images[r];
        let a = this.textureLoader;
        if (o.uri) {
            const l = i.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, r, a)
    }
    loadTextureImage(e, t, i) {
        const n = this
          , r = this.json
          , o = r.textures[e]
          , a = r.images[t]
          , l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const c = this.loadImageSource(t, i).then(function(h) {
            h.flipY = !1,
            h.name = o.name || a.name || "",
            h.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (h.name = a.uri);
            const d = (r.samplers || {})[o.sampler] || {};
            return h.magFilter = Yg[d.magFilter] || as,
            h.minFilter = Yg[d.minFilter] || Fh,
            h.wrapS = $g[d.wrapS] || Ml,
            h.wrapT = $g[d.wrapT] || Ml,
            n.associations.set(h, {
                textures: e
            }),
            h
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = c,
        c
    }
    loadImageSource(e, t) {
        const i = this
          , n = this.json
          , r = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(u => u.clone());
        const o = n.images[e]
          , a = self.URL || self.webkitURL;
        let l = o.uri || ""
          , c = !1;
        if (o.bufferView !== void 0)
            l = i.getDependency("bufferView", o.bufferView).then(function(u) {
                c = !0;
                const d = new Blob([u],{
                    type: o.mimeType
                });
                return l = a.createObjectURL(d),
                l
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const h = Promise.resolve(l).then(function(u) {
            return new Promise(function(d, f) {
                let m = d;
                t.isImageBitmapLoader === !0 && (m = function(_) {
                    const p = new bn(_);
                    p.needsUpdate = !0,
                    d(p)
                }
                ),
                t.load(ol.resolveURL(u, r.path), m, void 0, f)
            }
            )
        }).then(function(u) {
            return c === !0 && a.revokeObjectURL(l),
            u.userData.mimeType = o.mimeType || cT(o.uri),
            u
        }).catch(function(u) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
            u
        });
        return this.sourceCache[e] = h,
        h
    }
    assignTexture(e, t, i, n) {
        const r = this;
        return this.getDependency("texture", i.index).then(function(o) {
            if (!o)
                return null;
            if (i.texCoord !== void 0 && i.texCoord > 0 && (o = o.clone(),
            o.channel = i.texCoord),
            r.extensions[gt.KHR_TEXTURE_TRANSFORM]) {
                const a = i.extensions !== void 0 ? i.extensions[gt.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = r.associations.get(o);
                    o = r.extensions[gt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    r.associations.set(o, l)
                }
            }
            return n !== void 0 && (o.colorSpace = n),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let i = e.material;
        const n = t.attributes.tangent === void 0
          , r = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new Ux,
            Zs.prototype.copy.call(l, i),
            l.color.copy(i.color),
            l.map = i.map,
            l.sizeAttenuation = !1,
            this.cache.add(a, l)),
            i = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new Dx,
            Zs.prototype.copy.call(l, i),
            l.color.copy(i.color),
            l.map = i.map,
            this.cache.add(a, l)),
            i = l
        }
        if (n || r || o) {
            let a = "ClonedMaterial:" + i.uuid + ":";
            n && (a += "derivative-tangents:"),
            r && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = i.clone(),
            r && (l.vertexColors = !0),
            o && (l.flatShading = !0),
            n && (l.normalScale && (l.normalScale.y *= -1),
            l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, l),
            this.associations.set(l, this.associations.get(i))),
            i = l
        }
        e.material = i
    }
    getMaterialType() {
        return Qf
    }
    loadMaterial(e) {
        const t = this
          , i = this.json
          , n = this.extensions
          , r = i.materials[e];
        let o;
        const a = {}
          , l = r.extensions || {}
          , c = [];
        if (l[gt.KHR_MATERIALS_UNLIT]) {
            const u = n[gt.KHR_MATERIALS_UNLIT];
            o = u.getMaterialType(),
            c.push(u.extendParams(a, r, t))
        } else {
            const u = r.pbrMetallicRoughness || {};
            if (a.color = new Jt(1,1,1),
            a.opacity = 1,
            Array.isArray(u.baseColorFactor)) {
                const d = u.baseColorFactor;
                a.color.setRGB(d[0], d[1], d[2], Oi),
                a.opacity = d[3]
            }
            u.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", u.baseColorTexture, ai)),
            a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1,
            a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1,
            u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)),
            c.push(t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture))),
            o = this._invokeOne(function(d) {
                return d.getMaterialType && d.getMaterialType(e)
            }),
            c.push(Promise.all(this._invokeAll(function(d) {
                return d.extendMaterialParams && d.extendMaterialParams(e, a)
            })))
        }
        r.doubleSided === !0 && (a.side = wS);
        const h = r.alphaMode || ld.OPAQUE;
        if (h === ld.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        h === ld.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)),
        r.normalTexture !== void 0 && o !== Yo && (c.push(t.assignTexture(a, "normalMap", r.normalTexture)),
        a.normalScale = new Xt(1,1),
        r.normalTexture.scale !== void 0)) {
            const u = r.normalTexture.scale;
            a.normalScale.set(u, u)
        }
        if (r.occlusionTexture !== void 0 && o !== Yo && (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
        r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)),
        r.emissiveFactor !== void 0 && o !== Yo) {
            const u = r.emissiveFactor;
            a.emissive = new Jt().setRGB(u[0], u[1], u[2], Oi)
        }
        return r.emissiveTexture !== void 0 && o !== Yo && c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, ai)),
        Promise.all(c).then(function() {
            const u = new o(a);
            return r.name && (u.name = r.name),
            Xr(u, r),
            t.associations.set(u, {
                materials: e
            }),
            r.extensions && Ts(n, u, r),
            u
        })
    }
    createUniqueName(e) {
        const t = Tt.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
        t)
    }
    loadGeometries(e) {
        const t = this
          , i = this.extensions
          , n = this.primitiveCache;
        function r(a) {
            return i[gt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return jg(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , h = lT(c)
              , u = n[h];
            if (u)
                o.push(u.promise);
            else {
                let d;
                c.extensions && c.extensions[gt.KHR_DRACO_MESH_COMPRESSION] ? d = r(c) : d = jg(new so, c, t),
                n[h] = {
                    primitive: c,
                    promise: d
                },
                o.push(d)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , i = this.json
          , n = this.extensions
          , r = i.meshes[e]
          , o = r.primitives
          , a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const h = o[l].material === void 0 ? sT(this.cache) : this.getDependency("material", o[l].material);
            a.push(h)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(l) {
            const c = l.slice(0, l.length - 1)
              , h = l[l.length - 1]
              , u = [];
            for (let f = 0, m = h.length; f < m; f++) {
                const _ = h[f]
                  , p = o[f];
                let g;
                const M = c[f];
                if (p.mode === mn.TRIANGLES || p.mode === mn.TRIANGLE_STRIP || p.mode === mn.TRIANGLE_FAN || p.mode === void 0)
                    g = r.isSkinnedMesh === !0 ? new Nb(_,M) : new kh(_,M),
                    g.isSkinnedMesh === !0 && g.normalizeSkinWeights(),
                    p.mode === mn.TRIANGLE_STRIP ? g.geometry = Xg(g.geometry, Ex) : p.mode === mn.TRIANGLE_FAN && (g.geometry = Xg(g.geometry, of));
                else if (p.mode === mn.LINES)
                    g = new zb(_,M);
                else if (p.mode === mn.LINE_STRIP)
                    g = new Jf(_,M);
                else if (p.mode === mn.LINE_LOOP)
                    g = new kb(_,M);
                else if (p.mode === mn.POINTS)
                    g = new Hb(_,M);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                Object.keys(g.geometry.morphAttributes).length > 0 && aT(g, r),
                g.name = t.createUniqueName(r.name || "mesh_" + e),
                Xr(g, r),
                p.extensions && Ts(n, g, p),
                t.assignFinalMaterial(g),
                u.push(g)
            }
            for (let f = 0, m = u.length; f < m; f++)
                t.associations.set(u[f], {
                    meshes: e,
                    primitives: f
                });
            if (u.length === 1)
                return r.extensions && Ts(n, u[0], r),
                u[0];
            const d = new Qu;
            r.extensions && Ts(n, d, r),
            t.associations.set(d, {
                meshes: e
            });
            for (let f = 0, m = u.length; f < m; f++)
                d.add(u[f]);
            return d
        })
    }
    loadCamera(e) {
        let t;
        const i = this.json.cameras[e]
          , n = i[i.type];
        if (!n) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return i.type === "perspective" ? t = new jf(rb.radToDeg(n.yfov),n.aspectRatio || 1,n.znear || 1,n.zfar || 2e6) : i.type === "orthographic" && (t = new Px(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),
        i.name && (t.name = this.createUniqueName(i.name)),
        Xr(t, i),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , i = [];
        for (let n = 0, r = t.joints.length; n < r; n++)
            i.push(this._loadNodeShallow(t.joints[n]));
        return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null),
        Promise.all(i).then(function(n) {
            const r = n.pop()
              , o = n
              , a = []
              , l = [];
            for (let c = 0, h = o.length; c < h; c++) {
                const u = o[c];
                if (u) {
                    a.push(u);
                    const d = new vt;
                    r !== null && d.fromArray(r.array, c * 16),
                    l.push(d)
                } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c])
            }
            return new Kf(a,l)
        })
    }
    loadAnimation(e) {
        const t = this.json
          , i = this
          , n = t.animations[e]
          , r = n.name ? n.name : "animation_" + e
          , o = []
          , a = []
          , l = []
          , c = []
          , h = [];
        for (let u = 0, d = n.channels.length; u < d; u++) {
            const f = n.channels[u]
              , m = n.samplers[f.sampler]
              , _ = f.target
              , p = _.node
              , g = n.parameters !== void 0 ? n.parameters[m.input] : m.input
              , M = n.parameters !== void 0 ? n.parameters[m.output] : m.output;
            _.node !== void 0 && (o.push(this.getDependency("node", p)),
            a.push(this.getDependency("accessor", g)),
            l.push(this.getDependency("accessor", M)),
            c.push(m),
            h.push(_))
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c), Promise.all(h)]).then(function(u) {
            const d = u[0]
              , f = u[1]
              , m = u[2]
              , _ = u[3]
              , p = u[4]
              , g = [];
            for (let M = 0, y = d.length; M < y; M++) {
                const S = d[M]
                  , C = f[M]
                  , w = m[M]
                  , T = _[M]
                  , B = p[M];
                if (S === void 0)
                    continue;
                S.updateMatrix && S.updateMatrix();
                const b = i._createAnimationTracks(S, C, w, T, B);
                if (b)
                    for (let E = 0; E < b.length; E++)
                        g.push(b[E])
            }
            return new $b(r,void 0,g)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , i = this
          , n = t.nodes[e];
        return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(r) {
            const o = i._getNodeRef(i.meshCache, n.mesh, r);
            return n.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, c = n.weights.length; l < c; l++)
                        a.morphTargetInfluences[l] = n.weights[l]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , i = this
          , n = t.nodes[e]
          , r = i._loadNodeShallow(e)
          , o = []
          , a = n.children || [];
        for (let c = 0, h = a.length; c < h; c++)
            o.push(i.getDependency("node", a[c]));
        const l = n.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", n.skin);
        return Promise.all([r, Promise.all(o), l]).then(function(c) {
            const h = c[0]
              , u = c[1]
              , d = c[2];
            d !== null && h.traverse(function(f) {
                f.isSkinnedMesh && f.bind(d, hT)
            });
            for (let f = 0, m = u.length; f < m; f++)
                h.add(u[f]);
            return h
        })
    }
    _loadNodeShallow(e) {
        const t = this.json
          , i = this.extensions
          , n = this;
        if (this.nodeCache[e] !== void 0)
            return this.nodeCache[e];
        const r = t.nodes[e]
          , o = r.name ? n.createUniqueName(r.name) : ""
          , a = []
          , l = n._invokeOne(function(c) {
            return c.createNodeMesh && c.createNodeMesh(e)
        });
        return l && a.push(l),
        r.camera !== void 0 && a.push(n.getDependency("camera", r.camera).then(function(c) {
            return n._getNodeRef(n.cameraCache, r.camera, c)
        })),
        n._invokeAll(function(c) {
            return c.createNodeAttachment && c.createNodeAttachment(e)
        }).forEach(function(c) {
            a.push(c)
        }),
        this.nodeCache[e] = Promise.all(a).then(function(c) {
            let h;
            if (r.isBone === !0 ? h = new Lx : c.length > 1 ? h = new Qu : c.length === 1 ? h = c[0] : h = new qt,
            h !== c[0])
                for (let u = 0, d = c.length; u < d; u++)
                    h.add(c[u]);
            if (r.name && (h.userData.name = r.name,
            h.name = o),
            Xr(h, r),
            r.extensions && Ts(i, h, r),
            r.matrix !== void 0) {
                const u = new vt;
                u.fromArray(r.matrix),
                h.applyMatrix4(u)
            } else
                r.translation !== void 0 && h.position.fromArray(r.translation),
                r.rotation !== void 0 && h.quaternion.fromArray(r.rotation),
                r.scale !== void 0 && h.scale.fromArray(r.scale);
            return n.associations.has(h) || n.associations.set(h, {}),
            n.associations.get(h).nodes = e,
            h
        }),
        this.nodeCache[e]
    }
    loadScene(e) {
        const t = this.extensions
          , i = this.json.scenes[e]
          , n = this
          , r = new Qu;
        i.name && (r.name = n.createUniqueName(i.name)),
        Xr(r, i),
        i.extensions && Ts(t, r, i);
        const o = i.nodes || []
          , a = [];
        for (let l = 0, c = o.length; l < c; l++)
            a.push(n.getDependency("node", o[l]));
        return Promise.all(a).then(function(l) {
            for (let h = 0, u = l.length; h < u; h++)
                r.add(l[h]);
            const c = h => {
                const u = new Map;
                for (const [d,f] of n.associations)
                    (d instanceof Zs || d instanceof bn) && u.set(d, f);
                return h.traverse(d => {
                    const f = n.associations.get(d);
                    f != null && u.set(d, f)
                }
                ),
                u
            }
            ;
            return n.associations = c(r),
            r
        })
    }
    _createAnimationTracks(e, t, i, n, r) {
        const o = []
          , a = e.name ? e.name : e.uuid
          , l = [];
        Vr[r.path] === Vr.weights ? e.traverse(function(d) {
            d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid)
        }) : l.push(a);
        let c;
        switch (Vr[r.path]) {
        case Vr.weights:
            c = _a;
            break;
        case Vr.rotation:
            c = io;
            break;
        case Vr.position:
        case Vr.scale:
            c = xa;
            break;
        default:
            switch (i.itemSize) {
            case 1:
                c = _a;
                break;
            case 2:
            case 3:
            default:
                c = xa;
                break
            }
            break
        }
        const h = n.interpolation !== void 0 ? rT[n.interpolation] : ga
          , u = this._getArrayFromAccessor(i);
        for (let d = 0, f = l.length; d < f; d++) {
            const m = new c(l[d] + "." + Vr[r.path],t.array,u,h);
            n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m),
            o.push(m)
        }
        return o
    }
    _getArrayFromAccessor(e) {
        let t = e.array;
        if (e.normalized) {
            const i = gf(t.constructor)
              , n = new Float32Array(t.length);
            for (let r = 0, o = t.length; r < o; r++)
                n[r] = t[r] * i;
            t = n
        }
        return t
    }
    _createCubicSplineTrackInterpolant(e) {
        e.createInterpolant = function(i) {
            const n = this instanceof io ? nT : Wx;
            return new n(this.times,this.values,this.getValueSize() / 3,i)
        }
        ,
        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}
function dT(s, e, t) {
    const i = e.attributes
      , n = new Cr;
    if (i.POSITION !== void 0) {
        const a = t.json.accessors[i.POSITION]
          , l = a.min
          , c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (n.set(new ee(l[0],l[1],l[2]), new ee(c[0],c[1],c[2])),
            a.normalized) {
                const h = gf(sa[a.componentType]);
                n.min.multiplyScalar(h),
                n.max.multiplyScalar(h)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const r = e.targets;
    if (r !== void 0) {
        const a = new ee
          , l = new ee;
        for (let c = 0, h = r.length; c < h; c++) {
            const u = r[c];
            if (u.POSITION !== void 0) {
                const d = t.json.accessors[u.POSITION]
                  , f = d.min
                  , m = d.max;
                if (f !== void 0 && m !== void 0) {
                    if (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))),
                    l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))),
                    l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))),
                    d.normalized) {
                        const _ = gf(sa[d.componentType]);
                        l.multiplyScalar(_)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        n.expandByVector(a)
    }
    s.boundingBox = n;
    const o = new Jn;
    n.getCenter(o.center),
    o.radius = n.min.distanceTo(n.max) / 2,
    s.boundingSphere = o
}
function jg(s, e, t) {
    const i = e.attributes
      , n = [];
    function r(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            s.setAttribute(a, l)
        })
    }
    for (const o in i) {
        const a = mf[o] || o.toLowerCase();
        a in s.attributes || n.push(r(i[o], a))
    }
    if (e.indices !== void 0 && !s.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            s.setIndex(a)
        });
        n.push(o)
    }
    return en.workingColorSpace !== Oi && "COLOR_0"in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${en.workingColorSpace}" not supported.`),
    Xr(s, e),
    dT(s, e, t),
    Promise.all(n).then(function() {
        return e.targets !== void 0 ? oT(s, e.targets, t) : s
    })
}
const hd = new WeakMap;
class fT extends ps {
    constructor(e) {
        super(e),
        this.decoderPath = "",
        this.decoderConfig = {},
        this.decoderBinary = null,
        this.decoderPending = null,
        this.workerLimit = 4,
        this.workerPool = [],
        this.workerNextTaskID = 1,
        this.workerSourceURL = "",
        this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        },
        this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e,
        this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e,
        this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e,
        this
    }
    load(e, t, i, n) {
        const r = new El(this.manager);
        r.setPath(this.path),
        r.setResponseType("arraybuffer"),
        r.setRequestHeader(this.requestHeader),
        r.setWithCredentials(this.withCredentials),
        r.load(e, o => {
            this.parse(o, t, n)
        }
        , i, n)
    }
    parse(e, t, i= () => {}
    ) {
        this.decodeDracoFile(e, t, null, null, ai).catch(i)
    }
    decodeDracoFile(e, t, i, n, r=Oi, o= () => {}
    ) {
        const a = {
            attributeIDs: i || this.defaultAttributeIDs,
            attributeTypes: n || this.defaultAttributeTypes,
            useUniqueIDs: !!i,
            vertexColorSpace: r
        };
        return this.decodeGeometry(e, a).then(t).catch(o)
    }
    decodeGeometry(e, t) {
        const i = JSON.stringify(t);
        if (hd.has(e)) {
            const l = hd.get(e);
            if (l.key === i)
                return l.promise;
            if (e.byteLength === 0)
                throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let n;
        const r = this.workerNextTaskID++
          , o = e.byteLength
          , a = this._getWorker(r, o).then(l => (n = l,
        new Promise( (c, h) => {
            n._callbacks[r] = {
                resolve: c,
                reject: h
            },
            n.postMessage({
                type: "decode",
                id: r,
                taskConfig: t,
                buffer: e
            }, [e])
        }
        ))).then(l => this._createGeometry(l.geometry));
        return a.catch( () => !0).then( () => {
            n && r && this._releaseTask(n, r)
        }
        ),
        hd.set(e, {
            key: i,
            promise: a
        }),
        a
    }
    _createGeometry(e) {
        const t = new so;
        e.index && t.setIndex(new cn(e.index.array,1));
        for (let i = 0; i < e.attributes.length; i++) {
            const n = e.attributes[i]
              , r = n.name
              , o = n.array
              , a = n.itemSize
              , l = new cn(o,a);
            r === "color" && (this._assignVertexColorSpace(l, n.vertexColorSpace),
            l.normalized = !(o instanceof Float32Array)),
            t.setAttribute(r, l)
        }
        return t
    }
    _assignVertexColorSpace(e, t) {
        if (t !== ai)
            return;
        const i = new Jt;
        for (let n = 0, r = e.count; n < r; n++)
            i.fromBufferAttribute(e, n).convertSRGBToLinear(),
            e.setXYZ(n, i.r, i.g, i.b)
    }
    _loadLibrary(e, t) {
        const i = new El(this.manager);
        return i.setPath(this.decoderPath),
        i.setResponseType(t),
        i.setWithCredentials(this.withCredentials),
        new Promise( (n, r) => {
            i.load(e, n, void 0, r)
        }
        )
    }
    preload() {
        return this._initDecoder(),
        this
    }
    _initDecoder() {
        if (this.decoderPending)
            return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js"
          , t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
        t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
        this.decoderPending = Promise.all(t).then(i => {
            const n = i[0];
            e || (this.decoderConfig.wasmBinary = i[1]);
            const r = pT.toString()
              , o = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }
        ),
        this.decoderPending
    }
    _getWorker(e, t) {
        return this._initDecoder().then( () => {
            if (this.workerPool.length < this.workerLimit) {
                const n = new Worker(this.workerSourceURL);
                n._callbacks = {},
                n._taskCosts = {},
                n._taskLoad = 0,
                n.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }),
                n.onmessage = function(r) {
                    const o = r.data;
                    switch (o.type) {
                    case "decode":
                        n._callbacks[o.id].resolve(o);
                        break;
                    case "error":
                        n._callbacks[o.id].reject(o);
                        break;
                    default:
                        console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }
                ,
                this.workerPool.push(n)
            } else
                this.workerPool.sort(function(n, r) {
                    return n._taskLoad > r._taskLoad ? -1 : 1
                });
            const i = this.workerPool[this.workerPool.length - 1];
            return i._taskCosts[e] = t,
            i._taskLoad += t,
            i
        }
        )
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t],
        delete e._callbacks[t],
        delete e._taskCosts[t]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
        return this.workerPool.length = 0,
        this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL),
        this
    }
}
function pT() {
    let s, e;
    onmessage = function(o) {
        const a = o.data;
        switch (a.type) {
        case "init":
            s = a.decoderConfig,
            e = new Promise(function(h) {
                s.onModuleLoaded = function(u) {
                    h({
                        draco: u
                    })
                }
                ,
                DracoDecoderModule(s)
            }
            );
            break;
        case "decode":
            const l = a.buffer
              , c = a.taskConfig;
            e.then(h => {
                const u = h.draco
                  , d = new u.Decoder;
                try {
                    const f = t(u, d, new Int8Array(l), c)
                      , m = f.attributes.map(_ => _.array.buffer);
                    f.index && m.push(f.index.array.buffer),
                    self.postMessage({
                        type: "decode",
                        id: a.id,
                        geometry: f
                    }, m)
                } catch (f) {
                    console.error(f),
                    self.postMessage({
                        type: "error",
                        id: a.id,
                        error: f.message
                    })
                } finally {
                    u.destroy(d)
                }
            }
            );
            break
        }
    }
    ;
    function t(o, a, l, c) {
        const h = c.attributeIDs
          , u = c.attributeTypes;
        let d, f;
        const m = a.GetEncodedGeometryType(l);
        if (m === o.TRIANGULAR_MESH)
            d = new o.Mesh,
            f = a.DecodeArrayToMesh(l, l.byteLength, d);
        else if (m === o.POINT_CLOUD)
            d = new o.PointCloud,
            f = a.DecodeArrayToPointCloud(l, l.byteLength, d);
        else
            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!f.ok() || d.ptr === 0)
            throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
        const _ = {
            index: null,
            attributes: []
        };
        for (const p in h) {
            const g = self[u[p]];
            let M, y;
            if (c.useUniqueIDs)
                y = h[p],
                M = a.GetAttributeByUniqueId(d, y);
            else {
                if (y = a.GetAttributeId(d, o[h[p]]),
                y === -1)
                    continue;
                M = a.GetAttribute(d, y)
            }
            const S = n(o, a, d, p, g, M);
            p === "color" && (S.vertexColorSpace = c.vertexColorSpace),
            _.attributes.push(S)
        }
        return m === o.TRIANGULAR_MESH && (_.index = i(o, a, d)),
        o.destroy(d),
        _
    }
    function i(o, a, l) {
        const h = l.num_faces() * 3
          , u = h * 4
          , d = o._malloc(u);
        a.GetTrianglesUInt32Array(l, u, d);
        const f = new Uint32Array(o.HEAPF32.buffer,d,h).slice();
        return o._free(d),
        {
            array: f,
            itemSize: 1
        }
    }
    function n(o, a, l, c, h, u) {
        const d = u.num_components()
          , m = l.num_points() * d
          , _ = m * h.BYTES_PER_ELEMENT
          , p = r(o, h)
          , g = o._malloc(_);
        a.GetAttributeDataArrayForAllPoints(l, u, p, _, g);
        const M = new h(o.HEAPF32.buffer,g,m).slice();
        return o._free(g),
        {
            name: c,
            array: M,
            itemSize: d
        }
    }
    function r(o, a) {
        switch (a) {
        case Float32Array:
            return o.DT_FLOAT32;
        case Int8Array:
            return o.DT_INT8;
        case Int16Array:
            return o.DT_INT16;
        case Int32Array:
            return o.DT_INT32;
        case Uint8Array:
            return o.DT_UINT8;
        case Uint16Array:
            return o.DT_UINT16;
        case Uint32Array:
            return o.DT_UINT32
        }
    }
}
const mT = new TS
  , gT = new I1
  , Xx = new D1
  , qx = new fT;
qx.setDecoderPath("/gl-assets/draco/");
Xx.setDRACOLoader(qx);
const _T = s => {
    const e = s.split(".").pop().split("?")[0];
    return new Promise(t => {
        e === "exr" ? gT.load(s, t) : e === "glb" ? Xx.load(s, t) : mT.load(s, t)
    }
    )
}
  , xT = s => {
    const e = s.map(t => _T(t));
    return Promise.all(e)
}
;
class yT {
    constructor({id: e, slideCount: t, autoplay: i, interval: n, reverse: r}) {
        if (e === void 0)
            throw new Error("id");
        if (t === void 0)
            throw new Error("SlideCount");
        this.slideCount = t,
        this.autoplay = i || !1,
        this.interval = n || 2,
        this.reverse = r || !1,
        this.current = 0,
        this.before = 0,
        this.updateEvent = new CustomEvent(`slider_${e}:update`),
        this.prevEvent = new CustomEvent(`slider_${e}:prev`),
        this.nextEvent = new CustomEvent(`slider_${e}:next`),
        this.changeEvent = new CustomEvent(`slider_${e}:change`),
        this.gsapTimer = this.autoplay ? Gi.to({}, {
            ease: "none",
            duration: this.interval,
            onComplete: () => {
                this.autoChange()
            }
            ,
            onUpdate: () => {
                window.dispatchEvent(this.updateEvent)
            }
        }) : null
    }
    getPrev(e=this.current) {
        return e <= 0 ? this.slideCount - 1 : e - 1
    }
    getNext(e=this.current) {
        return e >= this.slideCount - 1 ? 0 : e + 1
    }
    prev() {
        const e = this.getPrev();
        this.change(e),
        window.dispatchEvent(this.prevEvent)
    }
    next() {
        const e = this.getNext();
        this.change(e),
        window.dispatchEvent(this.nextEvent)
    }
    change(e) {
        if (e === void 0)
            throw new Error("No Change Number Error");
        this.before = this.current,
        this.current = e,
        window.dispatchEvent(this.changeEvent),
        this.restartTimer()
    }
    autoChange() {
        this.reverse ? this.prev() : this.next()
    }
    restartTimer() {
        this.gsapTimer?.restart(),
        this.autoplay = !0
    }
    sleepTimer() {
        this.gsapTimer?.pause(),
        this.autoplay = !1
    }
    dispose() {
        this.gsapTimer?.kill()
    }
}
const Di = {
    viewSize: {
        width: 0,
        height: 0
    }
}
  , ud = () => typeof ontouchstart < "u";
class vT {
    constructor({hitElement: e, blurElements: t, onLoad: i= () => {}
    }) {
        const n = new Ll(1,1)
          , r = new wr({
            uniforms: {
                uTime: {
                    value: 0
                },
                uResolution: {
                    value: new Rt(1,1)
                },
                uImage: {
                    value: {
                        texture: null,
                        aspect: 1
                    }
                },
                uBlockNoiseTexture: {
                    value: null
                },
                uShake: {
                    value: 1
                },
                uIconVisible: {
                    value: 0
                },
                uPaused: {
                    value: 0
                },
                uDpr: {
                    value: 1
                }
            },
            vertexShader: vx,
            fragmentShader: xS,
            depthTest: !1,
            depthWrite: !1
        });
        this.mesh = new Yn(n,r),
        this.currentScaleX = 0,
        this.currentScaleY = 0,
        this.scaleRatio = 0,
        this.hitElement = e,
        this.blurElements = t,
        this.textures = [];
        const o = this.blurElements.map(l => l.src);
        (async () => (this.textures = await xT(o),
        this.setImage(0),
        i()))(),
        this.slider = new yT({
            id: "main",
            slideCount: o.length,
            autoplay: !0,
            interval: .6
        }),
        this.slider.sleepTimer();
        const a = () => {
            const l = this.slider.current;
            this.setImage(l)
        }
        ;
        window.addEventListener("slider_main:change", a),
        this.hitElement.addEventListener("mouseenter", this.handleMouseEnter),
        this.hitElement.addEventListener("mouseleave", this.handleMouseLeave),
        this.hitElement.addEventListener("click", this.handleClick),
        this.hitElement.addEventListener("focus", this.handleMouseEnter),
        this.hitElement.addEventListener("blur", this.handleMouseLeave)
    }
    setImage = e => {
        const {uniforms: t} = this.mesh.material
          , i = this.textures[e]
          , n = i.image.width / i.image.height;
        t.uImage.value.texture = i,
        t.uImage.value.aspect = n;
        const o = Math.min(Di.viewSize.width, Di.viewSize.height) * Wv
          , a = o * (n > 1 ? 1 : n)
          , l = o * (n > 1 ? 1 / n : 1);
        this.currentScaleX = a,
        this.currentScaleY = l,
        t.uResolution.value.x = a,
        t.uResolution.value.y = l,
        this.hitElement.style.transform = `scale(${a}, ${l})`,
        this.blurElements.forEach( (c, h) => {
            c.style.opacity = h === e ? 1 : 0
        }
        )
    }
    ;
    update = ({time: e, blockNoiseTexture: t}) => {
        const {uniforms: i} = this.mesh.material;
        i.uTime.value = e,
        i.uBlockNoiseTexture.value = t,
        i.uDpr.value = Math.min(window.devicePixelRatio, 2),
        this.mesh.scale.set(this.currentScaleX, this.currentScaleY, 1).multiplyScalar(this.scaleRatio),
        i.uPaused.value = ud() ? this.slider.autoplay : !this.slider.autoplay
    }
    ;
    handleMouseEnter = () => {
        ud() || (this.mesh.material.uniforms.uIconVisible.value = !0)
    }
    ;
    handleMouseLeave = () => {
        this.mesh.material.uniforms.uIconVisible.value = !1
    }
    ;
    handleClick = () => {
        this.slider.autoplay ? this.slider.sleepTimer() : this.slider.restartTimer(),
        ud() && Gi.fromTo(this.mesh.material.uniforms.uIconVisible, {
            value: 1
        }, {
            value: 0,
            duration: 1,
            ease: "power3.inOut"
        })
    }
    ;
    resize = () => {
        this.setImage(this.slider.current)
    }
}
const dd = new ne
  , MT = new ne
  , ST = new mt;
class Ps {
    constructor(e=new ne(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, n) {
        return this.normal.set(e, t, i),
        this.constant = n,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const n = dd.subVectors(i, t).cross(MT.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(dd)
          , n = this.normal.dot(i);
        if (n === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / n;
        return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || ST.getNormalMatrix(e)
          , n = this.coplanarPoint(dd).applyMatrix4(e)
          , r = this.normal.applyMatrix3(i).normalize();
        return this.constant = -n.dot(r),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Es = new Wf
  , Wc = new ne;
class Yx {
    constructor(e=new Ps, t=new Ps, i=new Ps, n=new Ps, r=new Ps, o=new Ps) {
        this.planes = [e, t, i, n, r, o]
    }
    set(e, t, i, n, r, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(n),
        a[4].copy(r),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t=vr) {
        const i = this.planes
          , n = e.elements
          , r = n[0]
          , o = n[1]
          , a = n[2]
          , l = n[3]
          , c = n[4]
          , h = n[5]
          , u = n[6]
          , d = n[7]
          , f = n[8]
          , m = n[9]
          , _ = n[10]
          , p = n[11]
          , g = n[12]
          , M = n[13]
          , y = n[14]
          , S = n[15];
        if (i[0].setComponents(l - r, d - c, p - f, S - g).normalize(),
        i[1].setComponents(l + r, d + c, p + f, S + g).normalize(),
        i[2].setComponents(l + o, d + h, p + m, S + M).normalize(),
        i[3].setComponents(l - o, d - h, p - m, S - M).normalize(),
        i[4].setComponents(l - a, d - u, p - _, S - y).normalize(),
        t === vr)
            i[5].setComponents(l + a, d + u, p + _, S + y).normalize();
        else if (t === wh)
            i[5].setComponents(a, u, _, y).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Es.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            Es.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Es)
    }
    intersectsSprite(e) {
        return Es.center.set(0, 0, 0),
        Es.radius = .7071067811865476,
        Es.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Es)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , n = -e.radius;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(i) < n)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const n = t[i];
            if (Wc.x = n.normal.x > 0 ? e.max.x : e.min.x,
            Wc.y = n.normal.y > 0 ? e.max.y : e.min.y,
            Wc.z = n.normal.z > 0 ? e.max.z : e.min.z,
            n.distanceToPoint(Wc) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class pi {
    constructor(e=0, t=0, i=0, n=1) {
        pi.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = n
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, n) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , n = this.z
          , r = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * n + o[12] * r,
        this.y = o[1] * t + o[5] * i + o[9] * n + o[13] * r,
        this.z = o[2] * t + o[6] * i + o[10] * n + o[14] * r,
        this.w = o[3] * t + o[7] * i + o[11] * n + o[15] * r,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, n, r;
        const l = e.elements
          , c = l[0]
          , h = l[4]
          , u = l[8]
          , d = l[1]
          , f = l[5]
          , m = l[9]
          , _ = l[2]
          , p = l[6]
          , g = l[10];
        if (Math.abs(h - d) < .01 && Math.abs(u - _) < .01 && Math.abs(m - p) < .01) {
            if (Math.abs(h + d) < .1 && Math.abs(u + _) < .1 && Math.abs(m + p) < .1 && Math.abs(c + f + g - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const y = (c + 1) / 2
              , S = (f + 1) / 2
              , C = (g + 1) / 2
              , w = (h + d) / 4
              , T = (u + _) / 4
              , B = (m + p) / 4;
            return y > S && y > C ? y < .01 ? (i = 0,
            n = .707106781,
            r = .707106781) : (i = Math.sqrt(y),
            n = w / i,
            r = T / i) : S > C ? S < .01 ? (i = .707106781,
            n = 0,
            r = .707106781) : (n = Math.sqrt(S),
            i = w / n,
            r = B / n) : C < .01 ? (i = .707106781,
            n = .707106781,
            r = 0) : (r = Math.sqrt(C),
            i = T / r,
            n = B / r),
            this.set(i, n, r, t),
            this
        }
        let M = Math.sqrt((p - m) * (p - m) + (u - _) * (u - _) + (d - h) * (d - h));
        return Math.abs(M) < .001 && (M = 1),
        this.x = (p - m) / M,
        this.y = (u - _) / M,
        this.z = (d - h) / M,
        this.w = Math.acos((c + f + g - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
function $x() {
    let s = null
      , e = !1
      , t = null
      , i = null;
    function n(r, o) {
        t(r, o),
        i = s.requestAnimationFrame(n)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = s.requestAnimationFrame(n),
            e = !0)
        },
        stop: function() {
            s.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(r) {
            t = r
        },
        setContext: function(r) {
            s = r
        }
    }
}
function bT(s, e) {
    const t = e.isWebGL2
      , i = new WeakMap;
    function n(c, h) {
        const u = c.array
          , d = c.usage
          , f = u.byteLength
          , m = s.createBuffer();
        s.bindBuffer(h, m),
        s.bufferData(h, u, d),
        c.onUploadCallback();
        let _;
        if (u instanceof Float32Array)
            _ = s.FLOAT;
        else if (u instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
                if (t)
                    _ = s.HALF_FLOAT;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                _ = s.UNSIGNED_SHORT;
        else if (u instanceof Int16Array)
            _ = s.SHORT;
        else if (u instanceof Uint32Array)
            _ = s.UNSIGNED_INT;
        else if (u instanceof Int32Array)
            _ = s.INT;
        else if (u instanceof Int8Array)
            _ = s.BYTE;
        else if (u instanceof Uint8Array)
            _ = s.UNSIGNED_BYTE;
        else if (u instanceof Uint8ClampedArray)
            _ = s.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
        return {
            buffer: m,
            type: _,
            bytesPerElement: u.BYTES_PER_ELEMENT,
            version: c.version,
            size: f
        }
    }
    function r(c, h, u) {
        const d = h.array
          , f = h._updateRange
          , m = h.updateRanges;
        if (s.bindBuffer(u, c),
        f.count === -1 && m.length === 0 && s.bufferSubData(u, 0, d),
        m.length !== 0) {
            for (let _ = 0, p = m.length; _ < p; _++) {
                const g = m[_];
                t ? s.bufferSubData(u, g.start * d.BYTES_PER_ELEMENT, d, g.start, g.count) : s.bufferSubData(u, g.start * d.BYTES_PER_ELEMENT, d.subarray(g.start, g.start + g.count))
            }
            h.clearUpdateRanges()
        }
        f.count !== -1 && (t ? s.bufferSubData(u, f.offset * d.BYTES_PER_ELEMENT, d, f.offset, f.count) : s.bufferSubData(u, f.offset * d.BYTES_PER_ELEMENT, d.subarray(f.offset, f.offset + f.count)),
        f.count = -1),
        h.onUploadCallback()
    }
    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data),
        i.get(c)
    }
    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        const h = i.get(c);
        h && (s.deleteBuffer(h.buffer),
        i.delete(c))
    }
    function l(c, h) {
        if (c.isGLBufferAttribute) {
            const d = i.get(c);
            (!d || d.version < c.version) && i.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version
            });
            return
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        const u = i.get(c);
        if (u === void 0)
            i.set(c, n(c, h));
        else if (u.version < c.version) {
            if (u.size !== c.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            r(u.buffer, c, h),
            u.version = c.version
        }
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class Ul extends Pl {
    constructor(e=1, t=1, i=1, n=1, r=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: o
        };
        const a = this;
        n = Math.floor(n),
        r = Math.floor(r),
        o = Math.floor(o);
        const l = []
          , c = []
          , h = []
          , u = [];
        let d = 0
          , f = 0;
        m("z", "y", "x", -1, -1, i, t, e, o, r, 0),
        m("z", "y", "x", 1, -1, i, t, -e, o, r, 1),
        m("x", "z", "y", 1, 1, e, i, t, n, o, 2),
        m("x", "z", "y", 1, -1, e, i, -t, n, o, 3),
        m("x", "y", "z", 1, -1, e, t, i, n, r, 4),
        m("x", "y", "z", -1, -1, e, t, -i, n, r, 5),
        this.setIndex(l),
        this.setAttribute("position", new js(c,3)),
        this.setAttribute("normal", new js(h,3)),
        this.setAttribute("uv", new js(u,2));
        function m(_, p, g, M, y, S, C, w, T, B, b) {
            const E = S / T
              , G = C / B
              , k = S / 2
              , te = C / 2
              , O = w / 2
              , H = T + 1
              , V = B + 1;
            let Y = 0
              , K = 0;
            const J = new ne;
            for (let D = 0; D < V; D++) {
                const se = D * G - te;
                for (let de = 0; de < H; de++) {
                    const Q = de * E - k;
                    J[_] = Q * M,
                    J[p] = se * y,
                    J[g] = O,
                    c.push(J.x, J.y, J.z),
                    J[_] = 0,
                    J[p] = 0,
                    J[g] = w > 0 ? 1 : -1,
                    h.push(J.x, J.y, J.z),
                    u.push(de / T),
                    u.push(1 - D / B),
                    Y += 1
                }
            }
            for (let D = 0; D < B; D++)
                for (let se = 0; se < T; se++) {
                    const de = d + se + H * D
                      , Q = d + se + H * (D + 1)
                      , re = d + (se + 1) + H * (D + 1)
                      , ge = d + (se + 1) + H * D;
                    l.push(de, Q, ge),
                    l.push(Q, re, ge),
                    K += 6
                }
            a.addGroup(f, K, b),
            f += K,
            d += Y
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ul(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
const TT = `
#ifdef USE_ALPHAHASH

	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;

#endif
`
  , ET = `
#ifdef USE_ALPHAHASH

	/**
	 * See: https://casual-effects.com/research/Wyman2017Hashed/index.html
	 */

	const float ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

	float hash2D( vec2 value ) {

		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );

	}

	float hash3D( vec3 value ) {

		return hash2D( vec2( hash2D( value.xy ), value.z ) );

	}

	float getAlphaHashThreshold( vec3 position ) {

		// Find the discretized derivatives of our coordinates
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );

		// Find two nearest log-discretized noise scales
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);

		// Compute alpha thresholds at our two noise scales
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);

		// Factor to interpolate lerp with
		float lerpFactor = fract( log2( pixScale ) );

		// Interpolate alpha threshold from noise at two scales
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;

		// Pass into CDF to compute uniformly distrib threshold
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);

		// Find our final, uniformly distributed alpha threshold ()
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;

		// Avoids  == 0. Could also do  =1-
		return clamp( threshold , 1.0e-6, 1.0 );

	}

#endif
`
  , wT = `
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;

#endif
`
  , AT = `
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`
  , RT = `
#ifdef USE_ALPHATEST

	if ( diffuseColor.a < alphaTest ) discard;

#endif
`
  , CT = `
#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif
`
  , PT = `
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif

	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );

	#endif

#endif
`
  , LT = `
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`
  , IT = `
#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {

		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );

	}
#endif
`
  , DT = `
#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif
`
  , UT = `
vec3 transformed = vec3( position );

#ifdef USE_ALPHAHASH

	vPosition = vec3( position );

#endif
`
  , NT = `
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`
  , FT = `

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( specularColor, 1.0, dotVH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

`
  , OT = `

#ifdef USE_IRIDESCENCE

	// XYZ to linear-sRGB color space
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);

	// Assume air interface for top
	// Note: We don't handle the case fresnel0 == 1
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {

		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );

	}

	// Conversion FO/IOR
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {

		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );

	}

	// ior is a value between 1.0 and 3.0. 1.0 is air interface
	float IorToFresnel0( float transmittedIor, float incidentIor ) {

		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));

	}

	// Fresnel equations for dielectric/dielectric interfaces.
	// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
	// Evaluation XYZ sensitivity curves in Fourier space
	vec3 evalSensitivity( float OPD, vec3 shift ) {

		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;

		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;

	}

	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {

		vec3 I;

		// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		// Evaluate the cosTheta on the base layer (Snell law)
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );

		// Handle TIR:
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {

			return vec3( 1.0 );

		}

		float cosTheta2 = sqrt( cosTheta2Sq );

		// First interface
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;

		// Second interface
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0
		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;

		// Phase shift
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;

		// Compound terms
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );

		// Reflectance term for m = 0 (DC term amplitude)
		vec3 C0 = R12 + Rs;
		I = C0;

		// Reflectance term for m > 0 (pairs of diracs)
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {

			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;

		}

		// Since out of gamut colors might be produced, negative color values are clamped to 0.
		return max( I, vec3( 0.0 ) );

	}

#endif

`
  , BT = `
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );

		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// normalize is done to ensure that the bump map looks the same regardless of the texture's scale
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm; // normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`
  , zT = `
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`
  , kT = `
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`
  , HT = `
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`
  , GT = `
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`
  , VT = `
#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif
`
  , WT = `
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif
`
  , XT = `
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	varying vec3 vColor;

#endif
`
  , qT = `
#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif
`
  , YT = `
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }

// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {

	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );

	return fract( sin( sn ) * c );

}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

#ifdef USE_ALPHAHASH

	varying vec3 vPosition;

#endif

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

float luminance( const in vec3 rgb ) {

	// assumes rgb is in linear color space with sRGB primaries and D65 white point

	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );

	return dot( weights, rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated
`
  , $T = `
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		uv.x += filterInt * 3.0 * cubeUV_minTileSize;

		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;

		#ifdef texture2DGradEXT

			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

		#else

			return texture2D( envMap, uv ).rgb;

		#endif

	}

	// These defines must match with PMREMGenerator

	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= cubeUV_r1 ) {

			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;

		} else if ( roughness >= cubeUV_r4 ) {

			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;

		} else if ( roughness >= cubeUV_r5 ) {

			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;

		} else if ( roughness >= cubeUV_r6 ) {

			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`
  , jT = `

vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT

	vec3 transformedTangent = objectTangent;

#endif

#ifdef USE_BATCHING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;

	#ifdef USE_TANGENT

		transformedTangent = bm * transformedTangent;

	#endif

#endif

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;

	#ifdef USE_TANGENT

		transformedTangent = im * transformedTangent;

	#endif

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`
  , ZT = `
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`
  , KT = `
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );

#endif
`
  , JT = `
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`
  , QT = `
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`
  , eE = `
gl_FragColor = linearToOutputTexel( gl_FragColor );
`
  , tE = `

// http://www.russellcottrell.com/photo/matrixCalculator.htm

// Linear sRGB => XYZ => Linear Display P3
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);

// Linear Display P3 => XYZ => Linear sRGB
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);

vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}

vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}

vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}

vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

// @deprecated, r156
vec4 LinearToLinear( in vec4 value ) {
	return value;
}

// @deprecated, r156
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}
`
  , iE = `
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`
  , nE = `
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`
  , rE = `
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`
  , sE = `
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`
  , oE = `
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`
  , aE = `
#ifdef USE_FOG

	vFogDepth = - mvPosition.z;

#endif
`
  , lE = `
#ifdef USE_FOG

	varying float vFogDepth;

#endif
`
  , cE = `
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`
  , hE = `
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float vFogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`
  , uE = `

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return vec3( texture2D( gradientMap, coord ).r );

	#else

		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );

	#endif

}
`
  , dE = `
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;

	reflectedLight.indirectDiffuse += lightMapIrradiance;

#endif
`
  , fE = `
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`
  , pE = `
LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;
`
  , mE = `
varying vec3 vViewPosition;

struct LambertMaterial {

	vec3 diffuseColor;
	float specularStrength;

};

void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
`
  , gE = `
uniform bool receiveShadow;
uniform vec3 ambientLightColor;

#if defined( USE_LIGHT_PROBES )

	uniform vec3 lightProbe[ 9 ];

#endif

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {

	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	return irradiance;

}

float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

	#if defined ( LEGACY_LIGHTS )

		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );

		}

		return 1.0;

	#else

		// based upon Frostbite 3 Moving to Physically-based Rendering
		// page 32, equation 26: E[window1]
		// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

		if ( cutoffDistance > 0.0 ) {

			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

		}

		return distanceFalloff;

	#endif

}

float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {

	return smoothstep( coneCosine, penumbraCosine, angleCosine );

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {

		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {

		vec3 lVector = pointLight.position - geometryPosition;

		light.direction = normalize( lVector );

		float lightDistance = length( lVector );

		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {

		vec3 lVector = spotLight.position - geometryPosition;

		light.direction = normalize( lVector );

		float angleCos = dot( light.direction, spotLight.direction );

		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );

		if ( spotAttenuation > 0.0 ) {

			float lightDistance = length( lVector );

			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );

		} else {

			light.color = vec3( 0.0 );
			light.visible = false;

		}

	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {

		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		return irradiance;

	}

#endif
`
  , _E = `
#ifdef USE_ENVMAP

	vec3 getIBLIrradiance( const in vec3 normal ) {

		#ifdef ENVMAP_TYPE_CUBE_UV

			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

			return PI * envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {

		#ifdef ENVMAP_TYPE_CUBE_UV

			vec3 reflectVec = reflect( - viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

			return envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	#ifdef USE_ANISOTROPY

		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {

			#ifdef ENVMAP_TYPE_CUBE_UV

			  // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );

				return getIBLRadiance( viewDir, bentNormal, roughness );

			#else

				return vec3( 0.0 );

			#endif

		}

	#endif

#endif
`
  , xE = `
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`
  , yE = `
varying vec3 vViewPosition;

struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
`
  , vE = `
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`
  , ME = `
varying vec3 vViewPosition;

struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
`
  , SE = `
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );

#ifdef IOR

	material.ior = ior;

	#ifdef USE_SPECULAR

		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;

		#ifdef USE_SPECULAR_COLORMAP

			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;

		#endif

		#ifdef USE_SPECULAR_INTENSITYMAP

			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;

		#endif

		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );

	#else

		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;

	#endif

	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;

#endif

#ifdef USE_CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_IRIDESCENCE

	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;

	#ifdef USE_IRIDESCENCEMAP

		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;

	#endif

	#ifdef USE_IRIDESCENCE_THICKNESSMAP

		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;

	#else

		material.iridescenceThickness = iridescenceThicknessMaximum;

	#endif

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheenColor;

	#ifdef USE_SHEEN_COLORMAP

		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;

	#endif

	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );

	#ifdef USE_SHEEN_ROUGHNESSMAP

		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;

	#endif

#endif

#ifdef USE_ANISOTROPY

	#ifdef USE_ANISOTROPYMAP

		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;

	#else

		vec2 anisotropyV = anisotropyVector;

	#endif

	material.anisotropy = length( anisotropyV );

	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}

	// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );

	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;

#endif
`
  , bE = `

struct PhysicalMaterial {

	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;

	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif

	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif

	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif

	#ifdef IOR
		float ior;
	#endif

	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif

	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif

};

// temporary
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );

vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );

    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf
#ifdef USE_ANISOTROPY

	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {

		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );

		return saturate(v);

	}

	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {

		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;

		return RECIPROCAL_PI * a2 * pow2 ( w2 );

	}

#endif

#ifdef USE_CLEARCOAT

	// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {

		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;

		float alpha = pow2( roughness ); // UE4's roughness

		vec3 halfDir = normalize( lightDir + viewDir );

		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );

		vec3 F = F_Schlick( f0, f90, dotVH );

		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

		float D = D_GGX( alpha, dotNH );

		return F * ( V * D );

	}

#endif

vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {

	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( f0, f90, dotVH );

	#ifdef USE_IRIDESCENCE

		F = mix( F, material.iridescenceFresnel, material.iridescence );

	#endif

	#ifdef USE_ANISOTROPY

		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );

		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );

		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );

	#else

		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

		float D = D_GGX( alpha, dotNH );

	#endif

	return F * ( V * D );

}

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float D_Charlie( float roughness, float dotNH ) {

	float alpha = pow2( roughness );

	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );

}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float V_Neubelt( float dotNV, float dotNL ) {

	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );

}

vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );

	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );

	return sheenColor * ( D * V );

}

#endif

// This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from 
// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	float r2 = roughness * roughness;

	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;

	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;

	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );

	return saturate( DG * RECIPROCAL_PI );

}

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;

	return fab;

}

vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	return specularColor * fab.x + specularF90 * fab.y;

}

// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	#ifdef USE_IRIDESCENCE

		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );

	#else

		vec3 Fr = specularColor;

	#endif

	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;

	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifdef USE_CLEARCOAT

		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = dotNLcc * directLight.color;

		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );

	#endif

	#ifdef USE_SHEEN

		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );

	#endif

	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef USE_CLEARCOAT

		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

	#endif

	#ifdef USE_SHEEN

		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );

	#endif

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	#ifdef USE_IRIDESCENCE

		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );

	#else

		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );

	#endif

	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );

	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`
  , TE = `
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE

	float dotNVi = saturate( dot( normal, geometryViewDir ) );

	if ( material.iridescenceThickness == 0.0 ) {

		material.iridescence = 0.0;

	} else {

		material.iridescence = saturate( material.iridescence );

	}

	if ( material.iridescence > 0.0 ) {

		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );

		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );

	}

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif

		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif

		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`
  , EE = `
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getIBLIrradiance( geometryNormal );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	#ifdef USE_ANISOTROPY

		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );

	#else

		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );

	#endif

	#ifdef USE_CLEARCOAT

		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );

	#endif

#endif
`
  , wE = `
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

#endif
`
  , AE = `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`
  , RE = `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`
  , CE = `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`
  , PE = `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`
  , LE = `
#ifdef USE_MAP

	vec4 sampledDiffuseColor = texture2D( map, vMapUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// use inline sRGB decode until browsers properly support SRGB8_APLHA8 with video textures

		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif

	diffuseColor *= sampledDiffuseColor;

#endif
`
  , IE = `
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`
  , DE = `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	#if defined( USE_POINTS_UV )

		vec2 uv = vUv;

	#else

		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

	#endif

#endif

#ifdef USE_MAP

	diffuseColor *= texture2D( map, uv );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`
  , UE = `
#if defined( USE_POINTS_UV )

	varying vec2 vUv;

#else

	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

		uniform mat3 uvTransform;

	#endif

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`
  , NE = `
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`
  , FE = `
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`
  , OE = `
#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	vColor *= morphTargetBaseInfluence;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		#if defined( USE_COLOR_ALPHA )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];

		#elif defined( USE_COLOR )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];

		#endif

	}

#endif
`
  , BE = `
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];

		}

	#else

		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

	#endif

#endif
`
  , zE = `
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;

		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {

			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;

			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );

		}

	#else

		#ifndef USE_MORPHNORMALS

			uniform float morphTargetInfluences[ 8 ];

		#else

			uniform float morphTargetInfluences[ 4 ];

		#endif

	#endif

#endif
`
  , kE = `
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];

		}

	#else

		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];

		#ifndef USE_MORPHNORMALS

			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];

		#endif

	#endif

#endif
`
  , HE = `
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal *= faceDirection;

	#endif

#endif

#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )

	#ifdef USE_TANGENT

		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

	#else

		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);

	#endif

	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;

	#endif

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	#ifdef USE_TANGENT

		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

	#else

		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );

	#endif

	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 nonPerturbedNormal = normal;

`
  , GE = `

#ifdef USE_NORMALMAP_OBJECTSPACE

	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( USE_NORMALMAP_TANGENTSPACE )

	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	normal = normalize( tbn * mapN );

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`
  , VE = `
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`
  , WE = `
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`
  , XE = `
#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif
`
  , qE = `
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef USE_NORMALMAP_OBJECTSPACE

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {

		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );

		return mat3( T * scale, B * scale, N );

	}

#endif
`
  , YE = `
#ifdef USE_CLEARCOAT

	vec3 clearcoatNormal = nonPerturbedNormal;

#endif
`
  , $E = `
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	clearcoatNormal = normalize( tbn2 * clearcoatMapN );

#endif
`
  , jE = `

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif
`
  , ZE = `

#ifdef USE_IRIDESCENCEMAP

	uniform sampler2D iridescenceMap;

#endif

#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform sampler2D iridescenceThicknessMap;

#endif
`
  , KE = `
#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif

#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif

gl_FragColor = vec4( outgoingLight, diffuseColor.a );
`
  , JE = `
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}

float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}

vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	// -near maps to 0; -far maps to 1
	return ( viewZ + near ) / ( near - far );
}

float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	// maps orthographic depth in [ 0, 1 ] to viewZ
	return depth * ( near - far ) - near;
}

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	// -near maps to 0; -far maps to 1
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}

float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	// maps perspective depth in [ 0, 1 ] to viewZ
	return ( near * far ) / ( ( far - near ) * depth - far );
}
`
  , QE = `
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`
  , ew = `
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_BATCHING

	mvPosition = batchingMatrix * mvPosition;

#endif

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`
  , tw = `
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`
  , iw = `
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift according to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`
  , nw = `
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`
  , rw = `
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`
  , sw = `
#if NUM_SPOT_LIGHT_COORDS > 0

	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#if NUM_SPOT_LIGHT_MAPS > 0

	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];

#endif

#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`
  , ow = `

#if NUM_SPOT_LIGHT_COORDS > 0

	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`
  , aw = `

#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )

	// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;

#endif

#if defined( USE_SHADOWMAP )

	#if NUM_DIR_LIGHT_SHADOWS > 0

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

		}
		#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

		}
		#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif

// spot lights can be evaluated without active shadow mapping (when SpotLight.map is used)

#if NUM_SPOT_LIGHT_COORDS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {

		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

#endif


`
  , lw = `
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`
  , cw = `
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`
  , hw = `
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	uniform highp sampler2D boneTexture;

	mat4 getBoneMatrix( const in float i ) {

		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );

		return mat4( v1, v2, v3, v4 );

	}

#endif
`
  , uw = `
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`
  , dw = `
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`
  , fw = `
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`
  , pw = `
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`
  , mw = `
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`
  , gw = `
#ifndef saturate
// <common> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return saturate( toneMappingExposure * color );

}

// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

// Matrices for rec 2020 <> rec 709 color space conversion
// matrix provided in row-major order so it has been transposed
// https://www.itu.int/pub/R-REP-BT.2407-2017
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);

const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);

// https://iolite-engine.com/blog_posts/minimal_agx_implementation
// Mean error^2: 3.6705141e-06
vec3 agxDefaultContrastApprox( vec3 x ) {

	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;

	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;

}

// Input and output encoded as Linear-sRGB.
vec3 AgXToneMapping( vec3 color ) {

	// AgX constants
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);

	// explicit AgXOutsetMatrix generated from Filaments AgXOutsetMatrixInv
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);

	const float AgxMinEv = - 12.47393;  // log2(pow(2, LOG2_MIN) * MIDDLE_GRAY)
	const float AgxMaxEv = 4.026069;    // log2(pow(2, LOG2_MAX) * MIDDLE_GRAY)

	// AGX Tone Mapping implementation based on Filament, which is in turn based
	// on Blender's implementation for rec 2020 colors:
	// https://github.com/google/filament/pull/7236
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;

	color = AgXInsetMatrix * color;

	// Log2 encoding
	color = max( color, 1e-10 ); // avoid 0 or negative numbers for log2
	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );

	color = clamp( color, 0.0, 1.0 );

	// Apply sigmoid
	color = agxDefaultContrastApprox( color );

	// Apply AgX look
	// v = agxLook(v, look);

	color = AgXOutsetMatrix * color;

	// Linearize
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );

	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;

	return color;

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`
  , _w = `
#ifdef USE_TRANSMISSION

	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;

	#ifdef USE_TRANSMISSIONMAP

		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;

	#endif

	#ifdef USE_THICKNESSMAP

		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;

	#endif

	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );

	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );

	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );

	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );

#endif
`
  , xw = `
#ifdef USE_TRANSMISSION

	// Transmission code is based on glTF-Sampler-Viewer
	// https://github.com/KhronosGroup/glTF-Sample-Viewer

	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;

	#ifdef USE_TRANSMISSIONMAP

		uniform sampler2D transmissionMap;

	#endif

	#ifdef USE_THICKNESSMAP

		uniform sampler2D thicknessMap;

	#endif

	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;

	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;

	varying vec3 vWorldPosition;

	// Mipped Bicubic Texture Filtering by N8
	// https://www.shadertoy.com/view/Dl2SDW

	float w0( float a ) {

		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );

	}

	float w1( float a ) {

		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );

	}

	float w2( float a ){

		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );

	}

	float w3( float a ) {

		return ( 1.0 / 6.0 ) * ( a * a * a );

	}

	// g0 and g1 are the two amplitude functions
	float g0( float a ) {

		return w0( a ) + w1( a );

	}

	float g1( float a ) {

		return w2( a ) + w3( a );

	}

	// h0 and h1 are the two offset functions
	float h0( float a ) {

		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );

	}

	float h1( float a ) {

		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );

	}

	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {

		uv = uv * texelSize.zw + 0.5;

		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );

		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );

		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;

		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );

	}

	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {

		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );

	}

	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {

		// Direction of refracted light.
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );

		// Compute rotation-independant scaling of the model matrix.
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		// The thickness is specified in local space.
		return normalize( refractionVector ) * thickness * modelScale;

	}

	float applyIorToRoughness( const in float roughness, const in float ior ) {

		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );

	}

	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {

		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );

	}

	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {

		if ( isinf( attenuationDistance ) ) {

			// Attenuation distance is +, i.e. the transmitted color is not attenuated at all.
			return vec3( 1.0 );

		} else {

			// Compute light attenuation using Beer's law.
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
			return transmittance;

		}

	}

	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {

		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;

		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;

		// Sample framebuffer to get pixel the refracted ray hits.
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );

		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;

		// Get the specular component.
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );

		// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job 
		// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;

		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );

	}
#endif
`
  , yw = `
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;

#endif
#ifdef USE_MAP

	varying vec2 vMapUv;

#endif
#ifdef USE_ALPHAMAP

	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	varying vec2 vNormalMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_SPECULARMAP

	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`
  , vw = `
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`
  , Mw = `
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	vUv = vec3( uv, 1 ).xy;

#endif
#ifdef USE_MAP

	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ALPHAMAP

	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_LIGHTMAP

	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_AOMAP

	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_BUMPMAP

	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_NORMALMAP

	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_DISPLACEMENTMAP

	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_EMISSIVEMAP

	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_METALNESSMAP

	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ROUGHNESSMAP

	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ANISOTROPYMAP

	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOATMAP

	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_IRIDESCENCEMAP

	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SHEEN_COLORMAP

	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULARMAP

	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULAR_COLORMAP

	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_TRANSMISSIONMAP

	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_THICKNESSMAP

	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;

#endif
`
  , Sw = `
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_BATCHING

		worldPosition = batchingMatrix * worldPosition;

	#endif

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`
  , bw = `
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`
  , Tw = `
uniform sampler2D t2D;
uniform float backgroundIntensity;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// use inline sRGB decode until browsers properly support SRGB8_APLHA8 with video textures

		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

	#endif

	texColor.rgb *= backgroundIntensity;

	gl_FragColor = texColor;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`
  , Ew = `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`
  , ww = `

#ifdef ENVMAP_TYPE_CUBE

	uniform samplerCube envMap;

#elif defined( ENVMAP_TYPE_CUBE_UV )

	uniform sampler2D envMap;

#endif

uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	#ifdef ENVMAP_TYPE_CUBE

		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );

	#else

		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );

	#endif

	texColor.rgb *= backgroundIntensity;

	gl_FragColor = texColor;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`
  , Aw = `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`
  , Rw = `
uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;

varying vec3 vWorldDirection;

void main() {

	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );

	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`
  , Cw = `
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <batching_vertex>
	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`
  , Pw = `
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`
  , Lw = `
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <batching_vertex>
	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`
  , Iw = `
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`
  , Dw = `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`
  , Uw = `
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	gl_FragColor = texture2D( tEquirect, sampleUV );

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`
  , Nw = `
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`
  , Fw = `
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`
  , Ow = `
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`
  , Bw = `
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
  , zw = `
#define LAMBERT

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`
  , kw = `
#define LAMBERT

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
  , Hw = `
#define MATCAP

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`
  , Gw = `
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );

	#else

		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 ); // default if matcap is missing

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
  , Vw = `
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	varying vec3 vViewPosition;

#endif

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	vViewPosition = - mvPosition.xyz;

#endif

}
`
  , Ww = `
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	varying vec3 vViewPosition;

#endif

#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

	#ifdef OPAQUE

		gl_FragColor.a = 1.0;

	#endif

}
`
  , Xw = `
#define PHONG

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`
  , qw = `
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
  , Yw = `
#define STANDARD

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

	varying vec3 vWorldPosition;

#endif

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

#ifdef USE_TRANSMISSION

	vWorldPosition = worldPosition.xyz;

#endif
}
`
  , $w = `
#define STANDARD

#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
	uniform float ior;
#endif

#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;

	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif

	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif

#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;

	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif

	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif

#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;

	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	#include <transmission_fragment>

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	#ifdef USE_SHEEN

		// Sheen energy compensation approximation calculation can be found at the end of
		// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;

	#endif

	#ifdef USE_CLEARCOAT

		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );

		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;

	#endif

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
  , jw = `
#define TOON

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`
  , Zw = `
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
  , Kw = `
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_POINTS_UV

	varying vec2 vUv;
	uniform mat3 uvTransform;

#endif

void main() {

	#ifdef USE_POINTS_UV

		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	#endif

	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`
  , Jw = `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`
  , Qw = `
#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`
  , eA = `
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	#include <logdepthbuf_fragment>

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>

}
`
  , tA = `
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`
  , iA = `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>

}
`
  , ht = {
    alphahash_fragment: TT,
    alphahash_pars_fragment: ET,
    alphamap_fragment: wT,
    alphamap_pars_fragment: AT,
    alphatest_fragment: RT,
    alphatest_pars_fragment: CT,
    aomap_fragment: PT,
    aomap_pars_fragment: LT,
    batching_pars_vertex: IT,
    batching_vertex: DT,
    begin_vertex: UT,
    beginnormal_vertex: NT,
    bsdfs: FT,
    iridescence_fragment: OT,
    bumpmap_pars_fragment: BT,
    clipping_planes_fragment: zT,
    clipping_planes_pars_fragment: kT,
    clipping_planes_pars_vertex: HT,
    clipping_planes_vertex: GT,
    color_fragment: VT,
    color_pars_fragment: WT,
    color_pars_vertex: XT,
    color_vertex: qT,
    common: YT,
    cube_uv_reflection_fragment: $T,
    defaultnormal_vertex: jT,
    displacementmap_pars_vertex: ZT,
    displacementmap_vertex: KT,
    emissivemap_fragment: JT,
    emissivemap_pars_fragment: QT,
    colorspace_fragment: eE,
    colorspace_pars_fragment: tE,
    envmap_fragment: iE,
    envmap_common_pars_fragment: nE,
    envmap_pars_fragment: rE,
    envmap_pars_vertex: sE,
    envmap_physical_pars_fragment: _E,
    envmap_vertex: oE,
    fog_vertex: aE,
    fog_pars_vertex: lE,
    fog_fragment: cE,
    fog_pars_fragment: hE,
    gradientmap_pars_fragment: uE,
    lightmap_fragment: dE,
    lightmap_pars_fragment: fE,
    lights_lambert_fragment: pE,
    lights_lambert_pars_fragment: mE,
    lights_pars_begin: gE,
    lights_toon_fragment: xE,
    lights_toon_pars_fragment: yE,
    lights_phong_fragment: vE,
    lights_phong_pars_fragment: ME,
    lights_physical_fragment: SE,
    lights_physical_pars_fragment: bE,
    lights_fragment_begin: TE,
    lights_fragment_maps: EE,
    lights_fragment_end: wE,
    logdepthbuf_fragment: AE,
    logdepthbuf_pars_fragment: RE,
    logdepthbuf_pars_vertex: CE,
    logdepthbuf_vertex: PE,
    map_fragment: LE,
    map_pars_fragment: IE,
    map_particle_fragment: DE,
    map_particle_pars_fragment: UE,
    metalnessmap_fragment: NE,
    metalnessmap_pars_fragment: FE,
    morphcolor_vertex: OE,
    morphnormal_vertex: BE,
    morphtarget_pars_vertex: zE,
    morphtarget_vertex: kE,
    normal_fragment_begin: HE,
    normal_fragment_maps: GE,
    normal_pars_fragment: VE,
    normal_pars_vertex: WE,
    normal_vertex: XE,
    normalmap_pars_fragment: qE,
    clearcoat_normal_fragment_begin: YE,
    clearcoat_normal_fragment_maps: $E,
    clearcoat_pars_fragment: jE,
    iridescence_pars_fragment: ZE,
    opaque_fragment: KE,
    packing: JE,
    premultiplied_alpha_fragment: QE,
    project_vertex: ew,
    dithering_fragment: tw,
    dithering_pars_fragment: iw,
    roughnessmap_fragment: nw,
    roughnessmap_pars_fragment: rw,
    shadowmap_pars_fragment: sw,
    shadowmap_pars_vertex: ow,
    shadowmap_vertex: aw,
    shadowmask_pars_fragment: lw,
    skinbase_vertex: cw,
    skinning_pars_vertex: hw,
    skinning_vertex: uw,
    skinnormal_vertex: dw,
    specularmap_fragment: fw,
    specularmap_pars_fragment: pw,
    tonemapping_fragment: mw,
    tonemapping_pars_fragment: gw,
    transmission_fragment: _w,
    transmission_pars_fragment: xw,
    uv_pars_fragment: yw,
    uv_pars_vertex: vw,
    uv_vertex: Mw,
    worldpos_vertex: Sw,
    background_vert: bw,
    background_frag: Tw,
    backgroundCube_vert: Ew,
    backgroundCube_frag: ww,
    cube_vert: Aw,
    cube_frag: Rw,
    depth_vert: Cw,
    depth_frag: Pw,
    distanceRGBA_vert: Lw,
    distanceRGBA_frag: Iw,
    equirect_vert: Dw,
    equirect_frag: Uw,
    linedashed_vert: Nw,
    linedashed_frag: Fw,
    meshbasic_vert: Ow,
    meshbasic_frag: Bw,
    meshlambert_vert: zw,
    meshlambert_frag: kw,
    meshmatcap_vert: Hw,
    meshmatcap_frag: Gw,
    meshnormal_vert: Vw,
    meshnormal_frag: Ww,
    meshphong_vert: Xw,
    meshphong_frag: qw,
    meshphysical_vert: Yw,
    meshphysical_frag: $w,
    meshtoon_vert: jw,
    meshtoon_frag: Zw,
    points_vert: Kw,
    points_frag: Jw,
    shadow_vert: Qw,
    shadow_frag: eA,
    sprite_vert: tA,
    sprite_frag: iA
}
  , Te = {
    common: {
        diffuse: {
            value: new At(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new mt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new mt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new mt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new mt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new mt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new mt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new mt
        },
        normalScale: {
            value: new Rt(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new mt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new mt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new mt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new mt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new At(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new At(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new mt
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new mt
        }
    },
    sprite: {
        diffuse: {
            value: new At(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Rt(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new mt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new mt
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Gn = {
    basic: {
        uniforms: Ai([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.fog]),
        vertexShader: ht.meshbasic_vert,
        fragmentShader: ht.meshbasic_frag
    },
    lambert: {
        uniforms: Ai([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.fog, Te.lights, {
            emissive: {
                value: new At(0)
            }
        }]),
        vertexShader: ht.meshlambert_vert,
        fragmentShader: ht.meshlambert_frag
    },
    phong: {
        uniforms: Ai([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.fog, Te.lights, {
            emissive: {
                value: new At(0)
            },
            specular: {
                value: new At(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: ht.meshphong_vert,
        fragmentShader: ht.meshphong_frag
    },
    standard: {
        uniforms: Ai([Te.common, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.roughnessmap, Te.metalnessmap, Te.fog, Te.lights, {
            emissive: {
                value: new At(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: ht.meshphysical_vert,
        fragmentShader: ht.meshphysical_frag
    },
    toon: {
        uniforms: Ai([Te.common, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.gradientmap, Te.fog, Te.lights, {
            emissive: {
                value: new At(0)
            }
        }]),
        vertexShader: ht.meshtoon_vert,
        fragmentShader: ht.meshtoon_frag
    },
    matcap: {
        uniforms: Ai([Te.common, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: ht.meshmatcap_vert,
        fragmentShader: ht.meshmatcap_frag
    },
    points: {
        uniforms: Ai([Te.points, Te.fog]),
        vertexShader: ht.points_vert,
        fragmentShader: ht.points_frag
    },
    dashed: {
        uniforms: Ai([Te.common, Te.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: ht.linedashed_vert,
        fragmentShader: ht.linedashed_frag
    },
    depth: {
        uniforms: Ai([Te.common, Te.displacementmap]),
        vertexShader: ht.depth_vert,
        fragmentShader: ht.depth_frag
    },
    normal: {
        uniforms: Ai([Te.common, Te.bumpmap, Te.normalmap, Te.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ht.meshnormal_vert,
        fragmentShader: ht.meshnormal_frag
    },
    sprite: {
        uniforms: Ai([Te.sprite, Te.fog]),
        vertexShader: ht.sprite_vert,
        fragmentShader: ht.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new mt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: ht.background_vert,
        fragmentShader: ht.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: ht.backgroundCube_vert,
        fragmentShader: ht.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: ht.cube_vert,
        fragmentShader: ht.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ht.equirect_vert,
        fragmentShader: ht.equirect_frag
    },
    distanceRGBA: {
        uniforms: Ai([Te.common, Te.displacementmap, {
            referencePosition: {
                value: new ne
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: ht.distanceRGBA_vert,
        fragmentShader: ht.distanceRGBA_frag
    },
    shadow: {
        uniforms: Ai([Te.lights, Te.fog, {
            color: {
                value: new At(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ht.shadow_vert,
        fragmentShader: ht.shadow_frag
    }
};
Gn.physical = {
    uniforms: Ai([Gn.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new mt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new mt
        },
        clearcoatNormalScale: {
            value: new Rt(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new mt
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new mt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new mt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new At(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new mt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new mt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new mt
        },
        transmissionSamplerSize: {
            value: new Rt
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new mt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new At(0)
        },
        specularColor: {
            value: new At(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new mt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new mt
        },
        anisotropyVector: {
            value: new Rt
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new mt
        }
    }]),
    vertexShader: ht.meshphysical_vert,
    fragmentShader: ht.meshphysical_frag
};
const Xc = {
    r: 0,
    b: 0,
    g: 0
};
function nA(s, e, t, i, n, r, o) {
    const a = new At(0);
    let l = r === !0 ? 0 : 1, c, h, u = null, d = 0, f = null;
    function m(p, g) {
        let M = !1
          , y = g.isScene === !0 ? g.background : null;
        y && y.isTexture && (y = (g.backgroundBlurriness > 0 ? t : e).get(y)),
        y === null ? _(a, l) : y && y.isColor && (_(y, 1),
        M = !0);
        const S = s.xr.getEnvironmentBlendMode();
        S === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : S === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
        (s.autoClear || M) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil),
        y && (y.isCubeTexture || y.mapping === Dh) ? (h === void 0 && (h = new Yn(new Ul(1,1,1),new wr({
            name: "BackgroundCubeMaterial",
            uniforms: ma(Gn.backgroundCube.uniforms),
            vertexShader: Gn.backgroundCube.vertexShader,
            fragmentShader: Gn.backgroundCube.fragmentShader,
            side: Yi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        h.geometry.deleteAttribute("normal"),
        h.geometry.deleteAttribute("uv"),
        h.onBeforeRender = function(C, w, T) {
            this.matrixWorld.copyPosition(T.matrixWorld)
        }
        ,
        Object.defineProperty(h.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        n.update(h)),
        h.material.uniforms.envMap.value = y,
        h.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1,
        h.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness,
        h.material.uniforms.backgroundIntensity.value = g.backgroundIntensity,
        h.material.toneMapped = wt.getTransfer(y.colorSpace) !== It,
        (u !== y || d !== y.version || f !== s.toneMapping) && (h.material.needsUpdate = !0,
        u = y,
        d = y.version,
        f = s.toneMapping),
        h.layers.enableAll(),
        p.unshift(h, h.geometry, h.material, 0, 0, null)) : y && y.isTexture && (c === void 0 && (c = new Yn(new Ll(2,2),new wr({
            name: "BackgroundMaterial",
            uniforms: ma(Gn.background.uniforms),
            vertexShader: Gn.background.vertexShader,
            fragmentShader: Gn.background.fragmentShader,
            side: us,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        n.update(c)),
        c.material.uniforms.t2D.value = y,
        c.material.uniforms.backgroundIntensity.value = g.backgroundIntensity,
        c.material.toneMapped = wt.getTransfer(y.colorSpace) !== It,
        y.matrixAutoUpdate === !0 && y.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(y.matrix),
        (u !== y || d !== y.version || f !== s.toneMapping) && (c.material.needsUpdate = !0,
        u = y,
        d = y.version,
        f = s.toneMapping),
        c.layers.enableAll(),
        p.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function _(p, g) {
        p.getRGB(Xc, xx(s)),
        i.buffers.color.setClear(Xc.r, Xc.g, Xc.b, g, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(p, g=1) {
            a.set(p),
            l = g,
            _(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(p) {
            l = p,
            _(a, l)
        },
        render: m
    }
}
function rA(s, e, t, i) {
    const n = s.getParameter(s.MAX_VERTEX_ATTRIBS)
      , r = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , o = i.isWebGL2 || r !== null
      , a = {}
      , l = p(null);
    let c = l
      , h = !1;
    function u(O, H, V, Y, K) {
        let J = !1;
        if (o) {
            const D = _(Y, V, H);
            c !== D && (c = D,
            f(c.object)),
            J = g(O, Y, V, K),
            J && M(O, Y, V, K)
        } else {
            const D = H.wireframe === !0;
            (c.geometry !== Y.id || c.program !== V.id || c.wireframe !== D) && (c.geometry = Y.id,
            c.program = V.id,
            c.wireframe = D,
            J = !0)
        }
        K !== null && t.update(K, s.ELEMENT_ARRAY_BUFFER),
        (J || h) && (h = !1,
        B(O, H, V, Y),
        K !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t.get(K).buffer))
    }
    function d() {
        return i.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES()
    }
    function f(O) {
        return i.isWebGL2 ? s.bindVertexArray(O) : r.bindVertexArrayOES(O)
    }
    function m(O) {
        return i.isWebGL2 ? s.deleteVertexArray(O) : r.deleteVertexArrayOES(O)
    }
    function _(O, H, V) {
        const Y = V.wireframe === !0;
        let K = a[O.id];
        K === void 0 && (K = {},
        a[O.id] = K);
        let J = K[H.id];
        J === void 0 && (J = {},
        K[H.id] = J);
        let D = J[Y];
        return D === void 0 && (D = p(d()),
        J[Y] = D),
        D
    }
    function p(O) {
        const H = []
          , V = []
          , Y = [];
        for (let K = 0; K < n; K++)
            H[K] = 0,
            V[K] = 0,
            Y[K] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: H,
            enabledAttributes: V,
            attributeDivisors: Y,
            object: O,
            attributes: {},
            index: null
        }
    }
    function g(O, H, V, Y) {
        const K = c.attributes
          , J = H.attributes;
        let D = 0;
        const se = V.getAttributes();
        for (const de in se)
            if (se[de].location >= 0) {
                const re = K[de];
                let ge = J[de];
                if (ge === void 0 && (de === "instanceMatrix" && O.instanceMatrix && (ge = O.instanceMatrix),
                de === "instanceColor" && O.instanceColor && (ge = O.instanceColor)),
                re === void 0 || re.attribute !== ge || ge && re.data !== ge.data)
                    return !0;
                D++
            }
        return c.attributesNum !== D || c.index !== Y
    }
    function M(O, H, V, Y) {
        const K = {}
          , J = H.attributes;
        let D = 0;
        const se = V.getAttributes();
        for (const de in se)
            if (se[de].location >= 0) {
                let re = J[de];
                re === void 0 && (de === "instanceMatrix" && O.instanceMatrix && (re = O.instanceMatrix),
                de === "instanceColor" && O.instanceColor && (re = O.instanceColor));
                const ge = {};
                ge.attribute = re,
                re && re.data && (ge.data = re.data),
                K[de] = ge,
                D++
            }
        c.attributes = K,
        c.attributesNum = D,
        c.index = Y
    }
    function y() {
        const O = c.newAttributes;
        for (let H = 0, V = O.length; H < V; H++)
            O[H] = 0
    }
    function S(O) {
        C(O, 0)
    }
    function C(O, H) {
        const V = c.newAttributes
          , Y = c.enabledAttributes
          , K = c.attributeDivisors;
        V[O] = 1,
        Y[O] === 0 && (s.enableVertexAttribArray(O),
        Y[O] = 1),
        K[O] !== H && ((i.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](O, H),
        K[O] = H)
    }
    function w() {
        const O = c.newAttributes
          , H = c.enabledAttributes;
        for (let V = 0, Y = H.length; V < Y; V++)
            H[V] !== O[V] && (s.disableVertexAttribArray(V),
            H[V] = 0)
    }
    function T(O, H, V, Y, K, J, D) {
        D === !0 ? s.vertexAttribIPointer(O, H, V, K, J) : s.vertexAttribPointer(O, H, V, Y, K, J)
    }
    function B(O, H, V, Y) {
        if (i.isWebGL2 === !1 && (O.isInstancedMesh || Y.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        y();
        const K = Y.attributes
          , J = V.getAttributes()
          , D = H.defaultAttributeValues;
        for (const se in J) {
            const de = J[se];
            if (de.location >= 0) {
                let Q = K[se];
                if (Q === void 0 && (se === "instanceMatrix" && O.instanceMatrix && (Q = O.instanceMatrix),
                se === "instanceColor" && O.instanceColor && (Q = O.instanceColor)),
                Q !== void 0) {
                    const re = Q.normalized
                      , ge = Q.itemSize
                      , fe = t.get(Q);
                    if (fe === void 0)
                        continue;
                    const ve = fe.buffer
                      , Ue = fe.type
                      , ke = fe.bytesPerElement
                      , Ve = i.isWebGL2 === !0 && (Ue === s.INT || Ue === s.UNSIGNED_INT || Q.gpuType === Q0);
                    if (Q.isInterleavedBufferAttribute) {
                        const Ke = Q.data
                          , $ = Ke.stride
                          , Qe = Q.offset;
                        if (Ke.isInstancedInterleavedBuffer) {
                            for (let Re = 0; Re < de.locationSize; Re++)
                                C(de.location + Re, Ke.meshPerAttribute);
                            O.isInstancedMesh !== !0 && Y._maxInstanceCount === void 0 && (Y._maxInstanceCount = Ke.meshPerAttribute * Ke.count)
                        } else
                            for (let Re = 0; Re < de.locationSize; Re++)
                                S(de.location + Re);
                        s.bindBuffer(s.ARRAY_BUFFER, ve);
                        for (let Re = 0; Re < de.locationSize; Re++)
                            T(de.location + Re, ge / de.locationSize, Ue, re, $ * ke, (Qe + ge / de.locationSize * Re) * ke, Ve)
                    } else {
                        if (Q.isInstancedBufferAttribute) {
                            for (let Ke = 0; Ke < de.locationSize; Ke++)
                                C(de.location + Ke, Q.meshPerAttribute);
                            O.isInstancedMesh !== !0 && Y._maxInstanceCount === void 0 && (Y._maxInstanceCount = Q.meshPerAttribute * Q.count)
                        } else
                            for (let Ke = 0; Ke < de.locationSize; Ke++)
                                S(de.location + Ke);
                        s.bindBuffer(s.ARRAY_BUFFER, ve);
                        for (let Ke = 0; Ke < de.locationSize; Ke++)
                            T(de.location + Ke, ge / de.locationSize, Ue, re, ge * ke, ge / de.locationSize * Ke * ke, Ve)
                    }
                } else if (D !== void 0) {
                    const re = D[se];
                    if (re !== void 0)
                        switch (re.length) {
                        case 2:
                            s.vertexAttrib2fv(de.location, re);
                            break;
                        case 3:
                            s.vertexAttrib3fv(de.location, re);
                            break;
                        case 4:
                            s.vertexAttrib4fv(de.location, re);
                            break;
                        default:
                            s.vertexAttrib1fv(de.location, re)
                        }
                }
            }
        }
        w()
    }
    function b() {
        k();
        for (const O in a) {
            const H = a[O];
            for (const V in H) {
                const Y = H[V];
                for (const K in Y)
                    m(Y[K].object),
                    delete Y[K];
                delete H[V]
            }
            delete a[O]
        }
    }
    function E(O) {
        if (a[O.id] === void 0)
            return;
        const H = a[O.id];
        for (const V in H) {
            const Y = H[V];
            for (const K in Y)
                m(Y[K].object),
                delete Y[K];
            delete H[V]
        }
        delete a[O.id]
    }
    function G(O) {
        for (const H in a) {
            const V = a[H];
            if (V[O.id] === void 0)
                continue;
            const Y = V[O.id];
            for (const K in Y)
                m(Y[K].object),
                delete Y[K];
            delete V[O.id]
        }
    }
    function k() {
        te(),
        h = !0,
        c !== l && (c = l,
        f(c.object))
    }
    function te() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: u,
        reset: k,
        resetDefaultState: te,
        dispose: b,
        releaseStatesOfGeometry: E,
        releaseStatesOfProgram: G,
        initAttributes: y,
        enableAttribute: S,
        disableUnusedAttributes: w
    }
}
function sA(s, e, t, i) {
    const n = i.isWebGL2;
    let r;
    function o(h) {
        r = h
    }
    function a(h, u) {
        s.drawArrays(r, h, u),
        t.update(u, r, 1)
    }
    function l(h, u, d) {
        if (d === 0)
            return;
        let f, m;
        if (n)
            f = s,
            m = "drawArraysInstanced";
        else if (f = e.get("ANGLE_instanced_arrays"),
        m = "drawArraysInstancedANGLE",
        f === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        f[m](r, h, u, d),
        t.update(u, r, d)
    }
    function c(h, u, d) {
        if (d === 0)
            return;
        const f = e.get("WEBGL_multi_draw");
        if (f === null)
            for (let m = 0; m < d; m++)
                this.render(h[m], u[m]);
        else {
            f.multiDrawArraysWEBGL(r, h, 0, u, 0, d);
            let m = 0;
            for (let _ = 0; _ < d; _++)
                m += u[_];
            t.update(m, r, 1)
        }
    }
    this.setMode = o,
    this.render = a,
    this.renderInstances = l,
    this.renderMultiDraw = c
}
function oA(s, e, t) {
    let i;
    function n() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const T = e.get("EXT_texture_filter_anisotropic");
            i = s.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function r(T) {
        if (T === "highp") {
            if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
                return "highp";
            T = "mediump"
        }
        return T === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && s.constructor.name === "WebGL2RenderingContext";
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = r(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."),
    a = l);
    const c = o || e.has("WEBGL_draw_buffers")
      , h = t.logarithmicDepthBuffer === !0
      , u = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS)
      , d = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , f = s.getParameter(s.MAX_TEXTURE_SIZE)
      , m = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE)
      , _ = s.getParameter(s.MAX_VERTEX_ATTRIBS)
      , p = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS)
      , g = s.getParameter(s.MAX_VARYING_VECTORS)
      , M = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS)
      , y = d > 0
      , S = o || e.has("OES_texture_float")
      , C = y && S
      , w = o ? s.getParameter(s.MAX_SAMPLES) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: n,
        getMaxPrecision: r,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: u,
        maxVertexTextures: d,
        maxTextureSize: f,
        maxCubemapSize: m,
        maxAttributes: _,
        maxVertexUniforms: p,
        maxVaryings: g,
        maxFragmentUniforms: M,
        vertexTextures: y,
        floatFragmentTextures: S,
        floatVertexTextures: C,
        maxSamples: w
    }
}
function aA(s) {
    const e = this;
    let t = null
      , i = 0
      , n = !1
      , r = !1;
    const o = new Ps
      , a = new mt
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(u, d) {
        const f = u.length !== 0 || d || i !== 0 || n;
        return n = d,
        i = u.length,
        f
    }
    ,
    this.beginShadows = function() {
        r = !0,
        h(null)
    }
    ,
    this.endShadows = function() {
        r = !1
    }
    ,
    this.setGlobalState = function(u, d) {
        t = h(u, d, 0)
    }
    ,
    this.setState = function(u, d, f) {
        const m = u.clippingPlanes
          , _ = u.clipIntersection
          , p = u.clipShadows
          , g = s.get(u);
        if (!n || m === null || m.length === 0 || r && !p)
            r ? h(null) : c();
        else {
            const M = r ? 0 : i
              , y = M * 4;
            let S = g.clippingState || null;
            l.value = S,
            S = h(m, d, y, f);
            for (let C = 0; C !== y; ++C)
                S[C] = t[C];
            g.clippingState = S,
            this.numIntersection = _ ? this.numPlanes : 0,
            this.numPlanes += M
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function h(u, d, f, m) {
        const _ = u !== null ? u.length : 0;
        let p = null;
        if (_ !== 0) {
            if (p = l.value,
            m !== !0 || p === null) {
                const g = f + _ * 4
                  , M = d.matrixWorldInverse;
                a.getNormalMatrix(M),
                (p === null || p.length < g) && (p = new Float32Array(g));
                for (let y = 0, S = f; y !== _; ++y,
                S += 4)
                    o.copy(u[y]).applyMatrix4(M, a),
                    o.normal.toArray(p, S),
                    p[S + 3] = o.constant
            }
            l.value = p,
            l.needsUpdate = !0
        }
        return e.numPlanes = _,
        e.numIntersection = 0,
        p
    }
}
class lA extends ya {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new pi(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new pi(0,0,e,t);
        const n = {
            width: e,
            height: t,
            depth: 1
        };
        i.encoding !== void 0 && (tl("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
        i.colorSpace = i.encoding === $s ? ui : xn),
        i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Hi,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0
        }, i),
        this.texture = new zn(n,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = i.generateMipmaps,
        this.texture.internalFormat = i.internalFormat,
        this.depthBuffer = i.depthBuffer,
        this.stencilBuffer = i.stencilBuffer,
        this.depthTexture = i.depthTexture,
        this.samples = i.samples
    }
    setSize(e, t, i=1) {
        (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e,
        this.height = t,
        this.depth = i,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = i,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Sx(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class no extends lA {
    constructor(e=1, t=1, i={}) {
        super(e, t, i),
        this.isWebGLRenderTarget = !0
    }
}
class jx extends Ar {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new $i,
        this.projectionMatrix = new $i,
        this.projectionMatrixInverse = new $i,
        this.coordinateSystem = vr
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Nn extends jx {
    constructor(e=50, t=1, i=.1, n=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = n,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = $d * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(lu * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return $d * 2 * Math.atan(Math.tan(lu * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, n, r, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = n,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(lu * .5 * this.fov) / this.zoom
          , i = 2 * t
          , n = this.aspect * i
          , r = -.5 * n;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            r += o.offsetX * n / l,
            t -= o.offsetY * i / c,
            n *= o.width / l,
            i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (r += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const Bo = -90
  , zo = 1;
class cA extends Ar {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const n = new Nn(Bo,zo,e,t);
        n.layers = this.layers,
        this.add(n);
        const r = new Nn(Bo,zo,e,t);
        r.layers = this.layers,
        this.add(r);
        const o = new Nn(Bo,zo,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new Nn(Bo,zo,e,t);
        a.layers = this.layers,
        this.add(a);
        const l = new Nn(Bo,zo,e,t);
        l.layers = this.layers,
        this.add(l);
        const c = new Nn(Bo,zo,e,t);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [i,n,r,o,a,l] = t;
        for (const c of t)
            this.remove(c);
        if (e === vr)
            i.up.set(0, 1, 0),
            i.lookAt(1, 0, 0),
            n.up.set(0, 1, 0),
            n.lookAt(-1, 0, 0),
            r.up.set(0, 0, -1),
            r.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (e === wh)
            i.up.set(0, -1, 0),
            i.lookAt(-1, 0, 0),
            n.up.set(0, -1, 0),
            n.lookAt(1, 0, 0),
            r.up.set(0, 0, 1),
            r.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: i, activeMipmapLevel: n} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [r,o,a,l,c,h] = this.children
          , u = e.getRenderTarget()
          , d = e.getActiveCubeFace()
          , f = e.getActiveMipmapLevel()
          , m = e.xr.enabled;
        e.xr.enabled = !1;
        const _ = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0, n),
        e.render(t, r),
        e.setRenderTarget(i, 1, n),
        e.render(t, o),
        e.setRenderTarget(i, 2, n),
        e.render(t, a),
        e.setRenderTarget(i, 3, n),
        e.render(t, l),
        e.setRenderTarget(i, 4, n),
        e.render(t, c),
        i.texture.generateMipmaps = _,
        e.setRenderTarget(i, 5, n),
        e.render(t, h),
        e.setRenderTarget(u, d, f),
        e.xr.enabled = m,
        i.texture.needsPMREMUpdate = !0
    }
}
class Zx extends zn {
    constructor(e, t, i, n, r, o, a, l, c, h) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : da,
        super(e, t, i, n, r, o, a, l, c, h),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class hA extends no {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , n = [i, i, i, i, i, i];
        t.encoding !== void 0 && (tl("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
        t.colorSpace = t.encoding === $s ? ui : xn),
        this.texture = new Zx(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Hi
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , n = new Ul(5,5,5)
          , r = new wr({
            name: "CubemapFromEquirect",
            uniforms: ma(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Yi,
            blending: rs
        });
        r.uniforms.tEquirect.value = t;
        const o = new Yn(n,r)
          , a = t.minFilter;
        return t.minFilter === xl && (t.minFilter = Hi),
        new cA(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, n) {
        const r = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, n);
        e.setRenderTarget(r)
    }
}
function uA(s) {
    let e = new WeakMap;
    function t(o, a) {
        return a === Jd ? o.mapping = da : a === Qd && (o.mapping = fa),
        o
    }
    function i(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === Jd || a === Qd)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new hA(l.height / 2);
                        return c.fromEquirectangularTexture(s, o),
                        e.set(o, c),
                        o.addEventListener("dispose", n),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function n(o) {
        const a = o.target;
        a.removeEventListener("dispose", n);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function r() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class Kx extends jx {
    constructor(e=-1, t=1, i=1, n=-1, r=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = n,
        this.near = r,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, n, r, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = n,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , n = (this.top + this.bottom) / 2;
        let r = i - e
          , o = i + e
          , a = n + t
          , l = n - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += c * this.view.offsetX,
            o = r + c * this.view.width,
            a -= h * this.view.offsetY,
            l = a - h * this.view.height
        }
        this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const $o = 4
  , Zg = [.125, .215, .35, .446, .526, .582]
  , Ds = 20
  , fd = new Kx
  , Kg = new At;
let pd = null
  , md = 0
  , gd = 0;
const Ls = (1 + Math.sqrt(5)) / 2
  , ko = 1 / Ls
  , Jg = [new ne(1,1,1), new ne(-1,1,1), new ne(1,1,-1), new ne(-1,1,-1), new ne(0,Ls,ko), new ne(0,Ls,-ko), new ne(ko,0,Ls), new ne(-ko,0,Ls), new ne(Ls,ko,0), new ne(-Ls,ko,0)];
class Qg {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, n=100) {
        pd = this._renderer.getRenderTarget(),
        md = this._renderer.getActiveCubeFace(),
        gd = this._renderer.getActiveMipmapLevel(),
        this._setSize(256);
        const r = this._allocateTargets();
        return r.depthBuffer = !0,
        this._sceneToCubeUV(e, i, n, r),
        t > 0 && this._blur(r, 0, 0, t),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = i_(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = t_(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(pd, md, gd),
        e.scissorTest = !1,
        qc(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === da || e.mapping === fa ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        pd = this._renderer.getRenderTarget(),
        md = this._renderer.getActiveCubeFace(),
        gd = this._renderer.getActiveMipmapLevel();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: Hi,
            minFilter: Hi,
            generateMipmaps: !1,
            type: yl,
            format: On,
            colorSpace: Er,
            depthBuffer: !1
        }
          , n = e_(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = e_(e, t, i);
            const {_lodMax: r} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = dA(r)),
            this._blurMaterial = fA(r, e, t)
        }
        return n
    }
    _compileMaterial(e) {
        const t = new Yn(this._lodPlanes[0],e);
        this._renderer.compile(t, fd)
    }
    _sceneToCubeUV(e, t, i, n) {
        const a = new Nn(90,1,t,i)
          , l = [1, -1, 1, 1, 1, 1]
          , c = [1, 1, 1, -1, -1, -1]
          , h = this._renderer
          , u = h.autoClear
          , d = h.toneMapping;
        h.getClearColor(Kg),
        h.toneMapping = ss,
        h.autoClear = !1;
        const f = new yx({
            name: "PMREM.Background",
            side: Yi,
            depthWrite: !1,
            depthTest: !1
        })
          , m = new Yn(new Ul,f);
        let _ = !1;
        const p = e.background;
        p ? p.isColor && (f.color.copy(p),
        e.background = null,
        _ = !0) : (f.color.copy(Kg),
        _ = !0);
        for (let g = 0; g < 6; g++) {
            const M = g % 3;
            M === 0 ? (a.up.set(0, l[g], 0),
            a.lookAt(c[g], 0, 0)) : M === 1 ? (a.up.set(0, 0, l[g]),
            a.lookAt(0, c[g], 0)) : (a.up.set(0, l[g], 0),
            a.lookAt(0, 0, c[g]));
            const y = this._cubeSize;
            qc(n, M * y, g > 2 ? y : 0, y, y),
            h.setRenderTarget(n),
            _ && h.render(m, a),
            h.render(e, a)
        }
        m.geometry.dispose(),
        m.material.dispose(),
        h.toneMapping = d,
        h.autoClear = u,
        e.background = p
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , n = e.mapping === da || e.mapping === fa;
        n ? (this._cubemapMaterial === null && (this._cubemapMaterial = i_()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = t_());
        const r = n ? this._cubemapMaterial : this._equirectMaterial
          , o = new Yn(this._lodPlanes[0],r)
          , a = r.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        qc(t, 0, 0, 3 * l, 2 * l),
        i.setRenderTarget(t),
        i.render(o, fd)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        for (let n = 1; n < this._lodPlanes.length; n++) {
            const r = Math.sqrt(this._sigmas[n] * this._sigmas[n] - this._sigmas[n - 1] * this._sigmas[n - 1])
              , o = Jg[(n - 1) % Jg.length];
            this._blur(e, n - 1, n, r, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, n, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, n, "latitudinal", r),
        this._halfBlur(o, e, i, i, n, "longitudinal", r)
    }
    _halfBlur(e, t, i, n, r, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const h = 3
          , u = new Yn(this._lodPlanes[n],c)
          , d = c.uniforms
          , f = this._sizeLods[i] - 1
          , m = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * Ds - 1)
          , _ = r / m
          , p = isFinite(r) ? 1 + Math.floor(h * _) : Ds;
        p > Ds && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${Ds}`);
        const g = [];
        let M = 0;
        for (let T = 0; T < Ds; ++T) {
            const B = T / _
              , b = Math.exp(-B * B / 2);
            g.push(b),
            T === 0 ? M += b : T < p && (M += 2 * b)
        }
        for (let T = 0; T < g.length; T++)
            g[T] = g[T] / M;
        d.envMap.value = e.texture,
        d.samples.value = p,
        d.weights.value = g,
        d.latitudinal.value = o === "latitudinal",
        a && (d.poleAxis.value = a);
        const {_lodMax: y} = this;
        d.dTheta.value = m,
        d.mipInt.value = y - i;
        const S = this._sizeLods[n]
          , C = 3 * S * (n > y - $o ? n - y + $o : 0)
          , w = 4 * (this._cubeSize - S);
        qc(t, C, w, 3 * S, 2 * S),
        l.setRenderTarget(t),
        l.render(u, fd)
    }
}
function dA(s) {
    const e = []
      , t = []
      , i = [];
    let n = s;
    const r = s - $o + 1 + Zg.length;
    for (let o = 0; o < r; o++) {
        const a = Math.pow(2, n);
        t.push(a);
        let l = 1 / a;
        o > s - $o ? l = Zg[o - s + $o - 1] : o === 0 && (l = 0),
        i.push(l);
        const c = 1 / (a - 2)
          , h = -c
          , u = 1 + c
          , d = [h, h, u, h, u, u, h, h, u, u, h, u]
          , f = 6
          , m = 6
          , _ = 3
          , p = 2
          , g = 1
          , M = new Float32Array(_ * m * f)
          , y = new Float32Array(p * m * f)
          , S = new Float32Array(g * m * f);
        for (let w = 0; w < f; w++) {
            const T = w % 3 * 2 / 3 - 1
              , B = w > 2 ? 0 : -1
              , b = [T, B, 0, T + 2 / 3, B, 0, T + 2 / 3, B + 1, 0, T, B, 0, T + 2 / 3, B + 1, 0, T, B + 1, 0];
            M.set(b, _ * m * w),
            y.set(d, p * m * w);
            const E = [w, w, w, w, w, w];
            S.set(E, g * m * w)
        }
        const C = new Pl;
        C.setAttribute("position", new Zn(M,_)),
        C.setAttribute("uv", new Zn(y,p)),
        C.setAttribute("faceIndex", new Zn(S,g)),
        e.push(C),
        n > $o && n--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function e_(s, e, t) {
    const i = new no(s,e,t);
    return i.texture.mapping = Dh,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function qc(s, e, t, i, n) {
    s.viewport.set(e, t, i, n),
    s.scissor.set(e, t, i, n)
}
function fA(s, e, t) {
    const i = new Float32Array(Ds)
      , n = new ne(0,1,0);
    return new wr({
        name: "SphericalGaussianBlur",
        defines: {
            n: Ds,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${s}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: n
            }
        },
        vertexShader: rp(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: rs,
        depthTest: !1,
        depthWrite: !1
    })
}
function t_() {
    return new wr({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: rp(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: rs,
        depthTest: !1,
        depthWrite: !1
    })
}
function i_() {
    return new wr({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: rp(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: rs,
        depthTest: !1,
        depthWrite: !1
    })
}
function rp() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function pA(s) {
    let e = new WeakMap
      , t = null;
    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === Jd || l === Qd
              , h = l === da || l === fa;
            if (c || h)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let u = e.get(a);
                    return t === null && (t = new Qg(s)),
                    u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u),
                    e.set(a, u),
                    u.texture
                } else {
                    if (e.has(a))
                        return e.get(a).texture;
                    {
                        const u = a.image;
                        if (c && u && u.height > 0 || h && u && n(u)) {
                            t === null && (t = new Qg(s));
                            const d = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, d),
                            a.addEventListener("dispose", r),
                            d.texture
                        } else
                            return null
                    }
                }
        }
        return a
    }
    function n(a) {
        let l = 0;
        const c = 6;
        for (let h = 0; h < c; h++)
            a[h] !== void 0 && l++;
        return l === c
    }
    function r(a) {
        const l = a.target;
        l.removeEventListener("dispose", r);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function mA(s) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let n;
        switch (i) {
        case "WEBGL_depth_texture":
            n = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            n = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            n = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            n = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            n = s.getExtension(i)
        }
        return e[i] = n,
        n
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function(i) {
            i.isWebGL2 ? (t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(i) {
            const n = t(i);
            return n === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."),
            n
        }
    }
}
function gA(s, e, t, i) {
    const n = {}
      , r = new WeakMap;
    function o(u) {
        const d = u.target;
        d.index !== null && e.remove(d.index);
        for (const m in d.attributes)
            e.remove(d.attributes[m]);
        for (const m in d.morphAttributes) {
            const _ = d.morphAttributes[m];
            for (let p = 0, g = _.length; p < g; p++)
                e.remove(_[p])
        }
        d.removeEventListener("dispose", o),
        delete n[d.id];
        const f = r.get(d);
        f && (e.remove(f),
        r.delete(d)),
        i.releaseStatesOfGeometry(d),
        d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
        t.memory.geometries--
    }
    function a(u, d) {
        return n[d.id] === !0 || (d.addEventListener("dispose", o),
        n[d.id] = !0,
        t.memory.geometries++),
        d
    }
    function l(u) {
        const d = u.attributes;
        for (const m in d)
            e.update(d[m], s.ARRAY_BUFFER);
        const f = u.morphAttributes;
        for (const m in f) {
            const _ = f[m];
            for (let p = 0, g = _.length; p < g; p++)
                e.update(_[p], s.ARRAY_BUFFER)
        }
    }
    function c(u) {
        const d = []
          , f = u.index
          , m = u.attributes.position;
        let _ = 0;
        if (f !== null) {
            const M = f.array;
            _ = f.version;
            for (let y = 0, S = M.length; y < S; y += 3) {
                const C = M[y + 0]
                  , w = M[y + 1]
                  , T = M[y + 2];
                d.push(C, w, w, T, T, C)
            }
        } else if (m !== void 0) {
            const M = m.array;
            _ = m.version;
            for (let y = 0, S = M.length / 3 - 1; y < S; y += 3) {
                const C = y + 0
                  , w = y + 1
                  , T = y + 2;
                d.push(C, w, w, T, T, C)
            }
        } else
            return;
        const p = new (mx(d) ? px : fx)(d,1);
        p.version = _;
        const g = r.get(u);
        g && e.remove(g),
        r.set(u, p)
    }
    function h(u) {
        const d = r.get(u);
        if (d) {
            const f = u.index;
            f !== null && d.version < f.version && c(u)
        } else
            c(u);
        return r.get(u)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: h
    }
}
function _A(s, e, t, i) {
    const n = i.isWebGL2;
    let r;
    function o(f) {
        r = f
    }
    let a, l;
    function c(f) {
        a = f.type,
        l = f.bytesPerElement
    }
    function h(f, m) {
        s.drawElements(r, m, a, f * l),
        t.update(m, r, 1)
    }
    function u(f, m, _) {
        if (_ === 0)
            return;
        let p, g;
        if (n)
            p = s,
            g = "drawElementsInstanced";
        else if (p = e.get("ANGLE_instanced_arrays"),
        g = "drawElementsInstancedANGLE",
        p === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        p[g](r, m, a, f * l, _),
        t.update(m, r, _)
    }
    function d(f, m, _) {
        if (_ === 0)
            return;
        const p = e.get("WEBGL_multi_draw");
        if (p === null)
            for (let g = 0; g < _; g++)
                this.render(f[g] / l, m[g]);
        else {
            p.multiDrawElementsWEBGL(r, m, 0, a, f, 0, _);
            let g = 0;
            for (let M = 0; M < _; M++)
                g += m[M];
            t.update(g, r, 1)
        }
    }
    this.setMode = o,
    this.setIndex = c,
    this.render = h,
    this.renderInstances = u,
    this.renderMultiDraw = d
}
function xA(s) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(r, o, a) {
        switch (t.calls++,
        o) {
        case s.TRIANGLES:
            t.triangles += a * (r / 3);
            break;
        case s.LINES:
            t.lines += a * (r / 2);
            break;
        case s.LINE_STRIP:
            t.lines += a * (r - 1);
            break;
        case s.LINE_LOOP:
            t.lines += a * r;
            break;
        case s.POINTS:
            t.points += a * r;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function n() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: n,
        update: i
    }
}
class Jx extends zn {
    constructor(e=null, t=1, i=1, n=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        },
        this.magFilter = Ii,
        this.minFilter = Ii,
        this.wrapR = Fn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
function yA(s, e) {
    return s[0] - e[0]
}
function vA(s, e) {
    return Math.abs(e[1]) - Math.abs(s[1])
}
function MA(s, e, t) {
    const i = {}
      , n = new Float32Array(8)
      , r = new WeakMap
      , o = new pi
      , a = [];
    for (let c = 0; c < 8; c++)
        a[c] = [c, 0];
    function l(c, h, u) {
        const d = c.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const f = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color
              , m = f !== void 0 ? f.length : 0;
            let _ = r.get(h);
            if (_ === void 0 || _.count !== m) {
                let O = function() {
                    k.dispose(),
                    r.delete(h),
                    h.removeEventListener("dispose", O)
                };
                _ !== void 0 && _.texture.dispose();
                const M = h.morphAttributes.position !== void 0
                  , y = h.morphAttributes.normal !== void 0
                  , S = h.morphAttributes.color !== void 0
                  , C = h.morphAttributes.position || []
                  , w = h.morphAttributes.normal || []
                  , T = h.morphAttributes.color || [];
                let B = 0;
                M === !0 && (B = 1),
                y === !0 && (B = 2),
                S === !0 && (B = 3);
                let b = h.attributes.position.count * B
                  , E = 1;
                b > e.maxTextureSize && (E = Math.ceil(b / e.maxTextureSize),
                b = e.maxTextureSize);
                const G = new Float32Array(b * E * 4 * m)
                  , k = new Jx(G,b,E,m);
                k.type = Jr,
                k.needsUpdate = !0;
                const te = B * 4;
                for (let H = 0; H < m; H++) {
                    const V = C[H]
                      , Y = w[H]
                      , K = T[H]
                      , J = b * E * 4 * H;
                    for (let D = 0; D < V.count; D++) {
                        const se = D * te;
                        M === !0 && (o.fromBufferAttribute(V, D),
                        G[J + se + 0] = o.x,
                        G[J + se + 1] = o.y,
                        G[J + se + 2] = o.z,
                        G[J + se + 3] = 0),
                        y === !0 && (o.fromBufferAttribute(Y, D),
                        G[J + se + 4] = o.x,
                        G[J + se + 5] = o.y,
                        G[J + se + 6] = o.z,
                        G[J + se + 7] = 0),
                        S === !0 && (o.fromBufferAttribute(K, D),
                        G[J + se + 8] = o.x,
                        G[J + se + 9] = o.y,
                        G[J + se + 10] = o.z,
                        G[J + se + 11] = K.itemSize === 4 ? o.w : 1)
                    }
                }
                _ = {
                    count: m,
                    texture: k,
                    size: new Rt(b,E)
                },
                r.set(h, _),
                h.addEventListener("dispose", O)
            }
            let p = 0;
            for (let M = 0; M < d.length; M++)
                p += d[M];
            const g = h.morphTargetsRelative ? 1 : 1 - p;
            u.getUniforms().setValue(s, "morphTargetBaseInfluence", g),
            u.getUniforms().setValue(s, "morphTargetInfluences", d),
            u.getUniforms().setValue(s, "morphTargetsTexture", _.texture, t),
            u.getUniforms().setValue(s, "morphTargetsTextureSize", _.size)
        } else {
            const f = d === void 0 ? 0 : d.length;
            let m = i[h.id];
            if (m === void 0 || m.length !== f) {
                m = [];
                for (let y = 0; y < f; y++)
                    m[y] = [y, 0];
                i[h.id] = m
            }
            for (let y = 0; y < f; y++) {
                const S = m[y];
                S[0] = y,
                S[1] = d[y]
            }
            m.sort(vA);
            for (let y = 0; y < 8; y++)
                y < f && m[y][1] ? (a[y][0] = m[y][0],
                a[y][1] = m[y][1]) : (a[y][0] = Number.MAX_SAFE_INTEGER,
                a[y][1] = 0);
            a.sort(yA);
            const _ = h.morphAttributes.position
              , p = h.morphAttributes.normal;
            let g = 0;
            for (let y = 0; y < 8; y++) {
                const S = a[y]
                  , C = S[0]
                  , w = S[1];
                C !== Number.MAX_SAFE_INTEGER && w ? (_ && h.getAttribute("morphTarget" + y) !== _[C] && h.setAttribute("morphTarget" + y, _[C]),
                p && h.getAttribute("morphNormal" + y) !== p[C] && h.setAttribute("morphNormal" + y, p[C]),
                n[y] = w,
                g += w) : (_ && h.hasAttribute("morphTarget" + y) === !0 && h.deleteAttribute("morphTarget" + y),
                p && h.hasAttribute("morphNormal" + y) === !0 && h.deleteAttribute("morphNormal" + y),
                n[y] = 0)
            }
            const M = h.morphTargetsRelative ? 1 : 1 - g;
            u.getUniforms().setValue(s, "morphTargetBaseInfluence", M),
            u.getUniforms().setValue(s, "morphTargetInfluences", n)
        }
    }
    return {
        update: l
    }
}
function SA(s, e, t, i) {
    let n = new WeakMap;
    function r(l) {
        const c = i.render.frame
          , h = l.geometry
          , u = e.get(l, h);
        if (n.get(u) !== c && (e.update(u),
        n.set(u, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        n.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER),
        n.set(l, c))),
        l.isSkinnedMesh) {
            const d = l.skeleton;
            n.get(d) !== c && (d.update(),
            n.set(d, c))
        }
        return u
    }
    function o() {
        n = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: r,
        dispose: o
    }
}
class bA extends zn {
    constructor(e=null, t=1, i=1, n=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        },
        this.magFilter = Ii,
        this.minFilter = Ii,
        this.wrapR = Fn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class Qx extends zn {
    constructor(e, t, i, n, r, o, a, l, c, h) {
        if (h = h !== void 0 ? h : Ys,
        h !== Ys && h !== pa)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && h === Ys && (i = Kr),
        i === void 0 && h === pa && (i = qs),
        super(null, n, r, o, a, l, h, i, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Ii,
        this.minFilter = l !== void 0 ? l : Ii,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const ey = new zn
  , ty = new Qx(1,1);
ty.compareFunction = ax;
const iy = new Jx
  , ny = new bA
  , ry = new Zx
  , n_ = []
  , r_ = []
  , s_ = new Float32Array(16)
  , o_ = new Float32Array(9)
  , a_ = new Float32Array(4);
function Sa(s, e, t) {
    const i = s[0];
    if (i <= 0 || i > 0)
        return s;
    const n = e * t;
    let r = n_[n];
    if (r === void 0 && (r = new Float32Array(n),
    n_[n] = r),
    e !== 0) {
        i.toArray(r, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            s[o].toArray(r, a)
    }
    return r
}
function ei(s, e) {
    if (s.length !== e.length)
        return !1;
    for (let t = 0, i = s.length; t < i; t++)
        if (s[t] !== e[t])
            return !1;
    return !0
}
function ti(s, e) {
    for (let t = 0, i = e.length; t < i; t++)
        s[t] = e[t]
}
function Hh(s, e) {
    let t = r_[e];
    t === void 0 && (t = new Int32Array(e),
    r_[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = s.allocateTextureUnit();
    return t
}
function TA(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1f(this.addr, e),
    t[0] = e)
}
function EA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ei(t, e))
            return;
        s.uniform2fv(this.addr, e),
        ti(t, e)
    }
}
function wA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (ei(t, e))
            return;
        s.uniform3fv(this.addr, e),
        ti(t, e)
    }
}
function AA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ei(t, e))
            return;
        s.uniform4fv(this.addr, e),
        ti(t, e)
    }
}
function RA(s, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (ei(t, e))
            return;
        s.uniformMatrix2fv(this.addr, !1, e),
        ti(t, e)
    } else {
        if (ei(t, i))
            return;
        a_.set(i),
        s.uniformMatrix2fv(this.addr, !1, a_),
        ti(t, i)
    }
}
function CA(s, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (ei(t, e))
            return;
        s.uniformMatrix3fv(this.addr, !1, e),
        ti(t, e)
    } else {
        if (ei(t, i))
            return;
        o_.set(i),
        s.uniformMatrix3fv(this.addr, !1, o_),
        ti(t, i)
    }
}
function PA(s, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (ei(t, e))
            return;
        s.uniformMatrix4fv(this.addr, !1, e),
        ti(t, e)
    } else {
        if (ei(t, i))
            return;
        s_.set(i),
        s.uniformMatrix4fv(this.addr, !1, s_),
        ti(t, i)
    }
}
function LA(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1i(this.addr, e),
    t[0] = e)
}
function IA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ei(t, e))
            return;
        s.uniform2iv(this.addr, e),
        ti(t, e)
    }
}
function DA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (ei(t, e))
            return;
        s.uniform3iv(this.addr, e),
        ti(t, e)
    }
}
function UA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ei(t, e))
            return;
        s.uniform4iv(this.addr, e),
        ti(t, e)
    }
}
function NA(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1ui(this.addr, e),
    t[0] = e)
}
function FA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (ei(t, e))
            return;
        s.uniform2uiv(this.addr, e),
        ti(t, e)
    }
}
function OA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (ei(t, e))
            return;
        s.uniform3uiv(this.addr, e),
        ti(t, e)
    }
}
function BA(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (ei(t, e))
            return;
        s.uniform4uiv(this.addr, e),
        ti(t, e)
    }
}
function zA(s, e, t) {
    const i = this.cache
      , n = t.allocateTextureUnit();
    i[0] !== n && (s.uniform1i(this.addr, n),
    i[0] = n);
    const r = this.type === s.SAMPLER_2D_SHADOW ? ty : ey;
    t.setTexture2D(e || r, n)
}
function kA(s, e, t) {
    const i = this.cache
      , n = t.allocateTextureUnit();
    i[0] !== n && (s.uniform1i(this.addr, n),
    i[0] = n),
    t.setTexture3D(e || ny, n)
}
function HA(s, e, t) {
    const i = this.cache
      , n = t.allocateTextureUnit();
    i[0] !== n && (s.uniform1i(this.addr, n),
    i[0] = n),
    t.setTextureCube(e || ry, n)
}
function GA(s, e, t) {
    const i = this.cache
      , n = t.allocateTextureUnit();
    i[0] !== n && (s.uniform1i(this.addr, n),
    i[0] = n),
    t.setTexture2DArray(e || iy, n)
}
function VA(s) {
    switch (s) {
    case 5126:
        return TA;
    case 35664:
        return EA;
    case 35665:
        return wA;
    case 35666:
        return AA;
    case 35674:
        return RA;
    case 35675:
        return CA;
    case 35676:
        return PA;
    case 5124:
    case 35670:
        return LA;
    case 35667:
    case 35671:
        return IA;
    case 35668:
    case 35672:
        return DA;
    case 35669:
    case 35673:
        return UA;
    case 5125:
        return NA;
    case 36294:
        return FA;
    case 36295:
        return OA;
    case 36296:
        return BA;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return zA;
    case 35679:
    case 36299:
    case 36307:
        return kA;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return HA;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return GA
    }
}
function WA(s, e) {
    s.uniform1fv(this.addr, e)
}
function XA(s, e) {
    const t = Sa(e, this.size, 2);
    s.uniform2fv(this.addr, t)
}
function qA(s, e) {
    const t = Sa(e, this.size, 3);
    s.uniform3fv(this.addr, t)
}
function YA(s, e) {
    const t = Sa(e, this.size, 4);
    s.uniform4fv(this.addr, t)
}
function $A(s, e) {
    const t = Sa(e, this.size, 4);
    s.uniformMatrix2fv(this.addr, !1, t)
}
function jA(s, e) {
    const t = Sa(e, this.size, 9);
    s.uniformMatrix3fv(this.addr, !1, t)
}
function ZA(s, e) {
    const t = Sa(e, this.size, 16);
    s.uniformMatrix4fv(this.addr, !1, t)
}
function KA(s, e) {
    s.uniform1iv(this.addr, e)
}
function JA(s, e) {
    s.uniform2iv(this.addr, e)
}
function QA(s, e) {
    s.uniform3iv(this.addr, e)
}
function eR(s, e) {
    s.uniform4iv(this.addr, e)
}
function tR(s, e) {
    s.uniform1uiv(this.addr, e)
}
function iR(s, e) {
    s.uniform2uiv(this.addr, e)
}
function nR(s, e) {
    s.uniform3uiv(this.addr, e)
}
function rR(s, e) {
    s.uniform4uiv(this.addr, e)
}
function sR(s, e, t) {
    const i = this.cache
      , n = e.length
      , r = Hh(t, n);
    ei(i, r) || (s.uniform1iv(this.addr, r),
    ti(i, r));
    for (let o = 0; o !== n; ++o)
        t.setTexture2D(e[o] || ey, r[o])
}
function oR(s, e, t) {
    const i = this.cache
      , n = e.length
      , r = Hh(t, n);
    ei(i, r) || (s.uniform1iv(this.addr, r),
    ti(i, r));
    for (let o = 0; o !== n; ++o)
        t.setTexture3D(e[o] || ny, r[o])
}
function aR(s, e, t) {
    const i = this.cache
      , n = e.length
      , r = Hh(t, n);
    ei(i, r) || (s.uniform1iv(this.addr, r),
    ti(i, r));
    for (let o = 0; o !== n; ++o)
        t.setTextureCube(e[o] || ry, r[o])
}
function lR(s, e, t) {
    const i = this.cache
      , n = e.length
      , r = Hh(t, n);
    ei(i, r) || (s.uniform1iv(this.addr, r),
    ti(i, r));
    for (let o = 0; o !== n; ++o)
        t.setTexture2DArray(e[o] || iy, r[o])
}
function cR(s) {
    switch (s) {
    case 5126:
        return WA;
    case 35664:
        return XA;
    case 35665:
        return qA;
    case 35666:
        return YA;
    case 35674:
        return $A;
    case 35675:
        return jA;
    case 35676:
        return ZA;
    case 5124:
    case 35670:
        return KA;
    case 35667:
    case 35671:
        return JA;
    case 35668:
    case 35672:
        return QA;
    case 35669:
    case 35673:
        return eR;
    case 5125:
        return tR;
    case 36294:
        return iR;
    case 36295:
        return nR;
    case 36296:
        return rR;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return sR;
    case 35679:
    case 36299:
    case 36307:
        return oR;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return aR;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return lR
    }
}
class hR {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.setValue = VA(t.type)
    }
}
class uR {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = cR(t.type)
    }
}
class dR {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const n = this.seq;
        for (let r = 0, o = n.length; r !== o; ++r) {
            const a = n[r];
            a.setValue(e, t[a.id], i)
        }
    }
}
const _d = /(\w+)(\])?(\[|\.)?/g;
function l_(s, e) {
    s.seq.push(e),
    s.map[e.id] = e
}
function fR(s, e, t) {
    const i = s.name
      , n = i.length;
    for (_d.lastIndex = 0; ; ) {
        const r = _d.exec(i)
          , o = _d.lastIndex;
        let a = r[1];
        const l = r[2] === "]"
          , c = r[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === n) {
            l_(t, c === void 0 ? new hR(a,s,e) : new uR(a,s,e));
            break
        } else {
            let u = t.map[a];
            u === void 0 && (u = new dR(a),
            l_(t, u)),
            t = u
        }
    }
}
class lh {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let n = 0; n < i; ++n) {
            const r = e.getActiveUniform(t, n)
              , o = e.getUniformLocation(t, r.name);
            fR(r, o, this)
        }
    }
    setValue(e, t, i, n) {
        const r = this.map[t];
        r !== void 0 && r.setValue(e, i, n)
    }
    setOptional(e, t, i) {
        const n = t[i];
        n !== void 0 && this.setValue(e, i, n)
    }
    static upload(e, t, i, n) {
        for (let r = 0, o = t.length; r !== o; ++r) {
            const a = t[r]
              , l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, n)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let n = 0, r = e.length; n !== r; ++n) {
            const o = e[n];
            o.id in t && i.push(o)
        }
        return i
    }
}
function c_(s, e, t) {
    const i = s.createShader(e);
    return s.shaderSource(i, t),
    s.compileShader(i),
    i
}
const pR = 37297;
let mR = 0;
function gR(s, e) {
    const t = s.split(`
`)
      , i = []
      , n = Math.max(e - 6, 0)
      , r = Math.min(e + 6, t.length);
    for (let o = n; o < r; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}
function _R(s) {
    const e = wt.getPrimaries(wt.workingColorSpace)
      , t = wt.getPrimaries(s);
    let i;
    switch (e === t ? i = "" : e === Eh && t === Th ? i = "LinearDisplayP3ToLinearSRGB" : e === Th && t === Eh && (i = "LinearSRGBToLinearDisplayP3"),
    s) {
    case Er:
    case Uh:
        return [i, "LinearTransferOETF"];
    case ui:
    case Vf:
        return [i, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", s),
        [i, "LinearTransferOETF"]
    }
}
function h_(s, e, t) {
    const i = s.getShaderParameter(e, s.COMPILE_STATUS)
      , n = s.getShaderInfoLog(e).trim();
    if (i && n === "")
        return "";
    const r = /ERROR: 0:(\d+)/.exec(n);
    if (r) {
        const o = parseInt(r[1]);
        return t.toUpperCase() + `

` + n + `

` + gR(s.getShaderSource(e), o)
    } else
        return n
}
function xR(s, e) {
    const t = _R(e);
    return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function yR(s, e) {
    let t;
    switch (e) {
    case AM:
        t = "Linear";
        break;
    case RM:
        t = "Reinhard";
        break;
    case CM:
        t = "OptimizedCineon";
        break;
    case PM:
        t = "ACESFilmic";
        break;
    case IM:
        t = "AgX";
        break;
    case LM:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function vR(s) {
    return [s.extensionDerivatives || s.envMapCubeUVHeight || s.bumpMap || s.normalMapTangentSpace || s.clearcoatNormalMap || s.flatShading || s.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (s.extensionFragDepth || s.logarithmicDepthBuffer) && s.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", s.extensionDrawBuffers && s.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (s.extensionShaderTextureLOD || s.envMap || s.transmission) && s.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(jo).join(`
`)
}
function MR(s) {
    return [s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""].filter(jo).join(`
`)
}
function SR(s) {
    const e = [];
    for (const t in s) {
        const i = s[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function bR(s, e) {
    const t = {}
      , i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
    for (let n = 0; n < i; n++) {
        const r = s.getActiveAttrib(e, n)
          , o = r.name;
        let a = 1;
        r.type === s.FLOAT_MAT2 && (a = 2),
        r.type === s.FLOAT_MAT3 && (a = 3),
        r.type === s.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: r.type,
            location: s.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function jo(s) {
    return s !== ""
}
function u_(s, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function d_(s, e) {
    return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const TR = /^[ \t]*#include +<([\w\d./]+)>/gm;
function _f(s) {
    return s.replace(TR, wR)
}
const ER = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
function wR(s, e) {
    let t = ht[e];
    if (t === void 0) {
        const i = ER.get(e);
        if (i !== void 0)
            t = ht[i],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return _f(t)
}
const AR = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function f_(s) {
    return s.replace(AR, RR)
}
function RR(s, e, t, i) {
    let n = "";
    for (let r = parseInt(e); r < parseInt(t); r++)
        n += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
    return n
}
function p_(s) {
    let e = "precision " + s.precision + ` float;
precision ` + s.precision + " int;";
    return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function CR(s) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return s.shadowMapType === Z0 ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === tM ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === dr && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function PR(s) {
    let e = "ENVMAP_TYPE_CUBE";
    if (s.envMap)
        switch (s.envMapMode) {
        case da:
        case fa:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Dh:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function LR(s) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (s.envMap)
        switch (s.envMapMode) {
        case fa:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function IR(s) {
    let e = "ENVMAP_BLENDING_NONE";
    if (s.envMap)
        switch (s.combine) {
        case K0:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case EM:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case wM:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function DR(s) {
    const e = s.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function UR(s, e, t, i) {
    const n = s.getContext()
      , r = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = CR(t)
      , c = PR(t)
      , h = LR(t)
      , u = IR(t)
      , d = DR(t)
      , f = t.isWebGL2 ? "" : vR(t)
      , m = MR(t)
      , _ = SR(r)
      , p = n.createProgram();
    let g, M, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(jo).join(`
`),
    g.length > 0 && (g += `
`),
    M = [f, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _].filter(jo).join(`
`),
    M.length > 0 && (M += `
`)) : (g = [p_(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(jo).join(`
`),
    M = [f, p_(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, _, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== ss ? "#define TONE_MAPPING" : "", t.toneMapping !== ss ? ht.tonemapping_pars_fragment : "", t.toneMapping !== ss ? yR("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", ht.colorspace_pars_fragment, xR("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(jo).join(`
`)),
    o = _f(o),
    o = u_(o, t),
    o = d_(o, t),
    a = _f(a),
    a = u_(a, t),
    a = d_(a, t),
    o = f_(o),
    a = f_(a),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (y = `#version 300 es
`,
    g = [m, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + g,
    M = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === Pm ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Pm ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + M);
    const S = y + g + o
      , C = y + M + a
      , w = c_(n, n.VERTEX_SHADER, S)
      , T = c_(n, n.FRAGMENT_SHADER, C);
    n.attachShader(p, w),
    n.attachShader(p, T),
    t.index0AttributeName !== void 0 ? n.bindAttribLocation(p, 0, t.index0AttributeName) : t.morphTargets === !0 && n.bindAttribLocation(p, 0, "position"),
    n.linkProgram(p);
    function B(k) {
        if (s.debug.checkShaderErrors) {
            const te = n.getProgramInfoLog(p).trim()
              , O = n.getShaderInfoLog(w).trim()
              , H = n.getShaderInfoLog(T).trim();
            let V = !0
              , Y = !0;
            if (n.getProgramParameter(p, n.LINK_STATUS) === !1)
                if (V = !1,
                typeof s.debug.onShaderError == "function")
                    s.debug.onShaderError(n, p, w, T);
                else {
                    const K = h_(n, w, "vertex")
                      , J = h_(n, T, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(p, n.VALIDATE_STATUS) + `

Program Info Log: ` + te + `
` + K + `
` + J)
                }
            else
                te !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", te) : (O === "" || H === "") && (Y = !1);
            Y && (k.diagnostics = {
                runnable: V,
                programLog: te,
                vertexShader: {
                    log: O,
                    prefix: g
                },
                fragmentShader: {
                    log: H,
                    prefix: M
                }
            })
        }
        n.deleteShader(w),
        n.deleteShader(T),
        b = new lh(n,p),
        E = bR(n, p)
    }
    let b;
    this.getUniforms = function() {
        return b === void 0 && B(this),
        b
    }
    ;
    let E;
    this.getAttributes = function() {
        return E === void 0 && B(this),
        E
    }
    ;
    let G = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return G === !1 && (G = n.getProgramParameter(p, pR)),
        G
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        n.deleteProgram(p),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = mR++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = p,
    this.vertexShader = w,
    this.fragmentShader = T,
    this
}
let NR = 0;
class FR {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , n = this._getShaderStage(t)
          , r = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(n) === !1 && (o.add(n),
        n.usedTimes++),
        o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new OR(e),
        t.set(e, i)),
        i
    }
}
class OR {
    constructor(e) {
        this.id = NR++,
        this.code = e,
        this.usedTimes = 0
    }
}
function BR(s, e, t, i, n, r, o) {
    const a = new hx
      , l = new FR
      , c = []
      , h = n.isWebGL2
      , u = n.logarithmicDepthBuffer
      , d = n.vertexTextures;
    let f = n.precision;
    const m = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function _(b) {
        return b === 0 ? "uv" : `uv${b}`
    }
    function p(b, E, G, k, te) {
        const O = k.fog
          , H = te.geometry
          , V = b.isMeshStandardMaterial ? k.environment : null
          , Y = (b.isMeshStandardMaterial ? t : e).get(b.envMap || V)
          , K = Y && Y.mapping === Dh ? Y.image.height : null
          , J = m[b.type];
        b.precision !== null && (f = n.getMaxPrecision(b.precision),
        f !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", f, "instead."));
        const D = H.morphAttributes.position || H.morphAttributes.normal || H.morphAttributes.color
          , se = D !== void 0 ? D.length : 0;
        let de = 0;
        H.morphAttributes.position !== void 0 && (de = 1),
        H.morphAttributes.normal !== void 0 && (de = 2),
        H.morphAttributes.color !== void 0 && (de = 3);
        let Q, re, ge, fe;
        if (J) {
            const nt = Gn[J];
            Q = nt.vertexShader,
            re = nt.fragmentShader
        } else
            Q = b.vertexShader,
            re = b.fragmentShader,
            l.update(b),
            ge = l.getVertexShaderID(b),
            fe = l.getFragmentShaderID(b);
        const ve = s.getRenderTarget()
          , Ue = te.isInstancedMesh === !0
          , ke = te.isBatchedMesh === !0
          , Ve = !!b.map
          , Ke = !!b.matcap
          , $ = !!Y
          , Qe = !!b.aoMap
          , Re = !!b.lightMap
          , ze = !!b.bumpMap
          , Pe = !!b.normalMap
          , Z = !!b.displacementMap
          , Ye = !!b.emissiveMap
          , L = !!b.metalnessMap
          , R = !!b.roughnessMap
          , X = b.anisotropy > 0
          , ue = b.clearcoat > 0
          , ce = b.iridescence > 0
          , pe = b.sheen > 0
          , be = b.transmission > 0
          , me = X && !!b.anisotropyMap
          , Ee = ue && !!b.clearcoatMap
          , Oe = ue && !!b.clearcoatNormalMap
          , Je = ue && !!b.clearcoatRoughnessMap
          , le = ce && !!b.iridescenceMap
          , lt = ce && !!b.iridescenceThicknessMap
          , Ze = pe && !!b.sheenColorMap
          , We = pe && !!b.sheenRoughnessMap
          , Ce = !!b.specularMap
          , Le = !!b.specularColorMap
          , $e = !!b.specularIntensityMap
          , et = be && !!b.transmissionMap
          , st = be && !!b.thicknessMap
          , we = !!b.gradientMap
          , j = !!b.alphaMap
          , z = b.alphaTest > 0
          , _e = !!b.alphaHash
          , xe = !!b.extensions
          , Xe = !!H.attributes.uv1
          , He = !!H.attributes.uv2
          , ut = !!H.attributes.uv3;
        let Ie = ss;
        return b.toneMapped && (ve === null || ve.isXRRenderTarget === !0) && (Ie = s.toneMapping),
        {
            isWebGL2: h,
            shaderID: J,
            shaderType: b.type,
            shaderName: b.name,
            vertexShader: Q,
            fragmentShader: re,
            defines: b.defines,
            customVertexShaderID: ge,
            customFragmentShaderID: fe,
            isRawShaderMaterial: b.isRawShaderMaterial === !0,
            glslVersion: b.glslVersion,
            precision: f,
            batching: ke,
            instancing: Ue,
            instancingColor: Ue && te.instanceColor !== null,
            supportsVertexTextures: d,
            outputColorSpace: ve === null ? s.outputColorSpace : ve.isXRRenderTarget === !0 ? ve.texture.colorSpace : Er,
            map: Ve,
            matcap: Ke,
            envMap: $,
            envMapMode: $ && Y.mapping,
            envMapCubeUVHeight: K,
            aoMap: Qe,
            lightMap: Re,
            bumpMap: ze,
            normalMap: Pe,
            displacementMap: d && Z,
            emissiveMap: Ye,
            normalMapObjectSpace: Pe && b.normalMapType === XM,
            normalMapTangentSpace: Pe && b.normalMapType === WM,
            metalnessMap: L,
            roughnessMap: R,
            anisotropy: X,
            anisotropyMap: me,
            clearcoat: ue,
            clearcoatMap: Ee,
            clearcoatNormalMap: Oe,
            clearcoatRoughnessMap: Je,
            iridescence: ce,
            iridescenceMap: le,
            iridescenceThicknessMap: lt,
            sheen: pe,
            sheenColorMap: Ze,
            sheenRoughnessMap: We,
            specularMap: Ce,
            specularColorMap: Le,
            specularIntensityMap: $e,
            transmission: be,
            transmissionMap: et,
            thicknessMap: st,
            gradientMap: we,
            opaque: b.transparent === !1 && b.blending === ia,
            alphaMap: j,
            alphaTest: z,
            alphaHash: _e,
            combine: b.combine,
            mapUv: Ve && _(b.map.channel),
            aoMapUv: Qe && _(b.aoMap.channel),
            lightMapUv: Re && _(b.lightMap.channel),
            bumpMapUv: ze && _(b.bumpMap.channel),
            normalMapUv: Pe && _(b.normalMap.channel),
            displacementMapUv: Z && _(b.displacementMap.channel),
            emissiveMapUv: Ye && _(b.emissiveMap.channel),
            metalnessMapUv: L && _(b.metalnessMap.channel),
            roughnessMapUv: R && _(b.roughnessMap.channel),
            anisotropyMapUv: me && _(b.anisotropyMap.channel),
            clearcoatMapUv: Ee && _(b.clearcoatMap.channel),
            clearcoatNormalMapUv: Oe && _(b.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Je && _(b.clearcoatRoughnessMap.channel),
            iridescenceMapUv: le && _(b.iridescenceMap.channel),
            iridescenceThicknessMapUv: lt && _(b.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ze && _(b.sheenColorMap.channel),
            sheenRoughnessMapUv: We && _(b.sheenRoughnessMap.channel),
            specularMapUv: Ce && _(b.specularMap.channel),
            specularColorMapUv: Le && _(b.specularColorMap.channel),
            specularIntensityMapUv: $e && _(b.specularIntensityMap.channel),
            transmissionMapUv: et && _(b.transmissionMap.channel),
            thicknessMapUv: st && _(b.thicknessMap.channel),
            alphaMapUv: j && _(b.alphaMap.channel),
            vertexTangents: !!H.attributes.tangent && (Pe || X),
            vertexColors: b.vertexColors,
            vertexAlphas: b.vertexColors === !0 && !!H.attributes.color && H.attributes.color.itemSize === 4,
            vertexUv1s: Xe,
            vertexUv2s: He,
            vertexUv3s: ut,
            pointsUvs: te.isPoints === !0 && !!H.attributes.uv && (Ve || j),
            fog: !!O,
            useFog: b.fog === !0,
            fogExp2: O && O.isFogExp2,
            flatShading: b.flatShading === !0,
            sizeAttenuation: b.sizeAttenuation === !0,
            logarithmicDepthBuffer: u,
            skinning: te.isSkinnedMesh === !0,
            morphTargets: H.morphAttributes.position !== void 0,
            morphNormals: H.morphAttributes.normal !== void 0,
            morphColors: H.morphAttributes.color !== void 0,
            morphTargetsCount: se,
            morphTextureStride: de,
            numDirLights: E.directional.length,
            numPointLights: E.point.length,
            numSpotLights: E.spot.length,
            numSpotLightMaps: E.spotLightMap.length,
            numRectAreaLights: E.rectArea.length,
            numHemiLights: E.hemi.length,
            numDirLightShadows: E.directionalShadowMap.length,
            numPointLightShadows: E.pointShadowMap.length,
            numSpotLightShadows: E.spotShadowMap.length,
            numSpotLightShadowsWithMaps: E.numSpotLightShadowsWithMaps,
            numLightProbes: E.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: b.dithering,
            shadowMapEnabled: s.shadowMap.enabled && G.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: Ie,
            useLegacyLights: s._useLegacyLights,
            decodeVideoTexture: Ve && b.map.isVideoTexture === !0 && wt.getTransfer(b.map.colorSpace) === It,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === gr,
            flipSided: b.side === Yi,
            useDepthPacking: b.depthPacking >= 0,
            depthPacking: b.depthPacking || 0,
            index0AttributeName: b.index0AttributeName,
            extensionDerivatives: xe && b.extensions.derivatives === !0,
            extensionFragDepth: xe && b.extensions.fragDepth === !0,
            extensionDrawBuffers: xe && b.extensions.drawBuffers === !0,
            extensionShaderTextureLOD: xe && b.extensions.shaderTextureLOD === !0,
            extensionClipCullDistance: xe && b.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
            rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: b.customProgramCacheKey()
        }
    }
    function g(b) {
        const E = [];
        if (b.shaderID ? E.push(b.shaderID) : (E.push(b.customVertexShaderID),
        E.push(b.customFragmentShaderID)),
        b.defines !== void 0)
            for (const G in b.defines)
                E.push(G),
                E.push(b.defines[G]);
        return b.isRawShaderMaterial === !1 && (M(E, b),
        y(E, b),
        E.push(s.outputColorSpace)),
        E.push(b.customProgramCacheKey),
        E.join()
    }
    function M(b, E) {
        b.push(E.precision),
        b.push(E.outputColorSpace),
        b.push(E.envMapMode),
        b.push(E.envMapCubeUVHeight),
        b.push(E.mapUv),
        b.push(E.alphaMapUv),
        b.push(E.lightMapUv),
        b.push(E.aoMapUv),
        b.push(E.bumpMapUv),
        b.push(E.normalMapUv),
        b.push(E.displacementMapUv),
        b.push(E.emissiveMapUv),
        b.push(E.metalnessMapUv),
        b.push(E.roughnessMapUv),
        b.push(E.anisotropyMapUv),
        b.push(E.clearcoatMapUv),
        b.push(E.clearcoatNormalMapUv),
        b.push(E.clearcoatRoughnessMapUv),
        b.push(E.iridescenceMapUv),
        b.push(E.iridescenceThicknessMapUv),
        b.push(E.sheenColorMapUv),
        b.push(E.sheenRoughnessMapUv),
        b.push(E.specularMapUv),
        b.push(E.specularColorMapUv),
        b.push(E.specularIntensityMapUv),
        b.push(E.transmissionMapUv),
        b.push(E.thicknessMapUv),
        b.push(E.combine),
        b.push(E.fogExp2),
        b.push(E.sizeAttenuation),
        b.push(E.morphTargetsCount),
        b.push(E.morphAttributeCount),
        b.push(E.numDirLights),
        b.push(E.numPointLights),
        b.push(E.numSpotLights),
        b.push(E.numSpotLightMaps),
        b.push(E.numHemiLights),
        b.push(E.numRectAreaLights),
        b.push(E.numDirLightShadows),
        b.push(E.numPointLightShadows),
        b.push(E.numSpotLightShadows),
        b.push(E.numSpotLightShadowsWithMaps),
        b.push(E.numLightProbes),
        b.push(E.shadowMapType),
        b.push(E.toneMapping),
        b.push(E.numClippingPlanes),
        b.push(E.numClipIntersection),
        b.push(E.depthPacking)
    }
    function y(b, E) {
        a.disableAll(),
        E.isWebGL2 && a.enable(0),
        E.supportsVertexTextures && a.enable(1),
        E.instancing && a.enable(2),
        E.instancingColor && a.enable(3),
        E.matcap && a.enable(4),
        E.envMap && a.enable(5),
        E.normalMapObjectSpace && a.enable(6),
        E.normalMapTangentSpace && a.enable(7),
        E.clearcoat && a.enable(8),
        E.iridescence && a.enable(9),
        E.alphaTest && a.enable(10),
        E.vertexColors && a.enable(11),
        E.vertexAlphas && a.enable(12),
        E.vertexUv1s && a.enable(13),
        E.vertexUv2s && a.enable(14),
        E.vertexUv3s && a.enable(15),
        E.vertexTangents && a.enable(16),
        E.anisotropy && a.enable(17),
        E.alphaHash && a.enable(18),
        E.batching && a.enable(19),
        b.push(a.mask),
        a.disableAll(),
        E.fog && a.enable(0),
        E.useFog && a.enable(1),
        E.flatShading && a.enable(2),
        E.logarithmicDepthBuffer && a.enable(3),
        E.skinning && a.enable(4),
        E.morphTargets && a.enable(5),
        E.morphNormals && a.enable(6),
        E.morphColors && a.enable(7),
        E.premultipliedAlpha && a.enable(8),
        E.shadowMapEnabled && a.enable(9),
        E.useLegacyLights && a.enable(10),
        E.doubleSided && a.enable(11),
        E.flipSided && a.enable(12),
        E.useDepthPacking && a.enable(13),
        E.dithering && a.enable(14),
        E.transmission && a.enable(15),
        E.sheen && a.enable(16),
        E.opaque && a.enable(17),
        E.pointsUvs && a.enable(18),
        E.decodeVideoTexture && a.enable(19),
        b.push(a.mask)
    }
    function S(b) {
        const E = m[b.type];
        let G;
        if (E) {
            const k = Gn[E];
            G = fS.clone(k.uniforms)
        } else
            G = b.uniforms;
        return G
    }
    function C(b, E) {
        let G;
        for (let k = 0, te = c.length; k < te; k++) {
            const O = c[k];
            if (O.cacheKey === E) {
                G = O,
                ++G.usedTimes;
                break
            }
        }
        return G === void 0 && (G = new UR(s,E,b,r),
        c.push(G)),
        G
    }
    function w(b) {
        if (--b.usedTimes === 0) {
            const E = c.indexOf(b);
            c[E] = c[c.length - 1],
            c.pop(),
            b.destroy()
        }
    }
    function T(b) {
        l.remove(b)
    }
    function B() {
        l.dispose()
    }
    return {
        getParameters: p,
        getProgramCacheKey: g,
        getUniforms: S,
        acquireProgram: C,
        releaseProgram: w,
        releaseShaderCache: T,
        programs: c,
        dispose: B
    }
}
function zR() {
    let s = new WeakMap;
    function e(r) {
        let o = s.get(r);
        return o === void 0 && (o = {},
        s.set(r, o)),
        o
    }
    function t(r) {
        s.delete(r)
    }
    function i(r, o, a) {
        s.get(r)[o] = a
    }
    function n() {
        s = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: n
    }
}
function kR(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id
}
function m_(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id
}
function g_() {
    const s = [];
    let e = 0;
    const t = []
      , i = []
      , n = [];
    function r() {
        e = 0,
        t.length = 0,
        i.length = 0,
        n.length = 0
    }
    function o(u, d, f, m, _, p) {
        let g = s[e];
        return g === void 0 ? (g = {
            id: u.id,
            object: u,
            geometry: d,
            material: f,
            groupOrder: m,
            renderOrder: u.renderOrder,
            z: _,
            group: p
        },
        s[e] = g) : (g.id = u.id,
        g.object = u,
        g.geometry = d,
        g.material = f,
        g.groupOrder = m,
        g.renderOrder = u.renderOrder,
        g.z = _,
        g.group = p),
        e++,
        g
    }
    function a(u, d, f, m, _, p) {
        const g = o(u, d, f, m, _, p);
        f.transmission > 0 ? i.push(g) : f.transparent === !0 ? n.push(g) : t.push(g)
    }
    function l(u, d, f, m, _, p) {
        const g = o(u, d, f, m, _, p);
        f.transmission > 0 ? i.unshift(g) : f.transparent === !0 ? n.unshift(g) : t.unshift(g)
    }
    function c(u, d) {
        t.length > 1 && t.sort(u || kR),
        i.length > 1 && i.sort(d || m_),
        n.length > 1 && n.sort(d || m_)
    }
    function h() {
        for (let u = e, d = s.length; u < d; u++) {
            const f = s[u];
            if (f.id === null)
                break;
            f.id = null,
            f.object = null,
            f.geometry = null,
            f.material = null,
            f.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: n,
        init: r,
        push: a,
        unshift: l,
        finish: h,
        sort: c
    }
}
function HR() {
    let s = new WeakMap;
    function e(i, n) {
        const r = s.get(i);
        let o;
        return r === void 0 ? (o = new g_,
        s.set(i, [o])) : n >= r.length ? (o = new g_,
        r.push(o)) : o = r[n],
        o
    }
    function t() {
        s = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function GR() {
    const s = {};
    return {
        get: function(e) {
            if (s[e.id] !== void 0)
                return s[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new ne,
                    color: new At
                };
                break;
            case "SpotLight":
                t = {
                    position: new ne,
                    direction: new ne,
                    color: new At,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new ne,
                    color: new At,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new ne,
                    skyColor: new At,
                    groundColor: new At
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new At,
                    position: new ne,
                    halfWidth: new ne,
                    halfHeight: new ne
                };
                break
            }
            return s[e.id] = t,
            t
        }
    }
}
function VR() {
    const s = {};
    return {
        get: function(e) {
            if (s[e.id] !== void 0)
                return s[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Rt
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Rt
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Rt,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return s[e.id] = t,
            t
        }
    }
}
let WR = 0;
function XR(s, e) {
    return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0)
}
function qR(s, e) {
    const t = new GR
      , i = VR()
      , n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let h = 0; h < 9; h++)
        n.probe.push(new ne);
    const r = new ne
      , o = new $i
      , a = new $i;
    function l(h, u) {
        let d = 0
          , f = 0
          , m = 0;
        for (let k = 0; k < 9; k++)
            n.probe[k].set(0, 0, 0);
        let _ = 0
          , p = 0
          , g = 0
          , M = 0
          , y = 0
          , S = 0
          , C = 0
          , w = 0
          , T = 0
          , B = 0
          , b = 0;
        h.sort(XR);
        const E = u === !0 ? Math.PI : 1;
        for (let k = 0, te = h.length; k < te; k++) {
            const O = h[k]
              , H = O.color
              , V = O.intensity
              , Y = O.distance
              , K = O.shadow && O.shadow.map ? O.shadow.map.texture : null;
            if (O.isAmbientLight)
                d += H.r * V * E,
                f += H.g * V * E,
                m += H.b * V * E;
            else if (O.isLightProbe) {
                for (let J = 0; J < 9; J++)
                    n.probe[J].addScaledVector(O.sh.coefficients[J], V);
                b++
            } else if (O.isDirectionalLight) {
                const J = t.get(O);
                if (J.color.copy(O.color).multiplyScalar(O.intensity * E),
                O.castShadow) {
                    const D = O.shadow
                      , se = i.get(O);
                    se.shadowBias = D.bias,
                    se.shadowNormalBias = D.normalBias,
                    se.shadowRadius = D.radius,
                    se.shadowMapSize = D.mapSize,
                    n.directionalShadow[_] = se,
                    n.directionalShadowMap[_] = K,
                    n.directionalShadowMatrix[_] = O.shadow.matrix,
                    S++
                }
                n.directional[_] = J,
                _++
            } else if (O.isSpotLight) {
                const J = t.get(O);
                J.position.setFromMatrixPosition(O.matrixWorld),
                J.color.copy(H).multiplyScalar(V * E),
                J.distance = Y,
                J.coneCos = Math.cos(O.angle),
                J.penumbraCos = Math.cos(O.angle * (1 - O.penumbra)),
                J.decay = O.decay,
                n.spot[g] = J;
                const D = O.shadow;
                if (O.map && (n.spotLightMap[T] = O.map,
                T++,
                D.updateMatrices(O),
                O.castShadow && B++),
                n.spotLightMatrix[g] = D.matrix,
                O.castShadow) {
                    const se = i.get(O);
                    se.shadowBias = D.bias,
                    se.shadowNormalBias = D.normalBias,
                    se.shadowRadius = D.radius,
                    se.shadowMapSize = D.mapSize,
                    n.spotShadow[g] = se,
                    n.spotShadowMap[g] = K,
                    w++
                }
                g++
            } else if (O.isRectAreaLight) {
                const J = t.get(O);
                J.color.copy(H).multiplyScalar(V),
                J.halfWidth.set(O.width * .5, 0, 0),
                J.halfHeight.set(0, O.height * .5, 0),
                n.rectArea[M] = J,
                M++
            } else if (O.isPointLight) {
                const J = t.get(O);
                if (J.color.copy(O.color).multiplyScalar(O.intensity * E),
                J.distance = O.distance,
                J.decay = O.decay,
                O.castShadow) {
                    const D = O.shadow
                      , se = i.get(O);
                    se.shadowBias = D.bias,
                    se.shadowNormalBias = D.normalBias,
                    se.shadowRadius = D.radius,
                    se.shadowMapSize = D.mapSize,
                    se.shadowCameraNear = D.camera.near,
                    se.shadowCameraFar = D.camera.far,
                    n.pointShadow[p] = se,
                    n.pointShadowMap[p] = K,
                    n.pointShadowMatrix[p] = O.shadow.matrix,
                    C++
                }
                n.point[p] = J,
                p++
            } else if (O.isHemisphereLight) {
                const J = t.get(O);
                J.skyColor.copy(O.color).multiplyScalar(V * E),
                J.groundColor.copy(O.groundColor).multiplyScalar(V * E),
                n.hemi[y] = J,
                y++
            }
        }
        M > 0 && (e.isWebGL2 ? s.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Te.LTC_FLOAT_1,
        n.rectAreaLTC2 = Te.LTC_FLOAT_2) : (n.rectAreaLTC1 = Te.LTC_HALF_1,
        n.rectAreaLTC2 = Te.LTC_HALF_2) : s.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = Te.LTC_FLOAT_1,
        n.rectAreaLTC2 = Te.LTC_FLOAT_2) : s.has("OES_texture_half_float_linear") === !0 ? (n.rectAreaLTC1 = Te.LTC_HALF_1,
        n.rectAreaLTC2 = Te.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        n.ambient[0] = d,
        n.ambient[1] = f,
        n.ambient[2] = m;
        const G = n.hash;
        (G.directionalLength !== _ || G.pointLength !== p || G.spotLength !== g || G.rectAreaLength !== M || G.hemiLength !== y || G.numDirectionalShadows !== S || G.numPointShadows !== C || G.numSpotShadows !== w || G.numSpotMaps !== T || G.numLightProbes !== b) && (n.directional.length = _,
        n.spot.length = g,
        n.rectArea.length = M,
        n.point.length = p,
        n.hemi.length = y,
        n.directionalShadow.length = S,
        n.directionalShadowMap.length = S,
        n.pointShadow.length = C,
        n.pointShadowMap.length = C,
        n.spotShadow.length = w,
        n.spotShadowMap.length = w,
        n.directionalShadowMatrix.length = S,
        n.pointShadowMatrix.length = C,
        n.spotLightMatrix.length = w + T - B,
        n.spotLightMap.length = T,
        n.numSpotLightShadowsWithMaps = B,
        n.numLightProbes = b,
        G.directionalLength = _,
        G.pointLength = p,
        G.spotLength = g,
        G.rectAreaLength = M,
        G.hemiLength = y,
        G.numDirectionalShadows = S,
        G.numPointShadows = C,
        G.numSpotShadows = w,
        G.numSpotMaps = T,
        G.numLightProbes = b,
        n.version = WR++)
    }
    function c(h, u) {
        let d = 0
          , f = 0
          , m = 0
          , _ = 0
          , p = 0;
        const g = u.matrixWorldInverse;
        for (let M = 0, y = h.length; M < y; M++) {
            const S = h[M];
            if (S.isDirectionalLight) {
                const C = n.directional[d];
                C.direction.setFromMatrixPosition(S.matrixWorld),
                r.setFromMatrixPosition(S.target.matrixWorld),
                C.direction.sub(r),
                C.direction.transformDirection(g),
                d++
            } else if (S.isSpotLight) {
                const C = n.spot[m];
                C.position.setFromMatrixPosition(S.matrixWorld),
                C.position.applyMatrix4(g),
                C.direction.setFromMatrixPosition(S.matrixWorld),
                r.setFromMatrixPosition(S.target.matrixWorld),
                C.direction.sub(r),
                C.direction.transformDirection(g),
                m++
            } else if (S.isRectAreaLight) {
                const C = n.rectArea[_];
                C.position.setFromMatrixPosition(S.matrixWorld),
                C.position.applyMatrix4(g),
                a.identity(),
                o.copy(S.matrixWorld),
                o.premultiply(g),
                a.extractRotation(o),
                C.halfWidth.set(S.width * .5, 0, 0),
                C.halfHeight.set(0, S.height * .5, 0),
                C.halfWidth.applyMatrix4(a),
                C.halfHeight.applyMatrix4(a),
                _++
            } else if (S.isPointLight) {
                const C = n.point[f];
                C.position.setFromMatrixPosition(S.matrixWorld),
                C.position.applyMatrix4(g),
                f++
            } else if (S.isHemisphereLight) {
                const C = n.hemi[p];
                C.direction.setFromMatrixPosition(S.matrixWorld),
                C.direction.transformDirection(g),
                p++
            }
        }
    }
    return {
        setup: l,
        setupView: c,
        state: n
    }
}
function __(s, e) {
    const t = new qR(s,e)
      , i = []
      , n = [];
    function r() {
        i.length = 0,
        n.length = 0
    }
    function o(u) {
        i.push(u)
    }
    function a(u) {
        n.push(u)
    }
    function l(u) {
        t.setup(i, u)
    }
    function c(u) {
        t.setupView(i, u)
    }
    return {
        init: r,
        state: {
            lightsArray: i,
            shadowsArray: n,
            lights: t
        },
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a
    }
}
function YR(s, e) {
    let t = new WeakMap;
    function i(r, o=0) {
        const a = t.get(r);
        let l;
        return a === void 0 ? (l = new __(s,e),
        t.set(r, [l])) : o >= a.length ? (l = new __(s,e),
        a.push(l)) : l = a[o],
        l
    }
    function n() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: n
    }
}
class $R extends Nh {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = GM,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class jR extends Nh {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const ZR = `
void main() {

	gl_Position = vec4( position, 1.0 );

}
`
  , KR = `
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	const float samples = float( VSM_SAMPLES );

	float mean = 0.0;
	float squared_mean = 0.0;

	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {

		float uvOffset = uvStart + i * uvStride;

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean / samples;
	squared_mean = squared_mean / samples;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;
function JR(s, e, t) {
    let i = new Yx;
    const n = new Rt
      , r = new Rt
      , o = new pi
      , a = new $R({
        depthPacking: VM
    })
      , l = new jR
      , c = {}
      , h = t.maxTextureSize
      , u = {
        [us]: Yi,
        [Yi]: us,
        [gr]: gr
    }
      , d = new wr({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Rt
            },
            radius: {
                value: 4
            }
        },
        vertexShader: ZR,
        fragmentShader: KR
    })
      , f = d.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const m = new Pl;
    m.setAttribute("position", new Zn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const _ = new Yn(m,d)
      , p = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Z0;
    let g = this.type;
    this.render = function(w, T, B) {
        if (p.enabled === !1 || p.autoUpdate === !1 && p.needsUpdate === !1 || w.length === 0)
            return;
        const b = s.getRenderTarget()
          , E = s.getActiveCubeFace()
          , G = s.getActiveMipmapLevel()
          , k = s.state;
        k.setBlending(rs),
        k.buffers.color.setClear(1, 1, 1, 1),
        k.buffers.depth.setTest(!0),
        k.setScissorTest(!1);
        const te = g !== dr && this.type === dr
          , O = g === dr && this.type !== dr;
        for (let H = 0, V = w.length; H < V; H++) {
            const Y = w[H]
              , K = Y.shadow;
            if (K === void 0) {
                console.warn("THREE.WebGLShadowMap:", Y, "has no shadow.");
                continue
            }
            if (K.autoUpdate === !1 && K.needsUpdate === !1)
                continue;
            n.copy(K.mapSize);
            const J = K.getFrameExtents();
            if (n.multiply(J),
            r.copy(K.mapSize),
            (n.x > h || n.y > h) && (n.x > h && (r.x = Math.floor(h / J.x),
            n.x = r.x * J.x,
            K.mapSize.x = r.x),
            n.y > h && (r.y = Math.floor(h / J.y),
            n.y = r.y * J.y,
            K.mapSize.y = r.y)),
            K.map === null || te === !0 || O === !0) {
                const se = this.type !== dr ? {
                    minFilter: Ii,
                    magFilter: Ii
                } : {};
                K.map !== null && K.map.dispose(),
                K.map = new no(n.x,n.y,se),
                K.map.texture.name = Y.name + ".shadowMap",
                K.camera.updateProjectionMatrix()
            }
            s.setRenderTarget(K.map),
            s.clear();
            const D = K.getViewportCount();
            for (let se = 0; se < D; se++) {
                const de = K.getViewport(se);
                o.set(r.x * de.x, r.y * de.y, r.x * de.z, r.y * de.w),
                k.viewport(o),
                K.updateMatrices(Y, se),
                i = K.getFrustum(),
                S(T, B, K.camera, Y, this.type)
            }
            K.isPointLightShadow !== !0 && this.type === dr && M(K, B),
            K.needsUpdate = !1
        }
        g = this.type,
        p.needsUpdate = !1,
        s.setRenderTarget(b, E, G)
    }
    ;
    function M(w, T) {
        const B = e.update(_);
        d.defines.VSM_SAMPLES !== w.blurSamples && (d.defines.VSM_SAMPLES = w.blurSamples,
        f.defines.VSM_SAMPLES = w.blurSamples,
        d.needsUpdate = !0,
        f.needsUpdate = !0),
        w.mapPass === null && (w.mapPass = new no(n.x,n.y)),
        d.uniforms.shadow_pass.value = w.map.texture,
        d.uniforms.resolution.value = w.mapSize,
        d.uniforms.radius.value = w.radius,
        s.setRenderTarget(w.mapPass),
        s.clear(),
        s.renderBufferDirect(T, null, B, d, _, null),
        f.uniforms.shadow_pass.value = w.mapPass.texture,
        f.uniforms.resolution.value = w.mapSize,
        f.uniforms.radius.value = w.radius,
        s.setRenderTarget(w.map),
        s.clear(),
        s.renderBufferDirect(T, null, B, f, _, null)
    }
    function y(w, T, B, b) {
        let E = null;
        const G = B.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
        if (G !== void 0)
            E = G;
        else if (E = B.isPointLight === !0 ? l : a,
        s.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0) {
            const k = E.uuid
              , te = T.uuid;
            let O = c[k];
            O === void 0 && (O = {},
            c[k] = O);
            let H = O[te];
            H === void 0 && (H = E.clone(),
            O[te] = H,
            T.addEventListener("dispose", C)),
            E = H
        }
        if (E.visible = T.visible,
        E.wireframe = T.wireframe,
        b === dr ? E.side = T.shadowSide !== null ? T.shadowSide : T.side : E.side = T.shadowSide !== null ? T.shadowSide : u[T.side],
        E.alphaMap = T.alphaMap,
        E.alphaTest = T.alphaTest,
        E.map = T.map,
        E.clipShadows = T.clipShadows,
        E.clippingPlanes = T.clippingPlanes,
        E.clipIntersection = T.clipIntersection,
        E.displacementMap = T.displacementMap,
        E.displacementScale = T.displacementScale,
        E.displacementBias = T.displacementBias,
        E.wireframeLinewidth = T.wireframeLinewidth,
        E.linewidth = T.linewidth,
        B.isPointLight === !0 && E.isMeshDistanceMaterial === !0) {
            const k = s.properties.get(E);
            k.light = B
        }
        return E
    }
    function S(w, T, B, b, E) {
        if (w.visible === !1)
            return;
        if (w.layers.test(T.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && E === dr) && (!w.frustumCulled || i.intersectsObject(w))) {
            w.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, w.matrixWorld);
            const te = e.update(w)
              , O = w.material;
            if (Array.isArray(O)) {
                const H = te.groups;
                for (let V = 0, Y = H.length; V < Y; V++) {
                    const K = H[V]
                      , J = O[K.materialIndex];
                    if (J && J.visible) {
                        const D = y(w, J, b, E);
                        w.onBeforeShadow(s, w, T, B, te, D, K),
                        s.renderBufferDirect(B, null, te, D, w, K),
                        w.onAfterShadow(s, w, T, B, te, D, K)
                    }
                }
            } else if (O.visible) {
                const H = y(w, O, b, E);
                w.onBeforeShadow(s, w, T, B, te, H, null),
                s.renderBufferDirect(B, null, te, H, w, null),
                w.onAfterShadow(s, w, T, B, te, H, null)
            }
        }
        const k = w.children;
        for (let te = 0, O = k.length; te < O; te++)
            S(k[te], T, B, b, E)
    }
    function C(w) {
        w.target.removeEventListener("dispose", C);
        for (const B in c) {
            const b = c[B]
              , E = w.target.uuid;
            E in b && (b[E].dispose(),
            delete b[E])
        }
    }
}
function QR(s, e, t) {
    const i = t.isWebGL2;
    function n() {
        let z = !1;
        const _e = new pi;
        let xe = null;
        const Xe = new pi(0,0,0,0);
        return {
            setMask: function(He) {
                xe !== He && !z && (s.colorMask(He, He, He, He),
                xe = He)
            },
            setLocked: function(He) {
                z = He
            },
            setClear: function(He, ut, Ie, De, nt) {
                nt === !0 && (He *= De,
                ut *= De,
                Ie *= De),
                _e.set(He, ut, Ie, De),
                Xe.equals(_e) === !1 && (s.clearColor(He, ut, Ie, De),
                Xe.copy(_e))
            },
            reset: function() {
                z = !1,
                xe = null,
                Xe.set(-1, 0, 0, 0)
            }
        }
    }
    function r() {
        let z = !1
          , _e = null
          , xe = null
          , Xe = null;
        return {
            setTest: function(He) {
                He ? ke(s.DEPTH_TEST) : Ve(s.DEPTH_TEST)
            },
            setMask: function(He) {
                _e !== He && !z && (s.depthMask(He),
                _e = He)
            },
            setFunc: function(He) {
                if (xe !== He) {
                    switch (He) {
                    case xM:
                        s.depthFunc(s.NEVER);
                        break;
                    case yM:
                        s.depthFunc(s.ALWAYS);
                        break;
                    case vM:
                        s.depthFunc(s.LESS);
                        break;
                    case Sh:
                        s.depthFunc(s.LEQUAL);
                        break;
                    case MM:
                        s.depthFunc(s.EQUAL);
                        break;
                    case SM:
                        s.depthFunc(s.GEQUAL);
                        break;
                    case bM:
                        s.depthFunc(s.GREATER);
                        break;
                    case TM:
                        s.depthFunc(s.NOTEQUAL);
                        break;
                    default:
                        s.depthFunc(s.LEQUAL)
                    }
                    xe = He
                }
            },
            setLocked: function(He) {
                z = He
            },
            setClear: function(He) {
                Xe !== He && (s.clearDepth(He),
                Xe = He)
            },
            reset: function() {
                z = !1,
                _e = null,
                xe = null,
                Xe = null
            }
        }
    }
    function o() {
        let z = !1
          , _e = null
          , xe = null
          , Xe = null
          , He = null
          , ut = null
          , Ie = null
          , De = null
          , nt = null;
        return {
            setTest: function(rt) {
                z || (rt ? ke(s.STENCIL_TEST) : Ve(s.STENCIL_TEST))
            },
            setMask: function(rt) {
                _e !== rt && !z && (s.stencilMask(rt),
                _e = rt)
            },
            setFunc: function(rt, Me, tt) {
                (xe !== rt || Xe !== Me || He !== tt) && (s.stencilFunc(rt, Me, tt),
                xe = rt,
                Xe = Me,
                He = tt)
            },
            setOp: function(rt, Me, tt) {
                (ut !== rt || Ie !== Me || De !== tt) && (s.stencilOp(rt, Me, tt),
                ut = rt,
                Ie = Me,
                De = tt)
            },
            setLocked: function(rt) {
                z = rt
            },
            setClear: function(rt) {
                nt !== rt && (s.clearStencil(rt),
                nt = rt)
            },
            reset: function() {
                z = !1,
                _e = null,
                xe = null,
                Xe = null,
                He = null,
                ut = null,
                Ie = null,
                De = null,
                nt = null
            }
        }
    }
    const a = new n
      , l = new r
      , c = new o
      , h = new WeakMap
      , u = new WeakMap;
    let d = {}
      , f = {}
      , m = new WeakMap
      , _ = []
      , p = null
      , g = !1
      , M = null
      , y = null
      , S = null
      , C = null
      , w = null
      , T = null
      , B = null
      , b = new At(0,0,0)
      , E = 0
      , G = !1
      , k = null
      , te = null
      , O = null
      , H = null
      , V = null;
    const Y = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let K = !1
      , J = 0;
    const D = s.getParameter(s.VERSION);
    D.indexOf("WebGL") !== -1 ? (J = parseFloat(/^WebGL (\d)/.exec(D)[1]),
    K = J >= 1) : D.indexOf("OpenGL ES") !== -1 && (J = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]),
    K = J >= 2);
    let se = null
      , de = {};
    const Q = s.getParameter(s.SCISSOR_BOX)
      , re = s.getParameter(s.VIEWPORT)
      , ge = new pi().fromArray(Q)
      , fe = new pi().fromArray(re);
    function ve(z, _e, xe, Xe) {
        const He = new Uint8Array(4)
          , ut = s.createTexture();
        s.bindTexture(z, ut),
        s.texParameteri(z, s.TEXTURE_MIN_FILTER, s.NEAREST),
        s.texParameteri(z, s.TEXTURE_MAG_FILTER, s.NEAREST);
        for (let Ie = 0; Ie < xe; Ie++)
            i && (z === s.TEXTURE_3D || z === s.TEXTURE_2D_ARRAY) ? s.texImage3D(_e, 0, s.RGBA, 1, 1, Xe, 0, s.RGBA, s.UNSIGNED_BYTE, He) : s.texImage2D(_e + Ie, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, He);
        return ut
    }
    const Ue = {};
    Ue[s.TEXTURE_2D] = ve(s.TEXTURE_2D, s.TEXTURE_2D, 1),
    Ue[s.TEXTURE_CUBE_MAP] = ve(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    i && (Ue[s.TEXTURE_2D_ARRAY] = ve(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1),
    Ue[s.TEXTURE_3D] = ve(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    ke(s.DEPTH_TEST),
    l.setFunc(Sh),
    Ye(!1),
    L(Zp),
    ke(s.CULL_FACE),
    Pe(rs);
    function ke(z) {
        d[z] !== !0 && (s.enable(z),
        d[z] = !0)
    }
    function Ve(z) {
        d[z] !== !1 && (s.disable(z),
        d[z] = !1)
    }
    function Ke(z, _e) {
        return f[z] !== _e ? (s.bindFramebuffer(z, _e),
        f[z] = _e,
        i && (z === s.DRAW_FRAMEBUFFER && (f[s.FRAMEBUFFER] = _e),
        z === s.FRAMEBUFFER && (f[s.DRAW_FRAMEBUFFER] = _e)),
        !0) : !1
    }
    function $(z, _e) {
        let xe = _
          , Xe = !1;
        if (z)
            if (xe = m.get(_e),
            xe === void 0 && (xe = [],
            m.set(_e, xe)),
            z.isWebGLMultipleRenderTargets) {
                const He = z.texture;
                if (xe.length !== He.length || xe[0] !== s.COLOR_ATTACHMENT0) {
                    for (let ut = 0, Ie = He.length; ut < Ie; ut++)
                        xe[ut] = s.COLOR_ATTACHMENT0 + ut;
                    xe.length = He.length,
                    Xe = !0
                }
            } else
                xe[0] !== s.COLOR_ATTACHMENT0 && (xe[0] = s.COLOR_ATTACHMENT0,
                Xe = !0);
        else
            xe[0] !== s.BACK && (xe[0] = s.BACK,
            Xe = !0);
        Xe && (t.isWebGL2 ? s.drawBuffers(xe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(xe))
    }
    function Qe(z) {
        return p !== z ? (s.useProgram(z),
        p = z,
        !0) : !1
    }
    const Re = {
        [Is]: s.FUNC_ADD,
        [nM]: s.FUNC_SUBTRACT,
        [rM]: s.FUNC_REVERSE_SUBTRACT
    };
    if (i)
        Re[em] = s.MIN,
        Re[tm] = s.MAX;
    else {
        const z = e.get("EXT_blend_minmax");
        z !== null && (Re[em] = z.MIN_EXT,
        Re[tm] = z.MAX_EXT)
    }
    const ze = {
        [sM]: s.ZERO,
        [oM]: s.ONE,
        [aM]: s.SRC_COLOR,
        [Zd]: s.SRC_ALPHA,
        [fM]: s.SRC_ALPHA_SATURATE,
        [uM]: s.DST_COLOR,
        [cM]: s.DST_ALPHA,
        [lM]: s.ONE_MINUS_SRC_COLOR,
        [Kd]: s.ONE_MINUS_SRC_ALPHA,
        [dM]: s.ONE_MINUS_DST_COLOR,
        [hM]: s.ONE_MINUS_DST_ALPHA,
        [pM]: s.CONSTANT_COLOR,
        [mM]: s.ONE_MINUS_CONSTANT_COLOR,
        [gM]: s.CONSTANT_ALPHA,
        [_M]: s.ONE_MINUS_CONSTANT_ALPHA
    };
    function Pe(z, _e, xe, Xe, He, ut, Ie, De, nt, rt) {
        if (z === rs) {
            g === !0 && (Ve(s.BLEND),
            g = !1);
            return
        }
        if (g === !1 && (ke(s.BLEND),
        g = !0),
        z !== iM) {
            if (z !== M || rt !== G) {
                if ((y !== Is || w !== Is) && (s.blendEquation(s.FUNC_ADD),
                y = Is,
                w = Is),
                rt)
                    switch (z) {
                    case ia:
                        s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Kp:
                        s.blendFunc(s.ONE, s.ONE);
                        break;
                    case Jp:
                        s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                        break;
                    case Qp:
                        s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", z);
                        break
                    }
                else
                    switch (z) {
                    case ia:
                        s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Kp:
                        s.blendFunc(s.SRC_ALPHA, s.ONE);
                        break;
                    case Jp:
                        s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                        break;
                    case Qp:
                        s.blendFunc(s.ZERO, s.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", z);
                        break
                    }
                S = null,
                C = null,
                T = null,
                B = null,
                b.set(0, 0, 0),
                E = 0,
                M = z,
                G = rt
            }
            return
        }
        He = He || _e,
        ut = ut || xe,
        Ie = Ie || Xe,
        (_e !== y || He !== w) && (s.blendEquationSeparate(Re[_e], Re[He]),
        y = _e,
        w = He),
        (xe !== S || Xe !== C || ut !== T || Ie !== B) && (s.blendFuncSeparate(ze[xe], ze[Xe], ze[ut], ze[Ie]),
        S = xe,
        C = Xe,
        T = ut,
        B = Ie),
        (De.equals(b) === !1 || nt !== E) && (s.blendColor(De.r, De.g, De.b, nt),
        b.copy(De),
        E = nt),
        M = z,
        G = !1
    }
    function Z(z, _e) {
        z.side === gr ? Ve(s.CULL_FACE) : ke(s.CULL_FACE);
        let xe = z.side === Yi;
        _e && (xe = !xe),
        Ye(xe),
        z.blending === ia && z.transparent === !1 ? Pe(rs) : Pe(z.blending, z.blendEquation, z.blendSrc, z.blendDst, z.blendEquationAlpha, z.blendSrcAlpha, z.blendDstAlpha, z.blendColor, z.blendAlpha, z.premultipliedAlpha),
        l.setFunc(z.depthFunc),
        l.setTest(z.depthTest),
        l.setMask(z.depthWrite),
        a.setMask(z.colorWrite);
        const Xe = z.stencilWrite;
        c.setTest(Xe),
        Xe && (c.setMask(z.stencilWriteMask),
        c.setFunc(z.stencilFunc, z.stencilRef, z.stencilFuncMask),
        c.setOp(z.stencilFail, z.stencilZFail, z.stencilZPass)),
        X(z.polygonOffset, z.polygonOffsetFactor, z.polygonOffsetUnits),
        z.alphaToCoverage === !0 ? ke(s.SAMPLE_ALPHA_TO_COVERAGE) : Ve(s.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function Ye(z) {
        k !== z && (z ? s.frontFace(s.CW) : s.frontFace(s.CCW),
        k = z)
    }
    function L(z) {
        z !== Qv ? (ke(s.CULL_FACE),
        z !== te && (z === Zp ? s.cullFace(s.BACK) : z === eM ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Ve(s.CULL_FACE),
        te = z
    }
    function R(z) {
        z !== O && (K && s.lineWidth(z),
        O = z)
    }
    function X(z, _e, xe) {
        z ? (ke(s.POLYGON_OFFSET_FILL),
        (H !== _e || V !== xe) && (s.polygonOffset(_e, xe),
        H = _e,
        V = xe)) : Ve(s.POLYGON_OFFSET_FILL)
    }
    function ue(z) {
        z ? ke(s.SCISSOR_TEST) : Ve(s.SCISSOR_TEST)
    }
    function ce(z) {
        z === void 0 && (z = s.TEXTURE0 + Y - 1),
        se !== z && (s.activeTexture(z),
        se = z)
    }
    function pe(z, _e, xe) {
        xe === void 0 && (se === null ? xe = s.TEXTURE0 + Y - 1 : xe = se);
        let Xe = de[xe];
        Xe === void 0 && (Xe = {
            type: void 0,
            texture: void 0
        },
        de[xe] = Xe),
        (Xe.type !== z || Xe.texture !== _e) && (se !== xe && (s.activeTexture(xe),
        se = xe),
        s.bindTexture(z, _e || Ue[z]),
        Xe.type = z,
        Xe.texture = _e)
    }
    function be() {
        const z = de[se];
        z !== void 0 && z.type !== void 0 && (s.bindTexture(z.type, null),
        z.type = void 0,
        z.texture = void 0)
    }
    function me() {
        try {
            s.compressedTexImage2D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function Ee() {
        try {
            s.compressedTexImage3D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function Oe() {
        try {
            s.texSubImage2D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function Je() {
        try {
            s.texSubImage3D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function le() {
        try {
            s.compressedTexSubImage2D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function lt() {
        try {
            s.compressedTexSubImage3D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function Ze() {
        try {
            s.texStorage2D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function We() {
        try {
            s.texStorage3D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function Ce() {
        try {
            s.texImage2D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function Le() {
        try {
            s.texImage3D.apply(s, arguments)
        } catch (z) {
            console.error("THREE.WebGLState:", z)
        }
    }
    function $e(z) {
        ge.equals(z) === !1 && (s.scissor(z.x, z.y, z.z, z.w),
        ge.copy(z))
    }
    function et(z) {
        fe.equals(z) === !1 && (s.viewport(z.x, z.y, z.z, z.w),
        fe.copy(z))
    }
    function st(z, _e) {
        let xe = u.get(_e);
        xe === void 0 && (xe = new WeakMap,
        u.set(_e, xe));
        let Xe = xe.get(z);
        Xe === void 0 && (Xe = s.getUniformBlockIndex(_e, z.name),
        xe.set(z, Xe))
    }
    function we(z, _e) {
        const Xe = u.get(_e).get(z);
        h.get(_e) !== Xe && (s.uniformBlockBinding(_e, Xe, z.__bindingPointIndex),
        h.set(_e, Xe))
    }
    function j() {
        s.disable(s.BLEND),
        s.disable(s.CULL_FACE),
        s.disable(s.DEPTH_TEST),
        s.disable(s.POLYGON_OFFSET_FILL),
        s.disable(s.SCISSOR_TEST),
        s.disable(s.STENCIL_TEST),
        s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),
        s.blendEquation(s.FUNC_ADD),
        s.blendFunc(s.ONE, s.ZERO),
        s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO),
        s.blendColor(0, 0, 0, 0),
        s.colorMask(!0, !0, !0, !0),
        s.clearColor(0, 0, 0, 0),
        s.depthMask(!0),
        s.depthFunc(s.LESS),
        s.clearDepth(1),
        s.stencilMask(4294967295),
        s.stencilFunc(s.ALWAYS, 0, 4294967295),
        s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
        s.clearStencil(0),
        s.cullFace(s.BACK),
        s.frontFace(s.CCW),
        s.polygonOffset(0, 0),
        s.activeTexture(s.TEXTURE0),
        s.bindFramebuffer(s.FRAMEBUFFER, null),
        i === !0 && (s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
        s.bindFramebuffer(s.READ_FRAMEBUFFER, null)),
        s.useProgram(null),
        s.lineWidth(1),
        s.scissor(0, 0, s.canvas.width, s.canvas.height),
        s.viewport(0, 0, s.canvas.width, s.canvas.height),
        d = {},
        se = null,
        de = {},
        f = {},
        m = new WeakMap,
        _ = [],
        p = null,
        g = !1,
        M = null,
        y = null,
        S = null,
        C = null,
        w = null,
        T = null,
        B = null,
        b = new At(0,0,0),
        E = 0,
        G = !1,
        k = null,
        te = null,
        O = null,
        H = null,
        V = null,
        ge.set(0, 0, s.canvas.width, s.canvas.height),
        fe.set(0, 0, s.canvas.width, s.canvas.height),
        a.reset(),
        l.reset(),
        c.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: c
        },
        enable: ke,
        disable: Ve,
        bindFramebuffer: Ke,
        drawBuffers: $,
        useProgram: Qe,
        setBlending: Pe,
        setMaterial: Z,
        setFlipSided: Ye,
        setCullFace: L,
        setLineWidth: R,
        setPolygonOffset: X,
        setScissorTest: ue,
        activeTexture: ce,
        bindTexture: pe,
        unbindTexture: be,
        compressedTexImage2D: me,
        compressedTexImage3D: Ee,
        texImage2D: Ce,
        texImage3D: Le,
        updateUBOMapping: st,
        uniformBlockBinding: we,
        texStorage2D: Ze,
        texStorage3D: We,
        texSubImage2D: Oe,
        texSubImage3D: Je,
        compressedTexSubImage2D: le,
        compressedTexSubImage3D: lt,
        scissor: $e,
        viewport: et,
        reset: j
    }
}
function eC(s, e, t, i, n, r, o) {
    const a = n.isWebGL2
      , l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , h = new WeakMap;
    let u;
    const d = new WeakMap;
    let f = !1;
    try {
        f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function m(L, R) {
        return f ? new OffscreenCanvas(L,R) : vl("canvas")
    }
    function _(L, R, X, ue) {
        let ce = 1;
        if ((L.width > ue || L.height > ue) && (ce = ue / Math.max(L.width, L.height)),
        ce < 1 || R === !0)
            if (typeof HTMLImageElement < "u" && L instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && L instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && L instanceof ImageBitmap) {
                const pe = R ? jd : Math.floor
                  , be = pe(ce * L.width)
                  , me = pe(ce * L.height);
                u === void 0 && (u = m(be, me));
                const Ee = X ? m(be, me) : u;
                return Ee.width = be,
                Ee.height = me,
                Ee.getContext("2d").drawImage(L, 0, 0, be, me),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + L.width + "x" + L.height + ") to (" + be + "x" + me + ")."),
                Ee
            } else
                return "data"in L && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + L.width + "x" + L.height + ")."),
                L;
        return L
    }
    function p(L) {
        return $p(L.width) && $p(L.height)
    }
    function g(L) {
        return a ? !1 : L.wrapS !== Fn || L.wrapT !== Fn || L.minFilter !== Ii && L.minFilter !== Hi
    }
    function M(L, R) {
        return L.generateMipmaps && R && L.minFilter !== Ii && L.minFilter !== Hi
    }
    function y(L) {
        s.generateMipmap(L)
    }
    function S(L, R, X, ue, ce=!1) {
        if (a === !1)
            return R;
        if (L !== null) {
            if (s[L] !== void 0)
                return s[L];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + L + "'")
        }
        let pe = R;
        if (R === s.RED && (X === s.FLOAT && (pe = s.R32F),
        X === s.HALF_FLOAT && (pe = s.R16F),
        X === s.UNSIGNED_BYTE && (pe = s.R8)),
        R === s.RED_INTEGER && (X === s.UNSIGNED_BYTE && (pe = s.R8UI),
        X === s.UNSIGNED_SHORT && (pe = s.R16UI),
        X === s.UNSIGNED_INT && (pe = s.R32UI),
        X === s.BYTE && (pe = s.R8I),
        X === s.SHORT && (pe = s.R16I),
        X === s.INT && (pe = s.R32I)),
        R === s.RG && (X === s.FLOAT && (pe = s.RG32F),
        X === s.HALF_FLOAT && (pe = s.RG16F),
        X === s.UNSIGNED_BYTE && (pe = s.RG8)),
        R === s.RGBA) {
            const be = ce ? bh : wt.getTransfer(ue);
            X === s.FLOAT && (pe = s.RGBA32F),
            X === s.HALF_FLOAT && (pe = s.RGBA16F),
            X === s.UNSIGNED_BYTE && (pe = be === It ? s.SRGB8_ALPHA8 : s.RGBA8),
            X === s.UNSIGNED_SHORT_4_4_4_4 && (pe = s.RGBA4),
            X === s.UNSIGNED_SHORT_5_5_5_1 && (pe = s.RGB5_A1)
        }
        return (pe === s.R16F || pe === s.R32F || pe === s.RG16F || pe === s.RG32F || pe === s.RGBA16F || pe === s.RGBA32F) && e.get("EXT_color_buffer_float"),
        pe
    }
    function C(L, R, X) {
        return M(L, X) === !0 || L.isFramebufferTexture && L.minFilter !== Ii && L.minFilter !== Hi ? Math.log2(Math.max(R.width, R.height)) + 1 : L.mipmaps !== void 0 && L.mipmaps.length > 0 ? L.mipmaps.length : L.isCompressedTexture && Array.isArray(L.image) ? R.mipmaps.length : 1
    }
    function w(L) {
        return L === Ii || L === im || L === uu ? s.NEAREST : s.LINEAR
    }
    function T(L) {
        const R = L.target;
        R.removeEventListener("dispose", T),
        b(R),
        R.isVideoTexture && h.delete(R)
    }
    function B(L) {
        const R = L.target;
        R.removeEventListener("dispose", B),
        G(R)
    }
    function b(L) {
        const R = i.get(L);
        if (R.__webglInit === void 0)
            return;
        const X = L.source
          , ue = d.get(X);
        if (ue) {
            const ce = ue[R.__cacheKey];
            ce.usedTimes--,
            ce.usedTimes === 0 && E(L),
            Object.keys(ue).length === 0 && d.delete(X)
        }
        i.remove(L)
    }
    function E(L) {
        const R = i.get(L);
        s.deleteTexture(R.__webglTexture);
        const X = L.source
          , ue = d.get(X);
        delete ue[R.__cacheKey],
        o.memory.textures--
    }
    function G(L) {
        const R = L.texture
          , X = i.get(L)
          , ue = i.get(R);
        if (ue.__webglTexture !== void 0 && (s.deleteTexture(ue.__webglTexture),
        o.memory.textures--),
        L.depthTexture && L.depthTexture.dispose(),
        L.isWebGLCubeRenderTarget)
            for (let ce = 0; ce < 6; ce++) {
                if (Array.isArray(X.__webglFramebuffer[ce]))
                    for (let pe = 0; pe < X.__webglFramebuffer[ce].length; pe++)
                        s.deleteFramebuffer(X.__webglFramebuffer[ce][pe]);
                else
                    s.deleteFramebuffer(X.__webglFramebuffer[ce]);
                X.__webglDepthbuffer && s.deleteRenderbuffer(X.__webglDepthbuffer[ce])
            }
        else {
            if (Array.isArray(X.__webglFramebuffer))
                for (let ce = 0; ce < X.__webglFramebuffer.length; ce++)
                    s.deleteFramebuffer(X.__webglFramebuffer[ce]);
            else
                s.deleteFramebuffer(X.__webglFramebuffer);
            if (X.__webglDepthbuffer && s.deleteRenderbuffer(X.__webglDepthbuffer),
            X.__webglMultisampledFramebuffer && s.deleteFramebuffer(X.__webglMultisampledFramebuffer),
            X.__webglColorRenderbuffer)
                for (let ce = 0; ce < X.__webglColorRenderbuffer.length; ce++)
                    X.__webglColorRenderbuffer[ce] && s.deleteRenderbuffer(X.__webglColorRenderbuffer[ce]);
            X.__webglDepthRenderbuffer && s.deleteRenderbuffer(X.__webglDepthRenderbuffer)
        }
        if (L.isWebGLMultipleRenderTargets)
            for (let ce = 0, pe = R.length; ce < pe; ce++) {
                const be = i.get(R[ce]);
                be.__webglTexture && (s.deleteTexture(be.__webglTexture),
                o.memory.textures--),
                i.remove(R[ce])
            }
        i.remove(R),
        i.remove(L)
    }
    let k = 0;
    function te() {
        k = 0
    }
    function O() {
        const L = k;
        return L >= n.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + L + " texture units while this GPU supports only " + n.maxTextures),
        k += 1,
        L
    }
    function H(L) {
        const R = [];
        return R.push(L.wrapS),
        R.push(L.wrapT),
        R.push(L.wrapR || 0),
        R.push(L.magFilter),
        R.push(L.minFilter),
        R.push(L.anisotropy),
        R.push(L.internalFormat),
        R.push(L.format),
        R.push(L.type),
        R.push(L.generateMipmaps),
        R.push(L.premultiplyAlpha),
        R.push(L.flipY),
        R.push(L.unpackAlignment),
        R.push(L.colorSpace),
        R.join()
    }
    function V(L, R) {
        const X = i.get(L);
        if (L.isVideoTexture && Z(L),
        L.isRenderTargetTexture === !1 && L.version > 0 && X.__version !== L.version) {
            const ue = L.image;
            if (ue === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (ue.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                ge(X, L, R);
                return
            }
        }
        t.bindTexture(s.TEXTURE_2D, X.__webglTexture, s.TEXTURE0 + R)
    }
    function Y(L, R) {
        const X = i.get(L);
        if (L.version > 0 && X.__version !== L.version) {
            ge(X, L, R);
            return
        }
        t.bindTexture(s.TEXTURE_2D_ARRAY, X.__webglTexture, s.TEXTURE0 + R)
    }
    function K(L, R) {
        const X = i.get(L);
        if (L.version > 0 && X.__version !== L.version) {
            ge(X, L, R);
            return
        }
        t.bindTexture(s.TEXTURE_3D, X.__webglTexture, s.TEXTURE0 + R)
    }
    function J(L, R) {
        const X = i.get(L);
        if (L.version > 0 && X.__version !== L.version) {
            fe(X, L, R);
            return
        }
        t.bindTexture(s.TEXTURE_CUBE_MAP, X.__webglTexture, s.TEXTURE0 + R)
    }
    const D = {
        [ef]: s.REPEAT,
        [Fn]: s.CLAMP_TO_EDGE,
        [tf]: s.MIRRORED_REPEAT
    }
      , se = {
        [Ii]: s.NEAREST,
        [im]: s.NEAREST_MIPMAP_NEAREST,
        [uu]: s.NEAREST_MIPMAP_LINEAR,
        [Hi]: s.LINEAR,
        [DM]: s.LINEAR_MIPMAP_NEAREST,
        [xl]: s.LINEAR_MIPMAP_LINEAR
    }
      , de = {
        [qM]: s.NEVER,
        [JM]: s.ALWAYS,
        [YM]: s.LESS,
        [ax]: s.LEQUAL,
        [$M]: s.EQUAL,
        [KM]: s.GEQUAL,
        [jM]: s.GREATER,
        [ZM]: s.NOTEQUAL
    };
    function Q(L, R, X) {
        if (X ? (s.texParameteri(L, s.TEXTURE_WRAP_S, D[R.wrapS]),
        s.texParameteri(L, s.TEXTURE_WRAP_T, D[R.wrapT]),
        (L === s.TEXTURE_3D || L === s.TEXTURE_2D_ARRAY) && s.texParameteri(L, s.TEXTURE_WRAP_R, D[R.wrapR]),
        s.texParameteri(L, s.TEXTURE_MAG_FILTER, se[R.magFilter]),
        s.texParameteri(L, s.TEXTURE_MIN_FILTER, se[R.minFilter])) : (s.texParameteri(L, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
        s.texParameteri(L, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
        (L === s.TEXTURE_3D || L === s.TEXTURE_2D_ARRAY) && s.texParameteri(L, s.TEXTURE_WRAP_R, s.CLAMP_TO_EDGE),
        (R.wrapS !== Fn || R.wrapT !== Fn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        s.texParameteri(L, s.TEXTURE_MAG_FILTER, w(R.magFilter)),
        s.texParameteri(L, s.TEXTURE_MIN_FILTER, w(R.minFilter)),
        R.minFilter !== Ii && R.minFilter !== Hi && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        R.compareFunction && (s.texParameteri(L, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE),
        s.texParameteri(L, s.TEXTURE_COMPARE_FUNC, de[R.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            const ue = e.get("EXT_texture_filter_anisotropic");
            if (R.magFilter === Ii || R.minFilter !== uu && R.minFilter !== xl || R.type === Jr && e.has("OES_texture_float_linear") === !1 || a === !1 && R.type === yl && e.has("OES_texture_half_float_linear") === !1)
                return;
            (R.anisotropy > 1 || i.get(R).__currentAnisotropy) && (s.texParameterf(L, ue.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(R.anisotropy, n.getMaxAnisotropy())),
            i.get(R).__currentAnisotropy = R.anisotropy)
        }
    }
    function re(L, R) {
        let X = !1;
        L.__webglInit === void 0 && (L.__webglInit = !0,
        R.addEventListener("dispose", T));
        const ue = R.source;
        let ce = d.get(ue);
        ce === void 0 && (ce = {},
        d.set(ue, ce));
        const pe = H(R);
        if (pe !== L.__cacheKey) {
            ce[pe] === void 0 && (ce[pe] = {
                texture: s.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            X = !0),
            ce[pe].usedTimes++;
            const be = ce[L.__cacheKey];
            be !== void 0 && (ce[L.__cacheKey].usedTimes--,
            be.usedTimes === 0 && E(R)),
            L.__cacheKey = pe,
            L.__webglTexture = ce[pe].texture
        }
        return X
    }
    function ge(L, R, X) {
        let ue = s.TEXTURE_2D;
        (R.isDataArrayTexture || R.isCompressedArrayTexture) && (ue = s.TEXTURE_2D_ARRAY),
        R.isData3DTexture && (ue = s.TEXTURE_3D);
        const ce = re(L, R)
          , pe = R.source;
        t.bindTexture(ue, L.__webglTexture, s.TEXTURE0 + X);
        const be = i.get(pe);
        if (pe.version !== be.__version || ce === !0) {
            t.activeTexture(s.TEXTURE0 + X);
            const me = wt.getPrimaries(wt.workingColorSpace)
              , Ee = R.colorSpace === xn ? null : wt.getPrimaries(R.colorSpace)
              , Oe = R.colorSpace === xn || me === Ee ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, R.flipY),
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.premultiplyAlpha),
            s.pixelStorei(s.UNPACK_ALIGNMENT, R.unpackAlignment),
            s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Oe);
            const Je = g(R) && p(R.image) === !1;
            let le = _(R.image, Je, !1, n.maxTextureSize);
            le = Ye(R, le);
            const lt = p(le) || a
              , Ze = r.convert(R.format, R.colorSpace);
            let We = r.convert(R.type)
              , Ce = S(R.internalFormat, Ze, We, R.colorSpace, R.isVideoTexture);
            Q(ue, R, lt);
            let Le;
            const $e = R.mipmaps
              , et = a && R.isVideoTexture !== !0 && Ce !== sx
              , st = be.__version === void 0 || ce === !0
              , we = C(R, le, lt);
            if (R.isDepthTexture)
                Ce = s.DEPTH_COMPONENT,
                a ? R.type === Jr ? Ce = s.DEPTH_COMPONENT32F : R.type === Kr ? Ce = s.DEPTH_COMPONENT24 : R.type === qs ? Ce = s.DEPTH24_STENCIL8 : Ce = s.DEPTH_COMPONENT16 : R.type === Jr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                R.format === Ys && Ce === s.DEPTH_COMPONENT && R.type !== Gf && R.type !== Kr && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                R.type = Kr,
                We = r.convert(R.type)),
                R.format === pa && Ce === s.DEPTH_COMPONENT && (Ce = s.DEPTH_STENCIL,
                R.type !== qs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                R.type = qs,
                We = r.convert(R.type))),
                st && (et ? t.texStorage2D(s.TEXTURE_2D, 1, Ce, le.width, le.height) : t.texImage2D(s.TEXTURE_2D, 0, Ce, le.width, le.height, 0, Ze, We, null));
            else if (R.isDataTexture)
                if ($e.length > 0 && lt) {
                    et && st && t.texStorage2D(s.TEXTURE_2D, we, Ce, $e[0].width, $e[0].height);
                    for (let j = 0, z = $e.length; j < z; j++)
                        Le = $e[j],
                        et ? t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, Le.width, Le.height, Ze, We, Le.data) : t.texImage2D(s.TEXTURE_2D, j, Ce, Le.width, Le.height, 0, Ze, We, Le.data);
                    R.generateMipmaps = !1
                } else
                    et ? (st && t.texStorage2D(s.TEXTURE_2D, we, Ce, le.width, le.height),
                    t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, le.width, le.height, Ze, We, le.data)) : t.texImage2D(s.TEXTURE_2D, 0, Ce, le.width, le.height, 0, Ze, We, le.data);
            else if (R.isCompressedTexture)
                if (R.isCompressedArrayTexture) {
                    et && st && t.texStorage3D(s.TEXTURE_2D_ARRAY, we, Ce, $e[0].width, $e[0].height, le.depth);
                    for (let j = 0, z = $e.length; j < z; j++)
                        Le = $e[j],
                        R.format !== On ? Ze !== null ? et ? t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, j, 0, 0, 0, Le.width, Le.height, le.depth, Ze, Le.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, j, Ce, Le.width, Le.height, le.depth, 0, Le.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : et ? t.texSubImage3D(s.TEXTURE_2D_ARRAY, j, 0, 0, 0, Le.width, Le.height, le.depth, Ze, We, Le.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, j, Ce, Le.width, Le.height, le.depth, 0, Ze, We, Le.data)
                } else {
                    et && st && t.texStorage2D(s.TEXTURE_2D, we, Ce, $e[0].width, $e[0].height);
                    for (let j = 0, z = $e.length; j < z; j++)
                        Le = $e[j],
                        R.format !== On ? Ze !== null ? et ? t.compressedTexSubImage2D(s.TEXTURE_2D, j, 0, 0, Le.width, Le.height, Ze, Le.data) : t.compressedTexImage2D(s.TEXTURE_2D, j, Ce, Le.width, Le.height, 0, Le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : et ? t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, Le.width, Le.height, Ze, We, Le.data) : t.texImage2D(s.TEXTURE_2D, j, Ce, Le.width, Le.height, 0, Ze, We, Le.data)
                }
            else if (R.isDataArrayTexture)
                et ? (st && t.texStorage3D(s.TEXTURE_2D_ARRAY, we, Ce, le.width, le.height, le.depth),
                t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, le.width, le.height, le.depth, Ze, We, le.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Ce, le.width, le.height, le.depth, 0, Ze, We, le.data);
            else if (R.isData3DTexture)
                et ? (st && t.texStorage3D(s.TEXTURE_3D, we, Ce, le.width, le.height, le.depth),
                t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, le.width, le.height, le.depth, Ze, We, le.data)) : t.texImage3D(s.TEXTURE_3D, 0, Ce, le.width, le.height, le.depth, 0, Ze, We, le.data);
            else if (R.isFramebufferTexture) {
                if (st)
                    if (et)
                        t.texStorage2D(s.TEXTURE_2D, we, Ce, le.width, le.height);
                    else {
                        let j = le.width
                          , z = le.height;
                        for (let _e = 0; _e < we; _e++)
                            t.texImage2D(s.TEXTURE_2D, _e, Ce, j, z, 0, Ze, We, null),
                            j >>= 1,
                            z >>= 1
                    }
            } else if ($e.length > 0 && lt) {
                et && st && t.texStorage2D(s.TEXTURE_2D, we, Ce, $e[0].width, $e[0].height);
                for (let j = 0, z = $e.length; j < z; j++)
                    Le = $e[j],
                    et ? t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, Ze, We, Le) : t.texImage2D(s.TEXTURE_2D, j, Ce, Ze, We, Le);
                R.generateMipmaps = !1
            } else
                et ? (st && t.texStorage2D(s.TEXTURE_2D, we, Ce, le.width, le.height),
                t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Ze, We, le)) : t.texImage2D(s.TEXTURE_2D, 0, Ce, Ze, We, le);
            M(R, lt) && y(ue),
            be.__version = pe.version,
            R.onUpdate && R.onUpdate(R)
        }
        L.__version = R.version
    }
    function fe(L, R, X) {
        if (R.image.length !== 6)
            return;
        const ue = re(L, R)
          , ce = R.source;
        t.bindTexture(s.TEXTURE_CUBE_MAP, L.__webglTexture, s.TEXTURE0 + X);
        const pe = i.get(ce);
        if (ce.version !== pe.__version || ue === !0) {
            t.activeTexture(s.TEXTURE0 + X);
            const be = wt.getPrimaries(wt.workingColorSpace)
              , me = R.colorSpace === xn ? null : wt.getPrimaries(R.colorSpace)
              , Ee = R.colorSpace === xn || be === me ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, R.flipY),
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, R.premultiplyAlpha),
            s.pixelStorei(s.UNPACK_ALIGNMENT, R.unpackAlignment),
            s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ee);
            const Oe = R.isCompressedTexture || R.image[0].isCompressedTexture
              , Je = R.image[0] && R.image[0].isDataTexture
              , le = [];
            for (let j = 0; j < 6; j++)
                !Oe && !Je ? le[j] = _(R.image[j], !1, !0, n.maxCubemapSize) : le[j] = Je ? R.image[j].image : R.image[j],
                le[j] = Ye(R, le[j]);
            const lt = le[0]
              , Ze = p(lt) || a
              , We = r.convert(R.format, R.colorSpace)
              , Ce = r.convert(R.type)
              , Le = S(R.internalFormat, We, Ce, R.colorSpace)
              , $e = a && R.isVideoTexture !== !0
              , et = pe.__version === void 0 || ue === !0;
            let st = C(R, lt, Ze);
            Q(s.TEXTURE_CUBE_MAP, R, Ze);
            let we;
            if (Oe) {
                $e && et && t.texStorage2D(s.TEXTURE_CUBE_MAP, st, Le, lt.width, lt.height);
                for (let j = 0; j < 6; j++) {
                    we = le[j].mipmaps;
                    for (let z = 0; z < we.length; z++) {
                        const _e = we[z];
                        R.format !== On ? We !== null ? $e ? t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, z, 0, 0, _e.width, _e.height, We, _e.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, z, Le, _e.width, _e.height, 0, _e.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : $e ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, z, 0, 0, _e.width, _e.height, We, Ce, _e.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, z, Le, _e.width, _e.height, 0, We, Ce, _e.data)
                    }
                }
            } else {
                we = R.mipmaps,
                $e && et && (we.length > 0 && st++,
                t.texStorage2D(s.TEXTURE_CUBE_MAP, st, Le, le[0].width, le[0].height));
                for (let j = 0; j < 6; j++)
                    if (Je) {
                        $e ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, 0, 0, le[j].width, le[j].height, We, Ce, le[j].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, Le, le[j].width, le[j].height, 0, We, Ce, le[j].data);
                        for (let z = 0; z < we.length; z++) {
                            const xe = we[z].image[j].image;
                            $e ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, z + 1, 0, 0, xe.width, xe.height, We, Ce, xe.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, z + 1, Le, xe.width, xe.height, 0, We, Ce, xe.data)
                        }
                    } else {
                        $e ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, 0, 0, We, Ce, le[j]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, Le, We, Ce, le[j]);
                        for (let z = 0; z < we.length; z++) {
                            const _e = we[z];
                            $e ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, z + 1, 0, 0, We, Ce, _e.image[j]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, z + 1, Le, We, Ce, _e.image[j])
                        }
                    }
            }
            M(R, Ze) && y(s.TEXTURE_CUBE_MAP),
            pe.__version = ce.version,
            R.onUpdate && R.onUpdate(R)
        }
        L.__version = R.version
    }
    function ve(L, R, X, ue, ce, pe) {
        const be = r.convert(X.format, X.colorSpace)
          , me = r.convert(X.type)
          , Ee = S(X.internalFormat, be, me, X.colorSpace);
        if (!i.get(R).__hasExternalTextures) {
            const Je = Math.max(1, R.width >> pe)
              , le = Math.max(1, R.height >> pe);
            ce === s.TEXTURE_3D || ce === s.TEXTURE_2D_ARRAY ? t.texImage3D(ce, pe, Ee, Je, le, R.depth, 0, be, me, null) : t.texImage2D(ce, pe, Ee, Je, le, 0, be, me, null)
        }
        t.bindFramebuffer(s.FRAMEBUFFER, L),
        Pe(R) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, ue, ce, i.get(X).__webglTexture, 0, ze(R)) : (ce === s.TEXTURE_2D || ce >= s.TEXTURE_CUBE_MAP_POSITIVE_X && ce <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, ue, ce, i.get(X).__webglTexture, pe),
        t.bindFramebuffer(s.FRAMEBUFFER, null)
    }
    function Ue(L, R, X) {
        if (s.bindRenderbuffer(s.RENDERBUFFER, L),
        R.depthBuffer && !R.stencilBuffer) {
            let ue = a === !0 ? s.DEPTH_COMPONENT24 : s.DEPTH_COMPONENT16;
            if (X || Pe(R)) {
                const ce = R.depthTexture;
                ce && ce.isDepthTexture && (ce.type === Jr ? ue = s.DEPTH_COMPONENT32F : ce.type === Kr && (ue = s.DEPTH_COMPONENT24));
                const pe = ze(R);
                Pe(R) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, pe, ue, R.width, R.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, pe, ue, R.width, R.height)
            } else
                s.renderbufferStorage(s.RENDERBUFFER, ue, R.width, R.height);
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, L)
        } else if (R.depthBuffer && R.stencilBuffer) {
            const ue = ze(R);
            X && Pe(R) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, ue, s.DEPTH24_STENCIL8, R.width, R.height) : Pe(R) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, ue, s.DEPTH24_STENCIL8, R.width, R.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, R.width, R.height),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, L)
        } else {
            const ue = R.isWebGLMultipleRenderTargets === !0 ? R.texture : [R.texture];
            for (let ce = 0; ce < ue.length; ce++) {
                const pe = ue[ce]
                  , be = r.convert(pe.format, pe.colorSpace)
                  , me = r.convert(pe.type)
                  , Ee = S(pe.internalFormat, be, me, pe.colorSpace)
                  , Oe = ze(R);
                X && Pe(R) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Oe, Ee, R.width, R.height) : Pe(R) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Oe, Ee, R.width, R.height) : s.renderbufferStorage(s.RENDERBUFFER, Ee, R.width, R.height)
            }
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null)
    }
    function ke(L, R) {
        if (R && R.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(s.FRAMEBUFFER, L),
        !(R.depthTexture && R.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(R.depthTexture).__webglTexture || R.depthTexture.image.width !== R.width || R.depthTexture.image.height !== R.height) && (R.depthTexture.image.width = R.width,
        R.depthTexture.image.height = R.height,
        R.depthTexture.needsUpdate = !0),
        V(R.depthTexture, 0);
        const ue = i.get(R.depthTexture).__webglTexture
          , ce = ze(R);
        if (R.depthTexture.format === Ys)
            Pe(R) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, ue, 0, ce) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, ue, 0);
        else if (R.depthTexture.format === pa)
            Pe(R) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, ue, 0, ce) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, ue, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Ve(L) {
        const R = i.get(L)
          , X = L.isWebGLCubeRenderTarget === !0;
        if (L.depthTexture && !R.__autoAllocateDepthBuffer) {
            if (X)
                throw new Error("target.depthTexture not supported in Cube render targets");
            ke(R.__webglFramebuffer, L)
        } else if (X) {
            R.__webglDepthbuffer = [];
            for (let ue = 0; ue < 6; ue++)
                t.bindFramebuffer(s.FRAMEBUFFER, R.__webglFramebuffer[ue]),
                R.__webglDepthbuffer[ue] = s.createRenderbuffer(),
                Ue(R.__webglDepthbuffer[ue], L, !1)
        } else
            t.bindFramebuffer(s.FRAMEBUFFER, R.__webglFramebuffer),
            R.__webglDepthbuffer = s.createRenderbuffer(),
            Ue(R.__webglDepthbuffer, L, !1);
        t.bindFramebuffer(s.FRAMEBUFFER, null)
    }
    function Ke(L, R, X) {
        const ue = i.get(L);
        R !== void 0 && ve(ue.__webglFramebuffer, L, L.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0),
        X !== void 0 && Ve(L)
    }
    function $(L) {
        const R = L.texture
          , X = i.get(L)
          , ue = i.get(R);
        L.addEventListener("dispose", B),
        L.isWebGLMultipleRenderTargets !== !0 && (ue.__webglTexture === void 0 && (ue.__webglTexture = s.createTexture()),
        ue.__version = R.version,
        o.memory.textures++);
        const ce = L.isWebGLCubeRenderTarget === !0
          , pe = L.isWebGLMultipleRenderTargets === !0
          , be = p(L) || a;
        if (ce) {
            X.__webglFramebuffer = [];
            for (let me = 0; me < 6; me++)
                if (a && R.mipmaps && R.mipmaps.length > 0) {
                    X.__webglFramebuffer[me] = [];
                    for (let Ee = 0; Ee < R.mipmaps.length; Ee++)
                        X.__webglFramebuffer[me][Ee] = s.createFramebuffer()
                } else
                    X.__webglFramebuffer[me] = s.createFramebuffer()
        } else {
            if (a && R.mipmaps && R.mipmaps.length > 0) {
                X.__webglFramebuffer = [];
                for (let me = 0; me < R.mipmaps.length; me++)
                    X.__webglFramebuffer[me] = s.createFramebuffer()
            } else
                X.__webglFramebuffer = s.createFramebuffer();
            if (pe)
                if (n.drawBuffers) {
                    const me = L.texture;
                    for (let Ee = 0, Oe = me.length; Ee < Oe; Ee++) {
                        const Je = i.get(me[Ee]);
                        Je.__webglTexture === void 0 && (Je.__webglTexture = s.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && L.samples > 0 && Pe(L) === !1) {
                const me = pe ? R : [R];
                X.__webglMultisampledFramebuffer = s.createFramebuffer(),
                X.__webglColorRenderbuffer = [],
                t.bindFramebuffer(s.FRAMEBUFFER, X.__webglMultisampledFramebuffer);
                for (let Ee = 0; Ee < me.length; Ee++) {
                    const Oe = me[Ee];
                    X.__webglColorRenderbuffer[Ee] = s.createRenderbuffer(),
                    s.bindRenderbuffer(s.RENDERBUFFER, X.__webglColorRenderbuffer[Ee]);
                    const Je = r.convert(Oe.format, Oe.colorSpace)
                      , le = r.convert(Oe.type)
                      , lt = S(Oe.internalFormat, Je, le, Oe.colorSpace, L.isXRRenderTarget === !0)
                      , Ze = ze(L);
                    s.renderbufferStorageMultisample(s.RENDERBUFFER, Ze, lt, L.width, L.height),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ee, s.RENDERBUFFER, X.__webglColorRenderbuffer[Ee])
                }
                s.bindRenderbuffer(s.RENDERBUFFER, null),
                L.depthBuffer && (X.__webglDepthRenderbuffer = s.createRenderbuffer(),
                Ue(X.__webglDepthRenderbuffer, L, !0)),
                t.bindFramebuffer(s.FRAMEBUFFER, null)
            }
        }
        if (ce) {
            t.bindTexture(s.TEXTURE_CUBE_MAP, ue.__webglTexture),
            Q(s.TEXTURE_CUBE_MAP, R, be);
            for (let me = 0; me < 6; me++)
                if (a && R.mipmaps && R.mipmaps.length > 0)
                    for (let Ee = 0; Ee < R.mipmaps.length; Ee++)
                        ve(X.__webglFramebuffer[me][Ee], L, R, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + me, Ee);
                else
                    ve(X.__webglFramebuffer[me], L, R, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + me, 0);
            M(R, be) && y(s.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (pe) {
            const me = L.texture;
            for (let Ee = 0, Oe = me.length; Ee < Oe; Ee++) {
                const Je = me[Ee]
                  , le = i.get(Je);
                t.bindTexture(s.TEXTURE_2D, le.__webglTexture),
                Q(s.TEXTURE_2D, Je, be),
                ve(X.__webglFramebuffer, L, Je, s.COLOR_ATTACHMENT0 + Ee, s.TEXTURE_2D, 0),
                M(Je, be) && y(s.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let me = s.TEXTURE_2D;
            if ((L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) && (a ? me = L.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(me, ue.__webglTexture),
            Q(me, R, be),
            a && R.mipmaps && R.mipmaps.length > 0)
                for (let Ee = 0; Ee < R.mipmaps.length; Ee++)
                    ve(X.__webglFramebuffer[Ee], L, R, s.COLOR_ATTACHMENT0, me, Ee);
            else
                ve(X.__webglFramebuffer, L, R, s.COLOR_ATTACHMENT0, me, 0);
            M(R, be) && y(me),
            t.unbindTexture()
        }
        L.depthBuffer && Ve(L)
    }
    function Qe(L) {
        const R = p(L) || a
          , X = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
        for (let ue = 0, ce = X.length; ue < ce; ue++) {
            const pe = X[ue];
            if (M(pe, R)) {
                const be = L.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D
                  , me = i.get(pe).__webglTexture;
                t.bindTexture(be, me),
                y(be),
                t.unbindTexture()
            }
        }
    }
    function Re(L) {
        if (a && L.samples > 0 && Pe(L) === !1) {
            const R = L.isWebGLMultipleRenderTargets ? L.texture : [L.texture]
              , X = L.width
              , ue = L.height;
            let ce = s.COLOR_BUFFER_BIT;
            const pe = []
              , be = L.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
              , me = i.get(L)
              , Ee = L.isWebGLMultipleRenderTargets === !0;
            if (Ee)
                for (let Oe = 0; Oe < R.length; Oe++)
                    t.bindFramebuffer(s.FRAMEBUFFER, me.__webglMultisampledFramebuffer),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Oe, s.RENDERBUFFER, null),
                    t.bindFramebuffer(s.FRAMEBUFFER, me.__webglFramebuffer),
                    s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Oe, s.TEXTURE_2D, null, 0);
            t.bindFramebuffer(s.READ_FRAMEBUFFER, me.__webglMultisampledFramebuffer),
            t.bindFramebuffer(s.DRAW_FRAMEBUFFER, me.__webglFramebuffer);
            for (let Oe = 0; Oe < R.length; Oe++) {
                pe.push(s.COLOR_ATTACHMENT0 + Oe),
                L.depthBuffer && pe.push(be);
                const Je = me.__ignoreDepthValues !== void 0 ? me.__ignoreDepthValues : !1;
                if (Je === !1 && (L.depthBuffer && (ce |= s.DEPTH_BUFFER_BIT),
                L.stencilBuffer && (ce |= s.STENCIL_BUFFER_BIT)),
                Ee && s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, me.__webglColorRenderbuffer[Oe]),
                Je === !0 && (s.invalidateFramebuffer(s.READ_FRAMEBUFFER, [be]),
                s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [be])),
                Ee) {
                    const le = i.get(R[Oe]).__webglTexture;
                    s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, le, 0)
                }
                s.blitFramebuffer(0, 0, X, ue, 0, 0, X, ue, ce, s.NEAREST),
                c && s.invalidateFramebuffer(s.READ_FRAMEBUFFER, pe)
            }
            if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null),
            t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
            Ee)
                for (let Oe = 0; Oe < R.length; Oe++) {
                    t.bindFramebuffer(s.FRAMEBUFFER, me.__webglMultisampledFramebuffer),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Oe, s.RENDERBUFFER, me.__webglColorRenderbuffer[Oe]);
                    const Je = i.get(R[Oe]).__webglTexture;
                    t.bindFramebuffer(s.FRAMEBUFFER, me.__webglFramebuffer),
                    s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Oe, s.TEXTURE_2D, Je, 0)
                }
            t.bindFramebuffer(s.DRAW_FRAMEBUFFER, me.__webglMultisampledFramebuffer)
        }
    }
    function ze(L) {
        return Math.min(n.maxSamples, L.samples)
    }
    function Pe(L) {
        const R = i.get(L);
        return a && L.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && R.__useRenderToTexture !== !1
    }
    function Z(L) {
        const R = o.render.frame;
        h.get(L) !== R && (h.set(L, R),
        L.update())
    }
    function Ye(L, R) {
        const X = L.colorSpace
          , ue = L.format
          , ce = L.type;
        return L.isCompressedTexture === !0 || L.isVideoTexture === !0 || L.format === nf || X !== Er && X !== xn && (wt.getTransfer(X) === It ? a === !1 ? e.has("EXT_sRGB") === !0 && ue === On ? (L.format = nf,
        L.minFilter = Hi,
        L.generateMipmaps = !1) : R = Mx.sRGBToLinear(R) : (ue !== On || ce !== os) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", X)),
        R
    }
    this.allocateTextureUnit = O,
    this.resetTextureUnits = te,
    this.setTexture2D = V,
    this.setTexture2DArray = Y,
    this.setTexture3D = K,
    this.setTextureCube = J,
    this.rebindTextures = Ke,
    this.setupRenderTarget = $,
    this.updateRenderTargetMipmap = Qe,
    this.updateMultisampleRenderTarget = Re,
    this.setupDepthRenderbuffer = Ve,
    this.setupFrameBufferTexture = ve,
    this.useMultisampledRTT = Pe
}
function tC(s, e, t) {
    const i = t.isWebGL2;
    function n(r, o=xn) {
        let a;
        const l = wt.getTransfer(o);
        if (r === os)
            return s.UNSIGNED_BYTE;
        if (r === ex)
            return s.UNSIGNED_SHORT_4_4_4_4;
        if (r === tx)
            return s.UNSIGNED_SHORT_5_5_5_1;
        if (r === UM)
            return s.BYTE;
        if (r === NM)
            return s.SHORT;
        if (r === Gf)
            return s.UNSIGNED_SHORT;
        if (r === Q0)
            return s.INT;
        if (r === Kr)
            return s.UNSIGNED_INT;
        if (r === Jr)
            return s.FLOAT;
        if (r === yl)
            return i ? s.HALF_FLOAT : (a = e.get("OES_texture_half_float"),
            a !== null ? a.HALF_FLOAT_OES : null);
        if (r === FM)
            return s.ALPHA;
        if (r === On)
            return s.RGBA;
        if (r === OM)
            return s.LUMINANCE;
        if (r === BM)
            return s.LUMINANCE_ALPHA;
        if (r === Ys)
            return s.DEPTH_COMPONENT;
        if (r === pa)
            return s.DEPTH_STENCIL;
        if (r === nf)
            return a = e.get("EXT_sRGB"),
            a !== null ? a.SRGB_ALPHA_EXT : null;
        if (r === zM)
            return s.RED;
        if (r === ix)
            return s.RED_INTEGER;
        if (r === kM)
            return s.RG;
        if (r === nx)
            return s.RG_INTEGER;
        if (r === rx)
            return s.RGBA_INTEGER;
        if (r === du || r === fu || r === pu || r === mu)
            if (l === It)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                a !== null) {
                    if (r === du)
                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (r === fu)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (r === pu)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (r === mu)
                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (a = e.get("WEBGL_compressed_texture_s3tc"),
            a !== null) {
                if (r === du)
                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (r === fu)
                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (r === pu)
                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (r === mu)
                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (r === nm || r === rm || r === sm || r === om)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"),
            a !== null) {
                if (r === nm)
                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (r === rm)
                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (r === sm)
                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (r === om)
                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (r === sx)
            return a = e.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (r === am || r === lm)
            if (a = e.get("WEBGL_compressed_texture_etc"),
            a !== null) {
                if (r === am)
                    return l === It ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (r === lm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (r === cm || r === hm || r === um || r === dm || r === fm || r === pm || r === mm || r === gm || r === _m || r === xm || r === ym || r === vm || r === Mm || r === Sm)
            if (a = e.get("WEBGL_compressed_texture_astc"),
            a !== null) {
                if (r === cm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (r === hm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (r === um)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (r === dm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (r === fm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (r === pm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (r === mm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (r === gm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (r === _m)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (r === xm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (r === ym)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (r === vm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (r === Mm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (r === Sm)
                    return l === It ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (r === gu || r === bm || r === Tm)
            if (a = e.get("EXT_texture_compression_bptc"),
            a !== null) {
                if (r === gu)
                    return l === It ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (r === bm)
                    return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (r === Tm)
                    return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (r === HM || r === Em || r === wm || r === Am)
            if (a = e.get("EXT_texture_compression_rgtc"),
            a !== null) {
                if (r === gu)
                    return a.COMPRESSED_RED_RGTC1_EXT;
                if (r === Em)
                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (r === wm)
                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (r === Am)
                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return r === qs ? i ? s.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"),
        a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : s[r] !== void 0 ? s[r] : null
    }
    return {
        convert: n
    }
}
class iC extends Nn {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class Yc extends Ar {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const nC = {
    type: "move"
};
class xd {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Yc,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Yc,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new ne,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new ne),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Yc,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new ne,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new ne),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let n = null
          , r = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const _ of e.hand.values()) {
                    const p = t.getJointPose(_, i)
                      , g = this._getHandJoint(c, _);
                    p !== null && (g.matrix.fromArray(p.transform.matrix),
                    g.matrix.decompose(g.position, g.rotation, g.scale),
                    g.matrixWorldNeedsUpdate = !0,
                    g.jointRadius = p.radius),
                    g.visible = p !== null
                }
                const h = c.joints["index-finger-tip"]
                  , u = c.joints["thumb-tip"]
                  , d = h.position.distanceTo(u.position)
                  , f = .02
                  , m = .005;
                c.inputState.pinching && d > f + m ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && d <= f - m && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, i),
                r !== null && (l.matrix.fromArray(r.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                r.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1,
                r.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (n = t.getPose(e.targetRaySpace, i),
            n === null && r !== null && (n = r),
            n !== null && (a.matrix.fromArray(n.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            n.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(n.linearVelocity)) : a.hasLinearVelocity = !1,
            n.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(n.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(nC)))
        }
        return a !== null && (a.visible = n !== null),
        l !== null && (l.visible = r !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new Yc;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
class rC extends ya {
    constructor(e, t) {
        super();
        const i = this;
        let n = null
          , r = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , h = null
          , u = null
          , d = null
          , f = null
          , m = null;
        const _ = t.getContextAttributes();
        let p = null
          , g = null;
        const M = []
          , y = []
          , S = new Rt;
        let C = null;
        const w = new Nn;
        w.layers.enable(1),
        w.viewport = new pi;
        const T = new Nn;
        T.layers.enable(2),
        T.viewport = new pi;
        const B = [w, T]
          , b = new iC;
        b.layers.enable(1),
        b.layers.enable(2);
        let E = null
          , G = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(Q) {
            let re = M[Q];
            return re === void 0 && (re = new xd,
            M[Q] = re),
            re.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(Q) {
            let re = M[Q];
            return re === void 0 && (re = new xd,
            M[Q] = re),
            re.getGripSpace()
        }
        ,
        this.getHand = function(Q) {
            let re = M[Q];
            return re === void 0 && (re = new xd,
            M[Q] = re),
            re.getHandSpace()
        }
        ;
        function k(Q) {
            const re = y.indexOf(Q.inputSource);
            if (re === -1)
                return;
            const ge = M[re];
            ge !== void 0 && (ge.update(Q.inputSource, Q.frame, c || o),
            ge.dispatchEvent({
                type: Q.type,
                data: Q.inputSource
            }))
        }
        function te() {
            n.removeEventListener("select", k),
            n.removeEventListener("selectstart", k),
            n.removeEventListener("selectend", k),
            n.removeEventListener("squeeze", k),
            n.removeEventListener("squeezestart", k),
            n.removeEventListener("squeezeend", k),
            n.removeEventListener("end", te),
            n.removeEventListener("inputsourceschange", O);
            for (let Q = 0; Q < M.length; Q++) {
                const re = y[Q];
                re !== null && (y[Q] = null,
                M[Q].disconnect(re))
            }
            E = null,
            G = null,
            e.setRenderTarget(p),
            f = null,
            d = null,
            u = null,
            n = null,
            g = null,
            de.stop(),
            i.isPresenting = !1,
            e.setPixelRatio(C),
            e.setSize(S.width, S.height, !1),
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(Q) {
            r = Q,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(Q) {
            a = Q,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(Q) {
            c = Q
        }
        ,
        this.getBaseLayer = function() {
            return d !== null ? d : f
        }
        ,
        this.getBinding = function() {
            return u
        }
        ,
        this.getFrame = function() {
            return m
        }
        ,
        this.getSession = function() {
            return n
        }
        ,
        this.setSession = async function(Q) {
            if (n = Q,
            n !== null) {
                if (p = e.getRenderTarget(),
                n.addEventListener("select", k),
                n.addEventListener("selectstart", k),
                n.addEventListener("selectend", k),
                n.addEventListener("squeeze", k),
                n.addEventListener("squeezestart", k),
                n.addEventListener("squeezeend", k),
                n.addEventListener("end", te),
                n.addEventListener("inputsourceschange", O),
                _.xrCompatible !== !0 && await t.makeXRCompatible(),
                C = e.getPixelRatio(),
                e.getSize(S),
                n.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const re = {
                        antialias: n.renderState.layers === void 0 ? _.antialias : !0,
                        alpha: !0,
                        depth: _.depth,
                        stencil: _.stencil,
                        framebufferScaleFactor: r
                    };
                    f = new XRWebGLLayer(n,t,re),
                    n.updateRenderState({
                        baseLayer: f
                    }),
                    e.setPixelRatio(1),
                    e.setSize(f.framebufferWidth, f.framebufferHeight, !1),
                    g = new no(f.framebufferWidth,f.framebufferHeight,{
                        format: On,
                        type: os,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: _.stencil
                    })
                } else {
                    let re = null
                      , ge = null
                      , fe = null;
                    _.depth && (fe = _.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    re = _.stencil ? pa : Ys,
                    ge = _.stencil ? qs : Kr);
                    const ve = {
                        colorFormat: t.RGBA8,
                        depthFormat: fe,
                        scaleFactor: r
                    };
                    u = new XRWebGLBinding(n,t),
                    d = u.createProjectionLayer(ve),
                    n.updateRenderState({
                        layers: [d]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(d.textureWidth, d.textureHeight, !1),
                    g = new no(d.textureWidth,d.textureHeight,{
                        format: On,
                        type: os,
                        depthTexture: new Qx(d.textureWidth,d.textureHeight,ge,void 0,void 0,void 0,void 0,void 0,void 0,re),
                        stencilBuffer: _.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: _.antialias ? 4 : 0
                    });
                    const Ue = e.properties.get(g);
                    Ue.__ignoreDepthValues = d.ignoreDepthValues
                }
                g.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await n.requestReferenceSpace(a),
                de.setContext(n),
                de.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (n !== null)
                return n.environmentBlendMode
        }
        ;
        function O(Q) {
            for (let re = 0; re < Q.removed.length; re++) {
                const ge = Q.removed[re]
                  , fe = y.indexOf(ge);
                fe >= 0 && (y[fe] = null,
                M[fe].disconnect(ge))
            }
            for (let re = 0; re < Q.added.length; re++) {
                const ge = Q.added[re];
                let fe = y.indexOf(ge);
                if (fe === -1) {
                    for (let Ue = 0; Ue < M.length; Ue++)
                        if (Ue >= y.length) {
                            y.push(ge),
                            fe = Ue;
                            break
                        } else if (y[Ue] === null) {
                            y[Ue] = ge,
                            fe = Ue;
                            break
                        }
                    if (fe === -1)
                        break
                }
                const ve = M[fe];
                ve && ve.connect(ge)
            }
        }
        const H = new ne
          , V = new ne;
        function Y(Q, re, ge) {
            H.setFromMatrixPosition(re.matrixWorld),
            V.setFromMatrixPosition(ge.matrixWorld);
            const fe = H.distanceTo(V)
              , ve = re.projectionMatrix.elements
              , Ue = ge.projectionMatrix.elements
              , ke = ve[14] / (ve[10] - 1)
              , Ve = ve[14] / (ve[10] + 1)
              , Ke = (ve[9] + 1) / ve[5]
              , $ = (ve[9] - 1) / ve[5]
              , Qe = (ve[8] - 1) / ve[0]
              , Re = (Ue[8] + 1) / Ue[0]
              , ze = ke * Qe
              , Pe = ke * Re
              , Z = fe / (-Qe + Re)
              , Ye = Z * -Qe;
            re.matrixWorld.decompose(Q.position, Q.quaternion, Q.scale),
            Q.translateX(Ye),
            Q.translateZ(Z),
            Q.matrixWorld.compose(Q.position, Q.quaternion, Q.scale),
            Q.matrixWorldInverse.copy(Q.matrixWorld).invert();
            const L = ke + Z
              , R = Ve + Z
              , X = ze - Ye
              , ue = Pe + (fe - Ye)
              , ce = Ke * Ve / R * L
              , pe = $ * Ve / R * L;
            Q.projectionMatrix.makePerspective(X, ue, ce, pe, L, R),
            Q.projectionMatrixInverse.copy(Q.projectionMatrix).invert()
        }
        function K(Q, re) {
            re === null ? Q.matrixWorld.copy(Q.matrix) : Q.matrixWorld.multiplyMatrices(re.matrixWorld, Q.matrix),
            Q.matrixWorldInverse.copy(Q.matrixWorld).invert()
        }
        this.updateCamera = function(Q) {
            if (n === null)
                return;
            b.near = T.near = w.near = Q.near,
            b.far = T.far = w.far = Q.far,
            (E !== b.near || G !== b.far) && (n.updateRenderState({
                depthNear: b.near,
                depthFar: b.far
            }),
            E = b.near,
            G = b.far);
            const re = Q.parent
              , ge = b.cameras;
            K(b, re);
            for (let fe = 0; fe < ge.length; fe++)
                K(ge[fe], re);
            ge.length === 2 ? Y(b, w, T) : b.projectionMatrix.copy(w.projectionMatrix),
            J(Q, b, re)
        }
        ;
        function J(Q, re, ge) {
            ge === null ? Q.matrix.copy(re.matrixWorld) : (Q.matrix.copy(ge.matrixWorld),
            Q.matrix.invert(),
            Q.matrix.multiply(re.matrixWorld)),
            Q.matrix.decompose(Q.position, Q.quaternion, Q.scale),
            Q.updateMatrixWorld(!0),
            Q.projectionMatrix.copy(re.projectionMatrix),
            Q.projectionMatrixInverse.copy(re.projectionMatrixInverse),
            Q.isPerspectiveCamera && (Q.fov = $d * 2 * Math.atan(1 / Q.projectionMatrix.elements[5]),
            Q.zoom = 1)
        }
        this.getCamera = function() {
            return b
        }
        ,
        this.getFoveation = function() {
            if (!(d === null && f === null))
                return l
        }
        ,
        this.setFoveation = function(Q) {
            l = Q,
            d !== null && (d.fixedFoveation = Q),
            f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = Q)
        }
        ;
        let D = null;
        function se(Q, re) {
            if (h = re.getViewerPose(c || o),
            m = re,
            h !== null) {
                const ge = h.views;
                f !== null && (e.setRenderTargetFramebuffer(g, f.framebuffer),
                e.setRenderTarget(g));
                let fe = !1;
                ge.length !== b.cameras.length && (b.cameras.length = 0,
                fe = !0);
                for (let ve = 0; ve < ge.length; ve++) {
                    const Ue = ge[ve];
                    let ke = null;
                    if (f !== null)
                        ke = f.getViewport(Ue);
                    else {
                        const Ke = u.getViewSubImage(d, Ue);
                        ke = Ke.viewport,
                        ve === 0 && (e.setRenderTargetTextures(g, Ke.colorTexture, d.ignoreDepthValues ? void 0 : Ke.depthStencilTexture),
                        e.setRenderTarget(g))
                    }
                    let Ve = B[ve];
                    Ve === void 0 && (Ve = new Nn,
                    Ve.layers.enable(ve),
                    Ve.viewport = new pi,
                    B[ve] = Ve),
                    Ve.matrix.fromArray(Ue.transform.matrix),
                    Ve.matrix.decompose(Ve.position, Ve.quaternion, Ve.scale),
                    Ve.projectionMatrix.fromArray(Ue.projectionMatrix),
                    Ve.projectionMatrixInverse.copy(Ve.projectionMatrix).invert(),
                    Ve.viewport.set(ke.x, ke.y, ke.width, ke.height),
                    ve === 0 && (b.matrix.copy(Ve.matrix),
                    b.matrix.decompose(b.position, b.quaternion, b.scale)),
                    fe === !0 && b.cameras.push(Ve)
                }
            }
            for (let ge = 0; ge < M.length; ge++) {
                const fe = y[ge]
                  , ve = M[ge];
                fe !== null && ve !== void 0 && ve.update(fe, re, c || o)
            }
            D && D(Q, re),
            re.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: re
            }),
            m = null
        }
        const de = new $x;
        de.setAnimationLoop(se),
        this.setAnimationLoop = function(Q) {
            D = Q
        }
        ,
        this.dispose = function() {}
    }
}
function sC(s, e) {
    function t(p, g) {
        p.matrixAutoUpdate === !0 && p.updateMatrix(),
        g.value.copy(p.matrix)
    }
    function i(p, g) {
        g.color.getRGB(p.fogColor.value, xx(s)),
        g.isFog ? (p.fogNear.value = g.near,
        p.fogFar.value = g.far) : g.isFogExp2 && (p.fogDensity.value = g.density)
    }
    function n(p, g, M, y, S) {
        g.isMeshBasicMaterial || g.isMeshLambertMaterial ? r(p, g) : g.isMeshToonMaterial ? (r(p, g),
        u(p, g)) : g.isMeshPhongMaterial ? (r(p, g),
        h(p, g)) : g.isMeshStandardMaterial ? (r(p, g),
        d(p, g),
        g.isMeshPhysicalMaterial && f(p, g, S)) : g.isMeshMatcapMaterial ? (r(p, g),
        m(p, g)) : g.isMeshDepthMaterial ? r(p, g) : g.isMeshDistanceMaterial ? (r(p, g),
        _(p, g)) : g.isMeshNormalMaterial ? r(p, g) : g.isLineBasicMaterial ? (o(p, g),
        g.isLineDashedMaterial && a(p, g)) : g.isPointsMaterial ? l(p, g, M, y) : g.isSpriteMaterial ? c(p, g) : g.isShadowMaterial ? (p.color.value.copy(g.color),
        p.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1)
    }
    function r(p, g) {
        p.opacity.value = g.opacity,
        g.color && p.diffuse.value.copy(g.color),
        g.emissive && p.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
        g.map && (p.map.value = g.map,
        t(g.map, p.mapTransform)),
        g.alphaMap && (p.alphaMap.value = g.alphaMap,
        t(g.alphaMap, p.alphaMapTransform)),
        g.bumpMap && (p.bumpMap.value = g.bumpMap,
        t(g.bumpMap, p.bumpMapTransform),
        p.bumpScale.value = g.bumpScale,
        g.side === Yi && (p.bumpScale.value *= -1)),
        g.normalMap && (p.normalMap.value = g.normalMap,
        t(g.normalMap, p.normalMapTransform),
        p.normalScale.value.copy(g.normalScale),
        g.side === Yi && p.normalScale.value.negate()),
        g.displacementMap && (p.displacementMap.value = g.displacementMap,
        t(g.displacementMap, p.displacementMapTransform),
        p.displacementScale.value = g.displacementScale,
        p.displacementBias.value = g.displacementBias),
        g.emissiveMap && (p.emissiveMap.value = g.emissiveMap,
        t(g.emissiveMap, p.emissiveMapTransform)),
        g.specularMap && (p.specularMap.value = g.specularMap,
        t(g.specularMap, p.specularMapTransform)),
        g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest);
        const M = e.get(g).envMap;
        if (M && (p.envMap.value = M,
        p.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1,
        p.reflectivity.value = g.reflectivity,
        p.ior.value = g.ior,
        p.refractionRatio.value = g.refractionRatio),
        g.lightMap) {
            p.lightMap.value = g.lightMap;
            const y = s._useLegacyLights === !0 ? Math.PI : 1;
            p.lightMapIntensity.value = g.lightMapIntensity * y,
            t(g.lightMap, p.lightMapTransform)
        }
        g.aoMap && (p.aoMap.value = g.aoMap,
        p.aoMapIntensity.value = g.aoMapIntensity,
        t(g.aoMap, p.aoMapTransform))
    }
    function o(p, g) {
        p.diffuse.value.copy(g.color),
        p.opacity.value = g.opacity,
        g.map && (p.map.value = g.map,
        t(g.map, p.mapTransform))
    }
    function a(p, g) {
        p.dashSize.value = g.dashSize,
        p.totalSize.value = g.dashSize + g.gapSize,
        p.scale.value = g.scale
    }
    function l(p, g, M, y) {
        p.diffuse.value.copy(g.color),
        p.opacity.value = g.opacity,
        p.size.value = g.size * M,
        p.scale.value = y * .5,
        g.map && (p.map.value = g.map,
        t(g.map, p.uvTransform)),
        g.alphaMap && (p.alphaMap.value = g.alphaMap,
        t(g.alphaMap, p.alphaMapTransform)),
        g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest)
    }
    function c(p, g) {
        p.diffuse.value.copy(g.color),
        p.opacity.value = g.opacity,
        p.rotation.value = g.rotation,
        g.map && (p.map.value = g.map,
        t(g.map, p.mapTransform)),
        g.alphaMap && (p.alphaMap.value = g.alphaMap,
        t(g.alphaMap, p.alphaMapTransform)),
        g.alphaTest > 0 && (p.alphaTest.value = g.alphaTest)
    }
    function h(p, g) {
        p.specular.value.copy(g.specular),
        p.shininess.value = Math.max(g.shininess, 1e-4)
    }
    function u(p, g) {
        g.gradientMap && (p.gradientMap.value = g.gradientMap)
    }
    function d(p, g) {
        p.metalness.value = g.metalness,
        g.metalnessMap && (p.metalnessMap.value = g.metalnessMap,
        t(g.metalnessMap, p.metalnessMapTransform)),
        p.roughness.value = g.roughness,
        g.roughnessMap && (p.roughnessMap.value = g.roughnessMap,
        t(g.roughnessMap, p.roughnessMapTransform)),
        e.get(g).envMap && (p.envMapIntensity.value = g.envMapIntensity)
    }
    function f(p, g, M) {
        p.ior.value = g.ior,
        g.sheen > 0 && (p.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        p.sheenRoughness.value = g.sheenRoughness,
        g.sheenColorMap && (p.sheenColorMap.value = g.sheenColorMap,
        t(g.sheenColorMap, p.sheenColorMapTransform)),
        g.sheenRoughnessMap && (p.sheenRoughnessMap.value = g.sheenRoughnessMap,
        t(g.sheenRoughnessMap, p.sheenRoughnessMapTransform))),
        g.clearcoat > 0 && (p.clearcoat.value = g.clearcoat,
        p.clearcoatRoughness.value = g.clearcoatRoughness,
        g.clearcoatMap && (p.clearcoatMap.value = g.clearcoatMap,
        t(g.clearcoatMap, p.clearcoatMapTransform)),
        g.clearcoatRoughnessMap && (p.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap,
        t(g.clearcoatRoughnessMap, p.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap && (p.clearcoatNormalMap.value = g.clearcoatNormalMap,
        t(g.clearcoatNormalMap, p.clearcoatNormalMapTransform),
        p.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
        g.side === Yi && p.clearcoatNormalScale.value.negate())),
        g.iridescence > 0 && (p.iridescence.value = g.iridescence,
        p.iridescenceIOR.value = g.iridescenceIOR,
        p.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0],
        p.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1],
        g.iridescenceMap && (p.iridescenceMap.value = g.iridescenceMap,
        t(g.iridescenceMap, p.iridescenceMapTransform)),
        g.iridescenceThicknessMap && (p.iridescenceThicknessMap.value = g.iridescenceThicknessMap,
        t(g.iridescenceThicknessMap, p.iridescenceThicknessMapTransform))),
        g.transmission > 0 && (p.transmission.value = g.transmission,
        p.transmissionSamplerMap.value = M.texture,
        p.transmissionSamplerSize.value.set(M.width, M.height),
        g.transmissionMap && (p.transmissionMap.value = g.transmissionMap,
        t(g.transmissionMap, p.transmissionMapTransform)),
        p.thickness.value = g.thickness,
        g.thicknessMap && (p.thicknessMap.value = g.thicknessMap,
        t(g.thicknessMap, p.thicknessMapTransform)),
        p.attenuationDistance.value = g.attenuationDistance,
        p.attenuationColor.value.copy(g.attenuationColor)),
        g.anisotropy > 0 && (p.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)),
        g.anisotropyMap && (p.anisotropyMap.value = g.anisotropyMap,
        t(g.anisotropyMap, p.anisotropyMapTransform))),
        p.specularIntensity.value = g.specularIntensity,
        p.specularColor.value.copy(g.specularColor),
        g.specularColorMap && (p.specularColorMap.value = g.specularColorMap,
        t(g.specularColorMap, p.specularColorMapTransform)),
        g.specularIntensityMap && (p.specularIntensityMap.value = g.specularIntensityMap,
        t(g.specularIntensityMap, p.specularIntensityMapTransform))
    }
    function m(p, g) {
        g.matcap && (p.matcap.value = g.matcap)
    }
    function _(p, g) {
        const M = e.get(g).light;
        p.referencePosition.value.setFromMatrixPosition(M.matrixWorld),
        p.nearDistance.value = M.shadow.camera.near,
        p.farDistance.value = M.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: n
    }
}
function oC(s, e, t, i) {
    let n = {}
      , r = {}
      , o = [];
    const a = t.isWebGL2 ? s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function l(M, y) {
        const S = y.program;
        i.uniformBlockBinding(M, S)
    }
    function c(M, y) {
        let S = n[M.id];
        S === void 0 && (m(M),
        S = h(M),
        n[M.id] = S,
        M.addEventListener("dispose", p));
        const C = y.program;
        i.updateUBOMapping(M, C);
        const w = e.render.frame;
        r[M.id] !== w && (d(M),
        r[M.id] = w)
    }
    function h(M) {
        const y = u();
        M.__bindingPointIndex = y;
        const S = s.createBuffer()
          , C = M.__size
          , w = M.usage;
        return s.bindBuffer(s.UNIFORM_BUFFER, S),
        s.bufferData(s.UNIFORM_BUFFER, C, w),
        s.bindBuffer(s.UNIFORM_BUFFER, null),
        s.bindBufferBase(s.UNIFORM_BUFFER, y, S),
        S
    }
    function u() {
        for (let M = 0; M < a; M++)
            if (o.indexOf(M) === -1)
                return o.push(M),
                M;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function d(M) {
        const y = n[M.id]
          , S = M.uniforms
          , C = M.__cache;
        s.bindBuffer(s.UNIFORM_BUFFER, y);
        for (let w = 0, T = S.length; w < T; w++) {
            const B = Array.isArray(S[w]) ? S[w] : [S[w]];
            for (let b = 0, E = B.length; b < E; b++) {
                const G = B[b];
                if (f(G, w, b, C) === !0) {
                    const k = G.__offset
                      , te = Array.isArray(G.value) ? G.value : [G.value];
                    let O = 0;
                    for (let H = 0; H < te.length; H++) {
                        const V = te[H]
                          , Y = _(V);
                        typeof V == "number" || typeof V == "boolean" ? (G.__data[0] = V,
                        s.bufferSubData(s.UNIFORM_BUFFER, k + O, G.__data)) : V.isMatrix3 ? (G.__data[0] = V.elements[0],
                        G.__data[1] = V.elements[1],
                        G.__data[2] = V.elements[2],
                        G.__data[3] = 0,
                        G.__data[4] = V.elements[3],
                        G.__data[5] = V.elements[4],
                        G.__data[6] = V.elements[5],
                        G.__data[7] = 0,
                        G.__data[8] = V.elements[6],
                        G.__data[9] = V.elements[7],
                        G.__data[10] = V.elements[8],
                        G.__data[11] = 0) : (V.toArray(G.__data, O),
                        O += Y.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    s.bufferSubData(s.UNIFORM_BUFFER, k, G.__data)
                }
            }
        }
        s.bindBuffer(s.UNIFORM_BUFFER, null)
    }
    function f(M, y, S, C) {
        const w = M.value
          , T = y + "_" + S;
        if (C[T] === void 0)
            return typeof w == "number" || typeof w == "boolean" ? C[T] = w : C[T] = w.clone(),
            !0;
        {
            const B = C[T];
            if (typeof w == "number" || typeof w == "boolean") {
                if (B !== w)
                    return C[T] = w,
                    !0
            } else if (B.equals(w) === !1)
                return B.copy(w),
                !0
        }
        return !1
    }
    function m(M) {
        const y = M.uniforms;
        let S = 0;
        const C = 16;
        for (let T = 0, B = y.length; T < B; T++) {
            const b = Array.isArray(y[T]) ? y[T] : [y[T]];
            for (let E = 0, G = b.length; E < G; E++) {
                const k = b[E]
                  , te = Array.isArray(k.value) ? k.value : [k.value];
                for (let O = 0, H = te.length; O < H; O++) {
                    const V = te[O]
                      , Y = _(V)
                      , K = S % C;
                    K !== 0 && C - K < Y.boundary && (S += C - K),
                    k.__data = new Float32Array(Y.storage / Float32Array.BYTES_PER_ELEMENT),
                    k.__offset = S,
                    S += Y.storage
                }
            }
        }
        const w = S % C;
        return w > 0 && (S += C - w),
        M.__size = S,
        M.__cache = {},
        this
    }
    function _(M) {
        const y = {
            boundary: 0,
            storage: 0
        };
        return typeof M == "number" || typeof M == "boolean" ? (y.boundary = 4,
        y.storage = 4) : M.isVector2 ? (y.boundary = 8,
        y.storage = 8) : M.isVector3 || M.isColor ? (y.boundary = 16,
        y.storage = 12) : M.isVector4 ? (y.boundary = 16,
        y.storage = 16) : M.isMatrix3 ? (y.boundary = 48,
        y.storage = 48) : M.isMatrix4 ? (y.boundary = 64,
        y.storage = 64) : M.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", M),
        y
    }
    function p(M) {
        const y = M.target;
        y.removeEventListener("dispose", p);
        const S = o.indexOf(y.__bindingPointIndex);
        o.splice(S, 1),
        s.deleteBuffer(n[y.id]),
        delete n[y.id],
        delete r[y.id]
    }
    function g() {
        for (const M in n)
            s.deleteBuffer(n[M]);
        o = [],
        n = {},
        r = {}
    }
    return {
        bind: l,
        update: c,
        dispose: g
    }
}
class aC {
    constructor(e={}) {
        const {canvas: t=lS(), context: i=null, depth: n=!0, stencil: r=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: h="default", failIfMajorPerformanceCaveat: u=!1} = e;
        this.isWebGLRenderer = !0;
        let d;
        i !== null ? d = i.getContextAttributes().alpha : d = o;
        const f = new Uint32Array(4)
          , m = new Int32Array(4);
        let _ = null
          , p = null;
        const g = []
          , M = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = ui,
        this._useLegacyLights = !1,
        this.toneMapping = ss,
        this.toneMappingExposure = 1;
        const y = this;
        let S = !1
          , C = 0
          , w = 0
          , T = null
          , B = -1
          , b = null;
        const E = new pi
          , G = new pi;
        let k = null;
        const te = new At(0);
        let O = 0
          , H = t.width
          , V = t.height
          , Y = 1
          , K = null
          , J = null;
        const D = new pi(0,0,H,V)
          , se = new pi(0,0,H,V);
        let de = !1;
        const Q = new Yx;
        let re = !1
          , ge = !1
          , fe = null;
        const ve = new $i
          , Ue = new Rt
          , ke = new ne
          , Ve = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function Ke() {
            return T === null ? Y : 1
        }
        let $ = i;
        function Qe(x, P) {
            for (let I = 0; I < x.length; I++) {
                const U = x[I]
                  , N = t.getContext(U, P);
                if (N !== null)
                    return N
            }
            return null
        }
        try {
            const x = {
                alpha: !0,
                depth: n,
                stencil: r,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: h,
                failIfMajorPerformanceCaveat: u
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${Jv}`),
            t.addEventListener("webglcontextlost", j, !1),
            t.addEventListener("webglcontextrestored", z, !1),
            t.addEventListener("webglcontextcreationerror", _e, !1),
            $ === null) {
                const P = ["webgl2", "webgl", "experimental-webgl"];
                if (y.isWebGL1Renderer === !0 && P.shift(),
                $ = Qe(P, x),
                $ === null)
                    throw Qe(P) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            typeof WebGLRenderingContext < "u" && $ instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
            $.getShaderPrecisionFormat === void 0 && ($.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (x) {
            throw console.error("THREE.WebGLRenderer: " + x.message),
            x
        }
        let Re, ze, Pe, Z, Ye, L, R, X, ue, ce, pe, be, me, Ee, Oe, Je, le, lt, Ze, We, Ce, Le, $e, et;
        function st() {
            Re = new mA($),
            ze = new oA($,Re,e),
            Re.init(ze),
            Le = new tC($,Re,ze),
            Pe = new QR($,Re,ze),
            Z = new xA($),
            Ye = new zR,
            L = new eC($,Re,Pe,Ye,ze,Le,Z),
            R = new uA(y),
            X = new pA(y),
            ue = new bT($,ze),
            $e = new rA($,Re,ue,ze),
            ce = new gA($,ue,Z,$e),
            pe = new SA($,ce,ue,Z),
            Ze = new MA($,ze,L),
            Je = new aA(Ye),
            be = new BR(y,R,X,Re,ze,$e,Je),
            me = new sC(y,Ye),
            Ee = new HR,
            Oe = new YR(Re,ze),
            lt = new nA(y,R,X,Pe,pe,d,l),
            le = new JR(y,pe,ze),
            et = new oC($,Z,ze,Pe),
            We = new sA($,Re,Z,ze),
            Ce = new _A($,Re,Z,ze),
            Z.programs = be.programs,
            y.capabilities = ze,
            y.extensions = Re,
            y.properties = Ye,
            y.renderLists = Ee,
            y.shadowMap = le,
            y.state = Pe,
            y.info = Z
        }
        st();
        const we = new rC(y,$);
        this.xr = we,
        this.getContext = function() {
            return $
        }
        ,
        this.getContextAttributes = function() {
            return $.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const x = Re.get("WEBGL_lose_context");
            x && x.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const x = Re.get("WEBGL_lose_context");
            x && x.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return Y
        }
        ,
        this.setPixelRatio = function(x) {
            x !== void 0 && (Y = x,
            this.setSize(H, V, !1))
        }
        ,
        this.getSize = function(x) {
            return x.set(H, V)
        }
        ,
        this.setSize = function(x, P, I=!0) {
            if (we.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            H = x,
            V = P,
            t.width = Math.floor(x * Y),
            t.height = Math.floor(P * Y),
            I === !0 && (t.style.width = x + "px",
            t.style.height = P + "px"),
            this.setViewport(0, 0, x, P)
        }
        ,
        this.getDrawingBufferSize = function(x) {
            return x.set(H * Y, V * Y).floor()
        }
        ,
        this.setDrawingBufferSize = function(x, P, I) {
            H = x,
            V = P,
            Y = I,
            t.width = Math.floor(x * I),
            t.height = Math.floor(P * I),
            this.setViewport(0, 0, x, P)
        }
        ,
        this.getCurrentViewport = function(x) {
            return x.copy(E)
        }
        ,
        this.getViewport = function(x) {
            return x.copy(D)
        }
        ,
        this.setViewport = function(x, P, I, U) {
            x.isVector4 ? D.set(x.x, x.y, x.z, x.w) : D.set(x, P, I, U),
            Pe.viewport(E.copy(D).multiplyScalar(Y).floor())
        }
        ,
        this.getScissor = function(x) {
            return x.copy(se)
        }
        ,
        this.setScissor = function(x, P, I, U) {
            x.isVector4 ? se.set(x.x, x.y, x.z, x.w) : se.set(x, P, I, U),
            Pe.scissor(G.copy(se).multiplyScalar(Y).floor())
        }
        ,
        this.getScissorTest = function() {
            return de
        }
        ,
        this.setScissorTest = function(x) {
            Pe.setScissorTest(de = x)
        }
        ,
        this.setOpaqueSort = function(x) {
            K = x
        }
        ,
        this.setTransparentSort = function(x) {
            J = x
        }
        ,
        this.getClearColor = function(x) {
            return x.copy(lt.getClearColor())
        }
        ,
        this.setClearColor = function() {
            lt.setClearColor.apply(lt, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return lt.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            lt.setClearAlpha.apply(lt, arguments)
        }
        ,
        this.clear = function(x=!0, P=!0, I=!0) {
            let U = 0;
            if (x) {
                let N = !1;
                if (T !== null) {
                    const W = T.texture.format;
                    N = W === rx || W === nx || W === ix
                }
                if (N) {
                    const W = T.texture.type
                      , q = W === os || W === Kr || W === Gf || W === qs || W === ex || W === tx
                      , ie = lt.getClearColor()
                      , oe = lt.getClearAlpha()
                      , ae = ie.r
                      , he = ie.g
                      , ye = ie.b;
                    q ? (f[0] = ae,
                    f[1] = he,
                    f[2] = ye,
                    f[3] = oe,
                    $.clearBufferuiv($.COLOR, 0, f)) : (m[0] = ae,
                    m[1] = he,
                    m[2] = ye,
                    m[3] = oe,
                    $.clearBufferiv($.COLOR, 0, m))
                } else
                    U |= $.COLOR_BUFFER_BIT
            }
            P && (U |= $.DEPTH_BUFFER_BIT),
            I && (U |= $.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            $.clear(U)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", j, !1),
            t.removeEventListener("webglcontextrestored", z, !1),
            t.removeEventListener("webglcontextcreationerror", _e, !1),
            Ee.dispose(),
            Oe.dispose(),
            Ye.dispose(),
            R.dispose(),
            X.dispose(),
            pe.dispose(),
            $e.dispose(),
            et.dispose(),
            be.dispose(),
            we.dispose(),
            we.removeEventListener("sessionstart", nt),
            we.removeEventListener("sessionend", rt),
            fe && (fe.dispose(),
            fe = null),
            Me.stop()
        }
        ;
        function j(x) {
            x.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            S = !0
        }
        function z() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            S = !1;
            const x = Z.autoReset
              , P = le.enabled
              , I = le.autoUpdate
              , U = le.needsUpdate
              , N = le.type;
            st(),
            Z.autoReset = x,
            le.enabled = P,
            le.autoUpdate = I,
            le.needsUpdate = U,
            le.type = N
        }
        function _e(x) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", x.statusMessage)
        }
        function xe(x) {
            const P = x.target;
            P.removeEventListener("dispose", xe),
            Xe(P)
        }
        function Xe(x) {
            He(x),
            Ye.remove(x)
        }
        function He(x) {
            const P = Ye.get(x).programs;
            P !== void 0 && (P.forEach(function(I) {
                be.releaseProgram(I)
            }),
            x.isShaderMaterial && be.releaseShaderCache(x))
        }
        this.renderBufferDirect = function(x, P, I, U, N, W) {
            P === null && (P = Ve);
            const q = N.isMesh && N.matrixWorld.determinant() < 0
              , ie = v(x, P, I, U, N);
            Pe.setMaterial(U, q);
            let oe = I.index
              , ae = 1;
            if (U.wireframe === !0) {
                if (oe = ce.getWireframeAttribute(I),
                oe === void 0)
                    return;
                ae = 2
            }
            const he = I.drawRange
              , ye = I.attributes.position;
            let Se = he.start * ae
              , Ae = (he.start + he.count) * ae;
            W !== null && (Se = Math.max(Se, W.start * ae),
            Ae = Math.min(Ae, (W.start + W.count) * ae)),
            oe !== null ? (Se = Math.max(Se, 0),
            Ae = Math.min(Ae, oe.count)) : ye != null && (Se = Math.max(Se, 0),
            Ae = Math.min(Ae, ye.count));
            const Ne = Ae - Se;
            if (Ne < 0 || Ne === 1 / 0)
                return;
            $e.setup(N, U, ie, I, oe);
            let dt, it = We;
            if (oe !== null && (dt = ue.get(oe),
            it = Ce,
            it.setIndex(dt)),
            N.isMesh)
                U.wireframe === !0 ? (Pe.setLineWidth(U.wireframeLinewidth * Ke()),
                it.setMode($.LINES)) : it.setMode($.TRIANGLES);
            else if (N.isLine) {
                let Ge = U.linewidth;
                Ge === void 0 && (Ge = 1),
                Pe.setLineWidth(Ge * Ke()),
                N.isLineSegments ? it.setMode($.LINES) : N.isLineLoop ? it.setMode($.LINE_LOOP) : it.setMode($.LINE_STRIP)
            } else
                N.isPoints ? it.setMode($.POINTS) : N.isSprite && it.setMode($.TRIANGLES);
            if (N.isBatchedMesh)
                it.renderMultiDraw(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount);
            else if (N.isInstancedMesh)
                it.renderInstances(Se, Ne, N.count);
            else if (I.isInstancedBufferGeometry) {
                const Ge = I._maxInstanceCount !== void 0 ? I._maxInstanceCount : 1 / 0
                  , bt = Math.min(I.instanceCount, Ge);
                it.renderInstances(Se, Ne, bt)
            } else
                it.render(Se, Ne)
        }
        ;
        function ut(x, P, I) {
            x.transparent === !0 && x.side === gr && x.forceSinglePass === !1 ? (x.side = Yi,
            x.needsUpdate = !0,
            Be(x, P, I),
            x.side = us,
            x.needsUpdate = !0,
            Be(x, P, I),
            x.side = gr) : Be(x, P, I)
        }
        this.compile = function(x, P, I=null) {
            I === null && (I = x),
            p = Oe.get(I),
            p.init(),
            M.push(p),
            I.traverseVisible(function(N) {
                N.isLight && N.layers.test(P.layers) && (p.pushLight(N),
                N.castShadow && p.pushShadow(N))
            }),
            x !== I && x.traverseVisible(function(N) {
                N.isLight && N.layers.test(P.layers) && (p.pushLight(N),
                N.castShadow && p.pushShadow(N))
            }),
            p.setupLights(y._useLegacyLights);
            const U = new Set;
            return x.traverse(function(N) {
                const W = N.material;
                if (W)
                    if (Array.isArray(W))
                        for (let q = 0; q < W.length; q++) {
                            const ie = W[q];
                            ut(ie, I, N),
                            U.add(ie)
                        }
                    else
                        ut(W, I, N),
                        U.add(W)
            }),
            M.pop(),
            p = null,
            U
        }
        ,
        this.compileAsync = function(x, P, I=null) {
            const U = this.compile(x, P, I);
            return new Promise(N => {
                function W() {
                    if (U.forEach(function(q) {
                        Ye.get(q).currentProgram.isReady() && U.delete(q)
                    }),
                    U.size === 0) {
                        N(x);
                        return
                    }
                    setTimeout(W, 10)
                }
                Re.get("KHR_parallel_shader_compile") !== null ? W() : setTimeout(W, 10)
            }
            )
        }
        ;
        let Ie = null;
        function De(x) {
            Ie && Ie(x)
        }
        function nt() {
            Me.stop()
        }
        function rt() {
            Me.start()
        }
        const Me = new $x;
        Me.setAnimationLoop(De),
        typeof self < "u" && Me.setContext(self),
        this.setAnimationLoop = function(x) {
            Ie = x,
            we.setAnimationLoop(x),
            x === null ? Me.stop() : Me.start()
        }
        ,
        we.addEventListener("sessionstart", nt),
        we.addEventListener("sessionend", rt),
        this.render = function(x, P) {
            if (P !== void 0 && P.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (S === !0)
                return;
            x.matrixWorldAutoUpdate === !0 && x.updateMatrixWorld(),
            P.parent === null && P.matrixWorldAutoUpdate === !0 && P.updateMatrixWorld(),
            we.enabled === !0 && we.isPresenting === !0 && (we.cameraAutoUpdate === !0 && we.updateCamera(P),
            P = we.getCamera()),
            x.isScene === !0 && x.onBeforeRender(y, x, P, T),
            p = Oe.get(x, M.length),
            p.init(),
            M.push(p),
            ve.multiplyMatrices(P.projectionMatrix, P.matrixWorldInverse),
            Q.setFromProjectionMatrix(ve),
            ge = this.localClippingEnabled,
            re = Je.init(this.clippingPlanes, ge),
            _ = Ee.get(x, g.length),
            _.init(),
            g.push(_),
            tt(x, P, 0, y.sortObjects),
            _.finish(),
            y.sortObjects === !0 && _.sort(K, J),
            this.info.render.frame++,
            re === !0 && Je.beginShadows();
            const I = p.state.shadowsArray;
            if (le.render(I, x, P),
            re === !0 && Je.endShadows(),
            this.info.autoReset === !0 && this.info.reset(),
            lt.render(_, x),
            p.setupLights(y._useLegacyLights),
            P.isArrayCamera) {
                const U = P.cameras;
                for (let N = 0, W = U.length; N < W; N++) {
                    const q = U[N];
                    je(_, x, q, q.viewport)
                }
            } else
                je(_, x, P);
            T !== null && (L.updateMultisampleRenderTarget(T),
            L.updateRenderTargetMipmap(T)),
            x.isScene === !0 && x.onAfterRender(y, x, P),
            $e.resetDefaultState(),
            B = -1,
            b = null,
            M.pop(),
            M.length > 0 ? p = M[M.length - 1] : p = null,
            g.pop(),
            g.length > 0 ? _ = g[g.length - 1] : _ = null
        }
        ;
        function tt(x, P, I, U) {
            if (x.visible === !1)
                return;
            if (x.layers.test(P.layers)) {
                if (x.isGroup)
                    I = x.renderOrder;
                else if (x.isLOD)
                    x.autoUpdate === !0 && x.update(P);
                else if (x.isLight)
                    p.pushLight(x),
                    x.castShadow && p.pushShadow(x);
                else if (x.isSprite) {
                    if (!x.frustumCulled || Q.intersectsSprite(x)) {
                        U && ke.setFromMatrixPosition(x.matrixWorld).applyMatrix4(ve);
                        const q = pe.update(x)
                          , ie = x.material;
                        ie.visible && _.push(x, q, ie, I, ke.z, null)
                    }
                } else if ((x.isMesh || x.isLine || x.isPoints) && (!x.frustumCulled || Q.intersectsObject(x))) {
                    const q = pe.update(x)
                      , ie = x.material;
                    if (U && (x.boundingSphere !== void 0 ? (x.boundingSphere === null && x.computeBoundingSphere(),
                    ke.copy(x.boundingSphere.center)) : (q.boundingSphere === null && q.computeBoundingSphere(),
                    ke.copy(q.boundingSphere.center)),
                    ke.applyMatrix4(x.matrixWorld).applyMatrix4(ve)),
                    Array.isArray(ie)) {
                        const oe = q.groups;
                        for (let ae = 0, he = oe.length; ae < he; ae++) {
                            const ye = oe[ae]
                              , Se = ie[ye.materialIndex];
                            Se && Se.visible && _.push(x, q, Se, I, ke.z, ye)
                        }
                    } else
                        ie.visible && _.push(x, q, ie, I, ke.z, null)
                }
            }
            const W = x.children;
            for (let q = 0, ie = W.length; q < ie; q++)
                tt(W[q], P, I, U)
        }
        function je(x, P, I, U) {
            const N = x.opaque
              , W = x.transmissive
              , q = x.transparent;
            p.setupLightsView(I),
            re === !0 && Je.setGlobalState(y.clippingPlanes, I),
            W.length > 0 && ct(N, W, P, I),
            U && Pe.viewport(E.copy(U)),
            N.length > 0 && St(N, P, I),
            W.length > 0 && St(W, P, I),
            q.length > 0 && St(q, P, I),
            Pe.buffers.depth.setTest(!0),
            Pe.buffers.depth.setMask(!0),
            Pe.buffers.color.setMask(!0),
            Pe.setPolygonOffset(!1)
        }
        function ct(x, P, I, U) {
            if ((I.isScene === !0 ? I.overrideMaterial : null) !== null)
                return;
            const W = ze.isWebGL2;
            fe === null && (fe = new no(1,1,{
                generateMipmaps: !0,
                type: Re.has("EXT_color_buffer_half_float") ? yl : os,
                minFilter: xl,
                samples: W ? 4 : 0
            })),
            y.getDrawingBufferSize(Ue),
            W ? fe.setSize(Ue.x, Ue.y) : fe.setSize(jd(Ue.x), jd(Ue.y));
            const q = y.getRenderTarget();
            y.setRenderTarget(fe),
            y.getClearColor(te),
            O = y.getClearAlpha(),
            O < 1 && y.setClearColor(16777215, .5),
            y.clear();
            const ie = y.toneMapping;
            y.toneMapping = ss,
            St(x, I, U),
            L.updateMultisampleRenderTarget(fe),
            L.updateRenderTargetMipmap(fe);
            let oe = !1;
            for (let ae = 0, he = P.length; ae < he; ae++) {
                const ye = P[ae]
                  , Se = ye.object
                  , Ae = ye.geometry
                  , Ne = ye.material
                  , dt = ye.group;
                if (Ne.side === gr && Se.layers.test(U.layers)) {
                    const it = Ne.side;
                    Ne.side = Yi,
                    Ne.needsUpdate = !0,
                    at(Se, I, U, Ae, Ne, dt),
                    Ne.side = it,
                    Ne.needsUpdate = !0,
                    oe = !0
                }
            }
            oe === !0 && (L.updateMultisampleRenderTarget(fe),
            L.updateRenderTargetMipmap(fe)),
            y.setRenderTarget(q),
            y.setClearColor(te, O),
            y.toneMapping = ie
        }
        function St(x, P, I) {
            const U = P.isScene === !0 ? P.overrideMaterial : null;
            for (let N = 0, W = x.length; N < W; N++) {
                const q = x[N]
                  , ie = q.object
                  , oe = q.geometry
                  , ae = U === null ? q.material : U
                  , he = q.group;
                ie.layers.test(I.layers) && at(ie, P, I, oe, ae, he)
            }
        }
        function at(x, P, I, U, N, W) {
            x.onBeforeRender(y, P, I, U, N, W),
            x.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, x.matrixWorld),
            x.normalMatrix.getNormalMatrix(x.modelViewMatrix),
            N.onBeforeRender(y, P, I, U, x, W),
            N.transparent === !0 && N.side === gr && N.forceSinglePass === !1 ? (N.side = Yi,
            N.needsUpdate = !0,
            y.renderBufferDirect(I, P, U, N, x, W),
            N.side = us,
            N.needsUpdate = !0,
            y.renderBufferDirect(I, P, U, N, x, W),
            N.side = gr) : y.renderBufferDirect(I, P, U, N, x, W),
            x.onAfterRender(y, P, I, U, N, W)
        }
        function Be(x, P, I) {
            P.isScene !== !0 && (P = Ve);
            const U = Ye.get(x)
              , N = p.state.lights
              , W = p.state.shadowsArray
              , q = N.state.version
              , ie = be.getParameters(x, N.state, W, P, I)
              , oe = be.getProgramCacheKey(ie);
            let ae = U.programs;
            U.environment = x.isMeshStandardMaterial ? P.environment : null,
            U.fog = P.fog,
            U.envMap = (x.isMeshStandardMaterial ? X : R).get(x.envMap || U.environment),
            ae === void 0 && (x.addEventListener("dispose", xe),
            ae = new Map,
            U.programs = ae);
            let he = ae.get(oe);
            if (he !== void 0) {
                if (U.currentProgram === he && U.lightsStateVersion === q)
                    return Ft(x, ie),
                    he
            } else
                ie.uniforms = be.getUniforms(x),
                x.onBuild(I, ie, y),
                x.onBeforeCompile(ie, y),
                he = be.acquireProgram(ie, oe),
                ae.set(oe, he),
                U.uniforms = ie.uniforms;
            const ye = U.uniforms;
            return (!x.isShaderMaterial && !x.isRawShaderMaterial || x.clipping === !0) && (ye.clippingPlanes = Je.uniform),
            Ft(x, ie),
            U.needsLights = F(x),
            U.lightsStateVersion = q,
            U.needsLights && (ye.ambientLightColor.value = N.state.ambient,
            ye.lightProbe.value = N.state.probe,
            ye.directionalLights.value = N.state.directional,
            ye.directionalLightShadows.value = N.state.directionalShadow,
            ye.spotLights.value = N.state.spot,
            ye.spotLightShadows.value = N.state.spotShadow,
            ye.rectAreaLights.value = N.state.rectArea,
            ye.ltc_1.value = N.state.rectAreaLTC1,
            ye.ltc_2.value = N.state.rectAreaLTC2,
            ye.pointLights.value = N.state.point,
            ye.pointLightShadows.value = N.state.pointShadow,
            ye.hemisphereLights.value = N.state.hemi,
            ye.directionalShadowMap.value = N.state.directionalShadowMap,
            ye.directionalShadowMatrix.value = N.state.directionalShadowMatrix,
            ye.spotShadowMap.value = N.state.spotShadowMap,
            ye.spotLightMatrix.value = N.state.spotLightMatrix,
            ye.spotLightMap.value = N.state.spotLightMap,
            ye.pointShadowMap.value = N.state.pointShadowMap,
            ye.pointShadowMatrix.value = N.state.pointShadowMatrix),
            U.currentProgram = he,
            U.uniformsList = null,
            he
        }
        function Vt(x) {
            if (x.uniformsList === null) {
                const P = x.currentProgram.getUniforms();
                x.uniformsList = lh.seqWithValue(P.seq, x.uniforms)
            }
            return x.uniformsList
        }
        function Ft(x, P) {
            const I = Ye.get(x);
            I.outputColorSpace = P.outputColorSpace,
            I.batching = P.batching,
            I.instancing = P.instancing,
            I.instancingColor = P.instancingColor,
            I.skinning = P.skinning,
            I.morphTargets = P.morphTargets,
            I.morphNormals = P.morphNormals,
            I.morphColors = P.morphColors,
            I.morphTargetsCount = P.morphTargetsCount,
            I.numClippingPlanes = P.numClippingPlanes,
            I.numIntersection = P.numClipIntersection,
            I.vertexAlphas = P.vertexAlphas,
            I.vertexTangents = P.vertexTangents,
            I.toneMapping = P.toneMapping
        }
        function v(x, P, I, U, N) {
            P.isScene !== !0 && (P = Ve),
            L.resetTextureUnits();
            const W = P.fog
              , q = U.isMeshStandardMaterial ? P.environment : null
              , ie = T === null ? y.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : Er
              , oe = (U.isMeshStandardMaterial ? X : R).get(U.envMap || q)
              , ae = U.vertexColors === !0 && !!I.attributes.color && I.attributes.color.itemSize === 4
              , he = !!I.attributes.tangent && (!!U.normalMap || U.anisotropy > 0)
              , ye = !!I.morphAttributes.position
              , Se = !!I.morphAttributes.normal
              , Ae = !!I.morphAttributes.color;
            let Ne = ss;
            U.toneMapped && (T === null || T.isXRRenderTarget === !0) && (Ne = y.toneMapping);
            const dt = I.morphAttributes.position || I.morphAttributes.normal || I.morphAttributes.color
              , it = dt !== void 0 ? dt.length : 0
              , Ge = Ye.get(U)
              , bt = p.state.lights;
            if (re === !0 && (ge === !0 || x !== b)) {
                const Ot = x === b && U.id === B;
                Je.setState(U, x, Ot)
            }
            let qe = !1;
            U.version === Ge.__version ? (Ge.needsLights && Ge.lightsStateVersion !== bt.state.version || Ge.outputColorSpace !== ie || N.isBatchedMesh && Ge.batching === !1 || !N.isBatchedMesh && Ge.batching === !0 || N.isInstancedMesh && Ge.instancing === !1 || !N.isInstancedMesh && Ge.instancing === !0 || N.isSkinnedMesh && Ge.skinning === !1 || !N.isSkinnedMesh && Ge.skinning === !0 || N.isInstancedMesh && Ge.instancingColor === !0 && N.instanceColor === null || N.isInstancedMesh && Ge.instancingColor === !1 && N.instanceColor !== null || Ge.envMap !== oe || U.fog === !0 && Ge.fog !== W || Ge.numClippingPlanes !== void 0 && (Ge.numClippingPlanes !== Je.numPlanes || Ge.numIntersection !== Je.numIntersection) || Ge.vertexAlphas !== ae || Ge.vertexTangents !== he || Ge.morphTargets !== ye || Ge.morphNormals !== Se || Ge.morphColors !== Ae || Ge.toneMapping !== Ne || ze.isWebGL2 === !0 && Ge.morphTargetsCount !== it) && (qe = !0) : (qe = !0,
            Ge.__version = U.version);
            let Ct = Ge.currentProgram;
            qe === !0 && (Ct = Be(U, P, N));
            let bi = !1
              , Nt = !1
              , Mt = !1;
            const ot = Ct.getUniforms()
              , hi = Ge.uniforms;
            if (Pe.useProgram(Ct.program) && (bi = !0,
            Nt = !0,
            Mt = !0),
            U.id !== B && (B = U.id,
            Nt = !0),
            bi || b !== x) {
                ot.setValue($, "projectionMatrix", x.projectionMatrix),
                ot.setValue($, "viewMatrix", x.matrixWorldInverse);
                const Ot = ot.map.cameraPosition;
                Ot !== void 0 && Ot.setValue($, ke.setFromMatrixPosition(x.matrixWorld)),
                ze.logarithmicDepthBuffer && ot.setValue($, "logDepthBufFC", 2 / (Math.log(x.far + 1) / Math.LN2)),
                (U.isMeshPhongMaterial || U.isMeshToonMaterial || U.isMeshLambertMaterial || U.isMeshBasicMaterial || U.isMeshStandardMaterial || U.isShaderMaterial) && ot.setValue($, "isOrthographic", x.isOrthographicCamera === !0),
                b !== x && (b = x,
                Nt = !0,
                Mt = !0)
            }
            if (N.isSkinnedMesh) {
                ot.setOptional($, N, "bindMatrix"),
                ot.setOptional($, N, "bindMatrixInverse");
                const Ot = N.skeleton;
                Ot && (ze.floatVertexTextures ? (Ot.boneTexture === null && Ot.computeBoneTexture(),
                ot.setValue($, "boneTexture", Ot.boneTexture, L)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            N.isBatchedMesh && (ot.setOptional($, N, "batchingTexture"),
            ot.setValue($, "batchingTexture", N._matricesTexture, L));
            const er = I.morphAttributes;
            if ((er.position !== void 0 || er.normal !== void 0 || er.color !== void 0 && ze.isWebGL2 === !0) && Ze.update(N, I, Ct),
            (Nt || Ge.receiveShadow !== N.receiveShadow) && (Ge.receiveShadow = N.receiveShadow,
            ot.setValue($, "receiveShadow", N.receiveShadow)),
            U.isMeshGouraudMaterial && U.envMap !== null && (hi.envMap.value = oe,
            hi.flipEnvMap.value = oe.isCubeTexture && oe.isRenderTargetTexture === !1 ? -1 : 1),
            Nt && (ot.setValue($, "toneMappingExposure", y.toneMappingExposure),
            Ge.needsLights && A(hi, Mt),
            W && U.fog === !0 && me.refreshFogUniforms(hi, W),
            me.refreshMaterialUniforms(hi, U, Y, V, fe),
            lh.upload($, Vt(Ge), hi, L)),
            U.isShaderMaterial && U.uniformsNeedUpdate === !0 && (lh.upload($, Vt(Ge), hi, L),
            U.uniformsNeedUpdate = !1),
            U.isSpriteMaterial && ot.setValue($, "center", N.center),
            ot.setValue($, "modelViewMatrix", N.modelViewMatrix),
            ot.setValue($, "normalMatrix", N.normalMatrix),
            ot.setValue($, "modelMatrix", N.matrixWorld),
            U.isShaderMaterial || U.isRawShaderMaterial) {
                const Ot = U.uniformsGroups;
                for (let Lr = 0, oy = Ot.length; Lr < oy; Lr++)
                    if (ze.isWebGL2) {
                        const ap = Ot[Lr];
                        et.update(ap, Ct),
                        et.bind(ap, Ct)
                    } else
                        console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return Ct
        }
        function A(x, P) {
            x.ambientLightColor.needsUpdate = P,
            x.lightProbe.needsUpdate = P,
            x.directionalLights.needsUpdate = P,
            x.directionalLightShadows.needsUpdate = P,
            x.pointLights.needsUpdate = P,
            x.pointLightShadows.needsUpdate = P,
            x.spotLights.needsUpdate = P,
            x.spotLightShadows.needsUpdate = P,
            x.rectAreaLights.needsUpdate = P,
            x.hemisphereLights.needsUpdate = P
        }
        function F(x) {
            return x.isMeshLambertMaterial || x.isMeshToonMaterial || x.isMeshPhongMaterial || x.isMeshStandardMaterial || x.isShadowMaterial || x.isShaderMaterial && x.lights === !0
        }
        this.getActiveCubeFace = function() {
            return C
        }
        ,
        this.getActiveMipmapLevel = function() {
            return w
        }
        ,
        this.getRenderTarget = function() {
            return T
        }
        ,
        this.setRenderTargetTextures = function(x, P, I) {
            Ye.get(x.texture).__webglTexture = P,
            Ye.get(x.depthTexture).__webglTexture = I;
            const U = Ye.get(x);
            U.__hasExternalTextures = !0,
            U.__hasExternalTextures && (U.__autoAllocateDepthBuffer = I === void 0,
            U.__autoAllocateDepthBuffer || Re.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            U.__useRenderToTexture = !1))
        }
        ,
        this.setRenderTargetFramebuffer = function(x, P) {
            const I = Ye.get(x);
            I.__webglFramebuffer = P,
            I.__useDefaultFramebuffer = P === void 0
        }
        ,
        this.setRenderTarget = function(x, P=0, I=0) {
            T = x,
            C = P,
            w = I;
            let U = !0
              , N = null
              , W = !1
              , q = !1;
            if (x) {
                const oe = Ye.get(x);
                oe.__useDefaultFramebuffer !== void 0 ? (Pe.bindFramebuffer($.FRAMEBUFFER, null),
                U = !1) : oe.__webglFramebuffer === void 0 ? L.setupRenderTarget(x) : oe.__hasExternalTextures && L.rebindTextures(x, Ye.get(x.texture).__webglTexture, Ye.get(x.depthTexture).__webglTexture);
                const ae = x.texture;
                (ae.isData3DTexture || ae.isDataArrayTexture || ae.isCompressedArrayTexture) && (q = !0);
                const he = Ye.get(x).__webglFramebuffer;
                x.isWebGLCubeRenderTarget ? (Array.isArray(he[P]) ? N = he[P][I] : N = he[P],
                W = !0) : ze.isWebGL2 && x.samples > 0 && L.useMultisampledRTT(x) === !1 ? N = Ye.get(x).__webglMultisampledFramebuffer : Array.isArray(he) ? N = he[I] : N = he,
                E.copy(x.viewport),
                G.copy(x.scissor),
                k = x.scissorTest
            } else
                E.copy(D).multiplyScalar(Y).floor(),
                G.copy(se).multiplyScalar(Y).floor(),
                k = de;
            if (Pe.bindFramebuffer($.FRAMEBUFFER, N) && ze.drawBuffers && U && Pe.drawBuffers(x, N),
            Pe.viewport(E),
            Pe.scissor(G),
            Pe.setScissorTest(k),
            W) {
                const oe = Ye.get(x.texture);
                $.framebufferTexture2D($.FRAMEBUFFER, $.COLOR_ATTACHMENT0, $.TEXTURE_CUBE_MAP_POSITIVE_X + P, oe.__webglTexture, I)
            } else if (q) {
                const oe = Ye.get(x.texture)
                  , ae = P || 0;
                $.framebufferTextureLayer($.FRAMEBUFFER, $.COLOR_ATTACHMENT0, oe.__webglTexture, I || 0, ae)
            }
            B = -1
        }
        ,
        this.readRenderTargetPixels = function(x, P, I, U, N, W, q) {
            if (!(x && x.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let ie = Ye.get(x).__webglFramebuffer;
            if (x.isWebGLCubeRenderTarget && q !== void 0 && (ie = ie[q]),
            ie) {
                Pe.bindFramebuffer($.FRAMEBUFFER, ie);
                try {
                    const oe = x.texture
                      , ae = oe.format
                      , he = oe.type;
                    if (ae !== On && Le.convert(ae) !== $.getParameter($.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    const ye = he === yl && (Re.has("EXT_color_buffer_half_float") || ze.isWebGL2 && Re.has("EXT_color_buffer_float"));
                    if (he !== os && Le.convert(he) !== $.getParameter($.IMPLEMENTATION_COLOR_READ_TYPE) && !(he === Jr && (ze.isWebGL2 || Re.has("OES_texture_float") || Re.has("WEBGL_color_buffer_float"))) && !ye) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    P >= 0 && P <= x.width - U && I >= 0 && I <= x.height - N && $.readPixels(P, I, U, N, Le.convert(ae), Le.convert(he), W)
                } finally {
                    const oe = T !== null ? Ye.get(T).__webglFramebuffer : null;
                    Pe.bindFramebuffer($.FRAMEBUFFER, oe)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(x, P, I=0) {
            const U = Math.pow(2, -I)
              , N = Math.floor(P.image.width * U)
              , W = Math.floor(P.image.height * U);
            L.setTexture2D(P, 0),
            $.copyTexSubImage2D($.TEXTURE_2D, I, 0, 0, x.x, x.y, N, W),
            Pe.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(x, P, I, U=0) {
            const N = P.image.width
              , W = P.image.height
              , q = Le.convert(I.format)
              , ie = Le.convert(I.type);
            L.setTexture2D(I, 0),
            $.pixelStorei($.UNPACK_FLIP_Y_WEBGL, I.flipY),
            $.pixelStorei($.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha),
            $.pixelStorei($.UNPACK_ALIGNMENT, I.unpackAlignment),
            P.isDataTexture ? $.texSubImage2D($.TEXTURE_2D, U, x.x, x.y, N, W, q, ie, P.image.data) : P.isCompressedTexture ? $.compressedTexSubImage2D($.TEXTURE_2D, U, x.x, x.y, P.mipmaps[0].width, P.mipmaps[0].height, q, P.mipmaps[0].data) : $.texSubImage2D($.TEXTURE_2D, U, x.x, x.y, q, ie, P.image),
            U === 0 && I.generateMipmaps && $.generateMipmap($.TEXTURE_2D),
            Pe.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(x, P, I, U, N=0) {
            if (y.isWebGL1Renderer) {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                return
            }
            const W = x.max.x - x.min.x + 1
              , q = x.max.y - x.min.y + 1
              , ie = x.max.z - x.min.z + 1
              , oe = Le.convert(U.format)
              , ae = Le.convert(U.type);
            let he;
            if (U.isData3DTexture)
                L.setTexture3D(U, 0),
                he = $.TEXTURE_3D;
            else if (U.isDataArrayTexture || U.isCompressedArrayTexture)
                L.setTexture2DArray(U, 0),
                he = $.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            $.pixelStorei($.UNPACK_FLIP_Y_WEBGL, U.flipY),
            $.pixelStorei($.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha),
            $.pixelStorei($.UNPACK_ALIGNMENT, U.unpackAlignment);
            const ye = $.getParameter($.UNPACK_ROW_LENGTH)
              , Se = $.getParameter($.UNPACK_IMAGE_HEIGHT)
              , Ae = $.getParameter($.UNPACK_SKIP_PIXELS)
              , Ne = $.getParameter($.UNPACK_SKIP_ROWS)
              , dt = $.getParameter($.UNPACK_SKIP_IMAGES)
              , it = I.isCompressedTexture ? I.mipmaps[N] : I.image;
            $.pixelStorei($.UNPACK_ROW_LENGTH, it.width),
            $.pixelStorei($.UNPACK_IMAGE_HEIGHT, it.height),
            $.pixelStorei($.UNPACK_SKIP_PIXELS, x.min.x),
            $.pixelStorei($.UNPACK_SKIP_ROWS, x.min.y),
            $.pixelStorei($.UNPACK_SKIP_IMAGES, x.min.z),
            I.isDataTexture || I.isData3DTexture ? $.texSubImage3D(he, N, P.x, P.y, P.z, W, q, ie, oe, ae, it.data) : I.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
            $.compressedTexSubImage3D(he, N, P.x, P.y, P.z, W, q, ie, oe, it.data)) : $.texSubImage3D(he, N, P.x, P.y, P.z, W, q, ie, oe, ae, it),
            $.pixelStorei($.UNPACK_ROW_LENGTH, ye),
            $.pixelStorei($.UNPACK_IMAGE_HEIGHT, Se),
            $.pixelStorei($.UNPACK_SKIP_PIXELS, Ae),
            $.pixelStorei($.UNPACK_SKIP_ROWS, Ne),
            $.pixelStorei($.UNPACK_SKIP_IMAGES, dt),
            N === 0 && U.generateMipmaps && $.generateMipmap(he),
            Pe.unbindTexture()
        }
        ,
        this.initTexture = function(x) {
            x.isCubeTexture ? L.setTextureCube(x, 0) : x.isData3DTexture ? L.setTexture3D(x, 0) : x.isDataArrayTexture || x.isCompressedArrayTexture ? L.setTexture2DArray(x, 0) : L.setTexture2D(x, 0),
            Pe.unbindTexture()
        }
        ,
        this.resetState = function() {
            C = 0,
            w = 0,
            T = null,
            Pe.reset(),
            $e.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return vr
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === Vf ? "display-p3" : "srgb",
        t.unpackColorSpace = wt.workingColorSpace === Uh ? "display-p3" : "srgb"
    }
    get outputEncoding() {
        return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace === ui ? $s : ox
    }
    set outputEncoding(e) {
        console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
        this.outputColorSpace = e === $s ? ui : Er
    }
    get useLegacyLights() {
        return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights
    }
    set useLegacyLights(e) {
        console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
        this._useLegacyLights = e
    }
}
class lC {
    constructor({el: e}) {
        this.renderer = null,
        this.setupRenderer(e)
    }
    setupRenderer = e => {
        this.renderer || (this.renderer = new aC({
            canvas: e,
            alpha: !0
        })),
        this.renderer.setPixelRatio(window.devicePixelRatio),
        this.renderer.setSize(Di.viewSize.width, Di.viewSize.height)
    }
    ;
    offscreenRender = ({renderTarget: e, scene: t, camera: i}) => {
        this.renderer.setRenderTarget(e),
        this.renderer.clear(this.renderer.autoClearColor, this.renderer.autoClearDepth, this.renderer.autoClearStencil),
        this.renderer.render(t, i),
        this.renderer.setRenderTarget(null)
    }
    ;
    render = ({scene: e, camera: t}) => {
        this.renderer.render(e, t)
    }
    ;
    resize = () => {
        this.setupRenderer()
    }
}
class cC extends Kx {
    constructor() {
        super(),
        this.setSize()
    }
    setSize = () => {
        const e = Di.viewSize.height
          , t = Di.viewSize.width / Di.viewSize.height
          , [i,n] = [e * t / 2, e / 2];
        this.left = -i,
        this.right = i,
        this.top = n,
        this.bottom = -n,
        this.position.set(0, 0, 2),
        this.updateProjectionMatrix()
    }
}
class hC extends zn {
    constructor(e, t, i, n, r, o, a, l, c) {
        super(e, t, i, n, r, o, a, l, c),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class uC {
    constructor() {
        this.canvas = document.createElement("canvas"),
        this.dpr = window.devicePixelRatio,
        this.setSize(),
        this.ctx = this.canvas.getContext("2d"),
        this.texture = new hC(this.canvas),
        this.texture.minFilter = Hi,
        this.texture.magFilter = Hi,
        this.texture.generateMipmaps = !1,
        this.currentTime = 0
    }
    setSize = () => {
        this.canvas.width = Di.viewSize.width * this.dpr,
        this.canvas.height = Di.viewSize.height * this.dpr
    }
    ;
    update = ({time: e}) => {
        const i = Math.floor(e * 7);
        if (i === this.currentTime)
            return;
        this.currentTime = i,
        this.texture.needsUpdate = !0,
        this.ctx.fillStyle = "black",
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        const n = _l.random(1, 3);
        for (let r = 0; r < n; r++) {
            const o = this.canvas.width * Math.random()
              , a = this.canvas.height * Math.random()
              , l = this.canvas.width * Math.random() * .4
              , c = this.canvas.height * Math.random() * .14
              , h = 255 * Math.random()
              , u = 255 * Math.random();
            this.ctx.fillStyle = `rgb(${h}, ${u}, 0)`,
            this.ctx.fillRect(o - l * .5, a - c * .5, l, c)
        }
    }
    ;
    resize = () => {
        this.setSize()
    }
}
const dC = `precision mediump float;

//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+10.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

//  Function from Iigo Quiles
//  https://www.shadertoy.com/view/MsS3Wc
vec3 hsb2rgb( in vec3 c ){
    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                             6.0)-3.0)-1.0,
                     0.0,
                     1.0 );
    rgb = rgb*rgb*(3.0-2.0*rgb);
    return c.z * mix(vec3(1.0), rgb, c.y);
}

uniform float uTime;
uniform vec2 uResolution;
uniform float uSeed;

varying vec2 vUv;

void main() {
  float aspect = uResolution.x / uResolution.y;

  // canvasoruv
  vec2 normalizeUvScale = vec2(min(aspect, 1.0), min(1.0 / aspect, 1.0));
  vec2 uv = (vUv - 0.5) * normalizeUvScale + 0.5;


  // 
  float scaleRatio = 2.0;
  uv = (uv - 0.5) / scaleRatio + 0.5; // 

  // noise uv
  vec2 noisedUv = uv + snoise(uv * 1.5 + uSeed) * 0.8;

  // hsb
  float noiseColor = snoise(noisedUv) * 3.0;
  float saturation = 0.12;
  vec3 color = hsb2rgb(vec3(fract(uTime + noiseColor), saturation, 1.0));

  // 
  float noiseMetalic = snoise(noisedUv * 7.0 + uTime) * 0.3;
  color += noiseMetalic;

  // 
  color -= 0.07;

  gl_FragColor = vec4(color, 1.0);
}`;
class x_ {
    constructor({width: e, height: t, seed: i}) {
        const n = new Ll(e,t)
          , r = new wr({
            uniforms: {
                uTime: {
                    value: 0
                },
                uResolution: {
                    value: new Rt(e,t)
                },
                uSeed: {
                    value: i
                }
            },
            vertexShader: vx,
            fragmentShader: dC,
            depthTest: !1,
            depthWrite: !1
        });
        this.mesh = new Yn(n,r),
        this.mesh.renderOrder = -1,
        this.resize()
    }
    update = ({time: e}) => {
        this.mesh.material.uniforms.uTime.value = e
    }
    ;
    resize = () => {}
}
class fC {
    constructor({canvasWrapper: e, canvas: t}) {
        this.wrapperEl = e,
        this.setViewSize(),
        this.glCanvas = new lC({
            el: t
        }),
        this.camera = new cC,
        this.scene = new oS,
        this.mainImage = null,
        this.blockNoise = null,
        this.holographic1 = null,
        this.holographic2 = null,
        this.isReady = !1,
        this.lastTime = this.getTime(),
        window.addEventListener("resize", this.resize)
    }
    setViewSize = () => {
        const e = this.wrapperEl.clientWidth
          , t = this.wrapperEl.clientHeight;
        Di.viewSize.width = e,
        Di.viewSize.height = t
    }
    ;
    setupPageIndex = ({hitElement: e, blurElements: t}) => {
        this.mainImage = new vT({
            hitElement: e,
            blurElements: t,
            onLoad: () => {
                this.isReady = !0,
                this.resize()
            }
        }),
        this.blockNoise = new uC,
        this.setHolographic(),
        this.scene.add(this.mainImage.mesh, this.holographic1.mesh, this.holographic2.mesh)
    }
    ;
    setHolographic = () => {
        const t = window.matchMedia(Xs).matches ? .8 : 1
          , i = 100 * t
          , n = 50 * t
          , r = Di.viewSize.width * .5 - i * .5
          , o = Di.viewSize.height * .5 - 150;
        this.holographic1 || (this.holographic1 = new x_({
            width: i,
            height: n,
            seed: .5
        })),
        this.holographic1.mesh.position.x = r,
        this.holographic1.mesh.position.y = o;
        const a = 120 * t
          , l = 40 * t
          , c = Di.viewSize.width * -.5 + a * .5
          , h = Di.viewSize.height * -.5 + 140;
        this.holographic2 || (this.holographic2 = new x_({
            width: a,
            height: l,
            seed: 4.05
        })),
        this.holographic2.mesh.position.x = c,
        this.holographic2.mesh.position.y = h
    }
    ;
    getTime = () => performance.now() * .001;
    getTimeScale = e => e * 60;
    ticker = () => {
        if (!this.isReady)
            return;
        this.stats?.begin();
        const e = this.getTime();
        this.lastTime = e,
        this.blockNoise.update({
            time: e
        }),
        this.holographic1.update({
            time: e
        }),
        this.holographic2.update({
            time: e
        }),
        this.mainImage.update({
            time: e,
            blockNoiseTexture: this.blockNoise.texture
        }),
        this.glCanvas.render({
            scene: this.scene,
            camera: this.camera
        }),
        this.stats?.end()
    }
    ;
    resize = () => {
        this.setViewSize(),
        this.glCanvas.resize(),
        this.camera.setSize(),
        this.mainImage.resize(),
        this.setHolographic()
    }
    ;
    dispose = () => {
        this.selfLoop && window.cancelAnimationFrame(this.rafId),
        window.removeEventListener("resize", this.resize)
    }
}
const pC = s => {
    const e = s.getBoundingClientRect()
      , t = e.left + (e.right - e.left) * .5
      , i = e.top + (e.bottom - e.top) * .5
      , n = t < window.innerWidth * .5;
    let r = 0
      , o = 0;
    n ? (r = `${t - s.offsetWidth * .5}px`,
    o = "auto") : (o = `${window.innerWidth - (t + s.offsetWidth * .5)}px`,
    r = "auto"),
    s.style.top = `${i - s.offsetHeight * .5}px`,
    s.style.left = r,
    s.style.right = o
}
  , $c = {
    zIndex: 0
};
class mC {
    constructor({el: e, handleTarget: t, disableMedia: i}) {
        this.el = e,
        this.handleTarget = t || e,
        this.offsetX = 0,
        this.offsetY = 0,
        this.isHover = !1,
        this.disableMedia = i;
        const n = getComputedStyle(e)
          , r = n.transform || n.mozTransform;
        this.matrixArray = r === "none" ? [1, 0, 0, 1, 0, 0] : r.split("(")[1].split(")")[0].split(",").map(o => Number(o)),
        $c.zIndex = Math.max($c.zIndex, Number(getComputedStyle(e).getPropertyValue("z-index"))),
        this.el.addEventListener("mouseenter", this.handleMouseEnter),
        this.el.addEventListener("mouseleave", this.handleMouseLeave),
        this.el.addEventListener("mousedown", this.handleMouseDown),
        window.addEventListener("mouseup", this.handleMouseUp)
    }
    isHandle = e => typeof this.handleTarget == "string" ? e.target.closest(this.handleTarget) : this.handleTarget.contains(e.target);
    handleMouseEnter = e => {
        window.matchMedia(this.disableMedia).matches || this.isHandle(e) && (this.isHover = !0,
        document.body.style.cursor = "grab")
    }
    ;
    handleMouseLeave = () => {
        document.body.style.cursor = "auto",
        this.isHover = !1
    }
    ;
    handleMouseDown = e => {
        if (window.matchMedia(this.disableMedia).matches)
            return;
        if (e.target.closest("button,a"))
            return !1;
        if (!this.isHandle(e))
            return;
        this.offsetX = e.clientX,
        this.offsetY = e.clientY,
        document.body.style.userSelect = "none",
        document.body.style.cursor = "grabbing";
        const t = $c.zIndex + 1;
        this.el.style.zIndex = t,
        $c.zIndex = t,
        window.addEventListener("mousemove", this.handleMouseMove)
    }
    ;
    handleMouseMove = e => {
        const t = e.clientX - this.offsetX
          , i = e.clientY - this.offsetY;
        this.matrixArray[4] = t,
        this.matrixArray[5] = i,
        this.el.style.transform = `matrix(${this.matrixArray.join(",")})`
    }
    ;
    handleMouseUp = () => {
        if (window.removeEventListener("mousemove", this.handleMouseMove),
        window.matchMedia(this.disableMedia).matches)
            return !1;
        document.body.style.userSelect = "auto",
        document.body.style.cursor = this.isHover ? "grab" : "auto",
        pC(this.el),
        this.matrixArray[4] = 0,
        this.matrixArray[5] = 0,
        this.el.style.transform = `matrix(${this.matrixArray.join(",")})`
    }
}
let sp = !1;
const op = document.querySelector('[data-js="hamburger-button"]')
  , sy = document.querySelector('[data-js="hamburger-button-inner"]')
  , Rh = document.querySelector('[data-js="hamburger-menu"]')
  , gC = () => {
    sp = !0,
    op.setAttribute("aria-expanded", "true"),
    Rh.setAttribute("aria-hidden", "false"),
    Gi.to(Rh.children, {
        autoAlpha: 1,
        duration: .01,
        overwrite: !0,
        stagger: {
            each: .12
        }
    }),
    sy.textContent = "X"
}
  , _C = () => {
    sp = !1,
    op.setAttribute("aria-expanded", "false"),
    Rh.setAttribute("aria-hidden", "true"),
    Gi.to(Rh.children, {
        autoAlpha: 0,
        duration: .01,
        overwrite: !0,
        stagger: {
            each: .12,
            from: "end"
        }
    }),
    sy.textContent = "Menu"
}
  , xC = () => {
    sp ? _C() : gC()
}
  , yC = () => {
    op.addEventListener("click", xC)
}
;
let ch = null
  , yd = null;
const vC = s => {
    yd?.kill(),
    yd = Gi.timeline();
    const e = .001
      , t = .1
      , i = .4;
    s.forEach( (n, r) => {
        for (; n.firstChild; )
            n.removeChild(n.firstChild);
        const a = n.getAttribute("data-text").split("")
          , l = a.map(f => ({
            char: f
        }));
        n.style.height = "1.5em";
        const c = document.createElement("span");
        n.appendChild(c);
        const h = r === 0 ? 0 : e * s[r - 1].children.length + i;
        let u = 0
          , d = "";
        yd.to(l, {
            duration: e,
            onStart: () => {
                n.appendChild(ch)
            }
            ,
            stagger: {
                each: t,
                onComplete: () => {
                    d += a[u],
                    c.textContent = d,
                    u++
                }
            }
        }, r === 0 ? ">" : `>+=${h}`)
    }
    )
}
  , MC = () => {
    const s = [...document.querySelectorAll('[data-js="typewriter-line"]')];
    ch = document.createElement("span"),
    ch.classList.add("c-typewriter-cursor");
    let e = !0;
    setInterval( () => {
        ch.style.opacity = e ? 1 : 0,
        e = !e
    }
    , 500);
    const t = window.matchMedia(Xs)
      , i = n => {
        const o = n.matches ? "pc" : "sp"
          , a = s.filter(l => l.getAttribute("data-only-show") !== o);
        vC(a)
    }
    ;
    t.addEventListener("change", i),
    i(t)
}
  , vd = 1.6
  , SC = ({glAnimation: s= () => {}
, onComplete: e= () => {}
}) => {
    const t = Gi.timeline({
        onComplete: e,
        paused: !0
    })
      , i = document.querySelector('[data-js="loading-overlay"]');
    t.set(i, {
        display: "none"
    });
    const n = [...document.querySelectorAll('[data-js="opening-frame"]')];
    t.to(n, {
        "--this-scale": 1,
        duration: vd,
        ease: "power3.inOut"
    });
    const r = document.querySelector('[data-js="grid-columns"')
      , o = document.querySelector('[data-js="grid-rows"');
    t.to(o.children, {
        "--this-scale": 1,
        duration: vd,
        ease: "power3.inOut",
        stagger: {
            each: .01,
            ease: "power3.inOut"
        }
    }, "<+=0.4"),
    t.to(r.children, {
        "--this-scale": 1,
        duration: vd,
        ease: "power3.inOut",
        stagger: {
            each: .01,
            ease: "power3.inOut"
        }
    }, "<");
    const a = document.querySelector('[data-js="outer"]')
      , l = document.querySelector('[data-js="header"]')
      , c = document.querySelector('[data-js="header-inner"]')
      , h = document.querySelector('[data-js="footer"]')
      , u = document.querySelector('[data-js="profile-image"]')
      , d = document.querySelector('[data-js="barcode"]')
      , f = document.querySelector('[data-js="gl-main"]');
    t.from([a, c, h, u, d, f], {
        opacity: 0,
        duration: .6,
        ease: "elastic.in(1.5,0.1)",
        onComplete: () => {
            n.forEach(p => {
                p.style.opacity = 0
            }
            ),
            l.style.borderColor = "currentColor"
        }
    }, ">-=0.6"),
    t.add(s(), ">+=0.2");
    const m = document.querySelector('[data-js="index-dialog-soon"]')
      , _ = document.querySelector('[data-js="index-dialog-social"]');
    if (window.matchMedia(Xs).matches)
        Gi.from(m.children, {
            opacity: 0,
            duration: .01,
            stagger: {
                each: .1
            },
            scrollTrigger: {
                trigger: m,
                start: "top bottom-=30%",
                once: !0
            }
        }),
        Gi.from(_.children, {
            opacity: 0,
            duration: .01,
            stagger: {
                each: .1
            },
            scrollTrigger: {
                trigger: _,
                start: "top bottom-=30%",
                once: !0
            }
        });
    else {
        const p = [...m.children, ..._.children];
        t.from(p, {
            opacity: 0,
            duration: .01,
            stagger: {
                each: .1
            }
        })
    }
    window.addEventListener("kvImageLoad", () => {
        t.play()
    }
    )
}
;
let Md = 0;
const bC = s => {
    const e = () => {
        const t = window.innerWidth < Y0
          , i = window.innerWidth === Md;
        t && i || s(),
        Md = window.innerWidth
    }
    ;
    return Md = window.innerWidth,
    window.addEventListener("resize", e),
    () => {
        window.removeEventListener("resize", e)
    }
}
;
let y_ = 0;
const TC = () => {
    const s = [...document.querySelectorAll("[data-kv-load]")]
      , e = () => {
        y_++,
        y_ === s.length && window.dispatchEvent(new CustomEvent("kvImageLoad"))
    }
    ;
    s.forEach(t => {
        t.complete ? e() : (t.addEventListener("load", e),
        t.addEventListener("error", e))
    }
    )
}
;
let xr = null
  , Mr = null;
const v_ = () => {
    const s = document.documentElement
      , e = document.body;
    xr === null && (xr = {
        position: window.getComputedStyle(e).position,
        top: window.getComputedStyle(e).top,
        left: window.getComputedStyle(e).left
    },
    Mr = {
        top: s.scrollTop || e.scrollTop,
        left: s.scrollLeft || e.scrollLeft
    })
}
  , EC = () => {
    if (!xr || !Mr)
        return;
    const s = document.body;
    s.style.position = xr.position,
    s.style.top = xr.top,
    s.style.left = xr.left,
    window.scrollTo(Mr.left, Mr.top),
    xr = null,
    Mr = null
}
  , wC = () => {
    if (!xr || !Mr)
        return;
    const s = document.body;
    s.style.position = "fixed",
    s.style.top = `${-Mr.top}px`,
    s.style.left = `${-Mr.left}px`
}
;
let Sd = !0;
const M_ = s => {
    (!xr || !Mr) && v_(),
    Sd = typeof s == "boolean" ? s : !Sd,
    Sd ? EC() : (v_(),
    wC())
}
  , AC = () => {
    [...document.querySelectorAll('[data-js="copy-to-clipboard"]')].forEach(e => {
        let t = !1;
        const i = n => {
            n.preventDefault(),
            !t && (e.setAttribute("data-copied-active", !0),
            navigator.clipboard.writeText(Xv),
            setTimeout( () => {
                e.removeAttribute("data-copied-active"),
                t = !1
            }
            , 1e3))
        }
        ;
        e.addEventListener("click", i)
    }
    )
}
  , RC = () => {
    Gi.registerPlugin(_t),
    window.scrollTo(0, 0),
    M_(!1),
    Zv(),
    Yp(),
    window.addEventListener("resize", Yp),
    Yv(),
    Wp(),
    bC(Wp),
    yC(),
    AC();
    const s = document.querySelector('[data-js="gl-main"]')
      , e = document.querySelector('[data-js="gl-main-hit"]')
      , t = document.querySelector('[data-js="gl-main-blur-wrapper"]')
      , i = new fC({
        canvasWrapper: s,
        canvas: s.querySelector("canvas")
    });
    i.setupPageIndex({
        hitElement: e,
        blurElements: [...t.children]
    }),
    Gi.ticker.add(i.ticker),
    SC({
        glAnimation: () => {
            const {mainImage: f} = i
              , m = Gi.timeline({
                onComplete: () => {
                    f.slider.restartTimer(),
                    M_(!0)
                }
            });
            return m.to(f, {
                scaleRatio: 1,
                duration: .1,
                ease: "power3.out"
            }),
            m.from(t, {
                scale: 0,
                duration: .1,
                ease: "power3.out"
            }, "<"),
            m.to(f.mesh.material.uniforms.uShake, {
                value: 0,
                duration: 1,
                ease: "power3.out"
            }, "<"),
            m
        }
        ,
        onComplete: () => {
            window.matchMedia(Xs).matches && document.querySelector('[data-js="hamburger-button"]').click(),
            MC()
        }
    }),
    TC();
    const n = [...document.querySelector('[data-js="index-dialog-soon"]').children, ...document.querySelector('[data-js="index-dialog-social"]').children, document.querySelector('[data-js="profile-image"]')];
    n.forEach(f => {
        new mC({
            el: f,
            handleTarget: f.querySelector('[data-js="dialog-box-header"]'),
            disableMedia: Xs
        })
    }
    );
    const r = f => {
        f.style.top = "",
        f.style.left = "",
        f.style.right = "",
        f.style.transform = ""
    }
    ;
    window.matchMedia(Xs).addEventListener("change", () => {
        n.forEach(f => {
            r(f)
        }
        )
    }
    ),
    [...document.querySelectorAll('[data-js="dialog-box"]')].forEach(f => {
        let m = 0;
        const _ = () => {
            clearTimeout(m),
            f.setAttribute("data-blink", !0),
            m = setTimeout( () => {
                f.removeAttribute("data-blink")
            }
            , 250)
        }
        ;
        f.querySelector('[data-js="dialog-box-close"]').addEventListener("click", _)
    }
    );
    const l = document.querySelector('[data-js="gl-bonus"]');
    l.style.display = "none",
    l.style.mixBlendMode = "luminosity";
    let c = null
      , h = 0;
    const u = ["", "exclusion", "darken", "difference"];
    setInterval( () => {
        const f = new Date
          , m = f.getHours()
          , _ = f.getMinutes();
        m === 1 && _ === 9 ? (l.style.display = "block",
        l.style.mixBlendMode = u[h % u.length],
        c || cy( () => import("./effect.js"), __vite__mapDeps([])).then(p => {
            c = new p.GLBonus({
                canvasWrapper: l,
                canvas: l.querySelector("canvas"),
                texturePath: "/images/1-09.png"
            }),
            Gi.ticker.add(c.ticker)
        }
        ),
        h++) : (l.style.display = "none",
        c && Gi.ticker.remove(c.ticker))
    }
    , 1e3)
}
;
window.addEventListener("DOMContentLoaded", RC);
export {cC as C, lC as G, Yn as M, Ll as P, wr as S, Rt as V, oS as a, Di as g, xT as l};
function __vite__mapDeps(indexes) {
    if (!__vite__mapDeps.viteFileDeps) {
        __vite__mapDeps.viteFileDeps = []
    }
    return indexes.map( (i) => __vite__mapDeps.viteFileDeps[i])
}
